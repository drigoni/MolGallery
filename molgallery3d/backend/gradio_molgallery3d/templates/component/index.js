const Block_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$7,
  assign: assign$1,
  create_slot: create_slot$2,
  detach: detach$7,
  element: element$5,
  get_all_dirty_from_scope: get_all_dirty_from_scope$2,
  get_slot_changes: get_slot_changes$2,
  get_spread_update: get_spread_update$1,
  init: init$7,
  insert: insert$7,
  safe_not_equal: safe_not_equal$8,
  set_dynamic_element_data,
  set_style: set_style$3,
  toggle_class: toggle_class$5,
  transition_in: transition_in$5,
  transition_out: transition_out$5,
  update_slot_base: update_slot_base$2
} = window.__gradio__svelte__internal;
function create_dynamic_element(P) {
  let _, s, v;
  const M = (
    /*#slots*/
    P[17].default
  ), E = create_slot$2(
    M,
    P,
    /*$$scope*/
    P[16],
    null
  );
  let A = [
    { "data-testid": (
      /*test_id*/
      P[7]
    ) },
    { id: (
      /*elem_id*/
      P[2]
    ) },
    {
      class: s = "block " + /*elem_classes*/
      P[3].join(" ") + " svelte-1t38q2d"
    }
  ], h = {};
  for (let g = 0; g < A.length; g += 1)
    h = assign$1(h, A[g]);
  return {
    c() {
      _ = element$5(
        /*tag*/
        P[14]
      ), E && E.c(), set_dynamic_element_data(
        /*tag*/
        P[14]
      )(_, h), toggle_class$5(
        _,
        "hidden",
        /*visible*/
        P[10] === !1
      ), toggle_class$5(
        _,
        "padded",
        /*padding*/
        P[6]
      ), toggle_class$5(
        _,
        "border_focus",
        /*border_mode*/
        P[5] === "focus"
      ), toggle_class$5(_, "hide-container", !/*explicit_call*/
      P[8] && !/*container*/
      P[9]), set_style$3(_, "height", typeof /*height*/
      P[0] == "number" ? (
        /*height*/
        P[0] + "px"
      ) : void 0), set_style$3(_, "width", typeof /*width*/
      P[1] == "number" ? `calc(min(${/*width*/
      P[1]}px, 100%))` : void 0), set_style$3(
        _,
        "border-style",
        /*variant*/
        P[4]
      ), set_style$3(
        _,
        "overflow",
        /*allow_overflow*/
        P[11] ? "visible" : "hidden"
      ), set_style$3(
        _,
        "flex-grow",
        /*scale*/
        P[12]
      ), set_style$3(_, "min-width", `calc(min(${/*min_width*/
      P[13]}px, 100%))`), set_style$3(_, "border-width", "var(--block-border-width)");
    },
    m(g, C) {
      insert$7(g, _, C), E && E.m(_, null), v = !0;
    },
    p(g, C) {
      E && E.p && (!v || C & /*$$scope*/
      65536) && update_slot_base$2(
        E,
        M,
        g,
        /*$$scope*/
        g[16],
        v ? get_slot_changes$2(
          M,
          /*$$scope*/
          g[16],
          C,
          null
        ) : get_all_dirty_from_scope$2(
          /*$$scope*/
          g[16]
        ),
        null
      ), set_dynamic_element_data(
        /*tag*/
        g[14]
      )(_, h = get_spread_update$1(A, [
        (!v || C & /*test_id*/
        128) && { "data-testid": (
          /*test_id*/
          g[7]
        ) },
        (!v || C & /*elem_id*/
        4) && { id: (
          /*elem_id*/
          g[2]
        ) },
        (!v || C & /*elem_classes*/
        8 && s !== (s = "block " + /*elem_classes*/
        g[3].join(" ") + " svelte-1t38q2d")) && { class: s }
      ])), toggle_class$5(
        _,
        "hidden",
        /*visible*/
        g[10] === !1
      ), toggle_class$5(
        _,
        "padded",
        /*padding*/
        g[6]
      ), toggle_class$5(
        _,
        "border_focus",
        /*border_mode*/
        g[5] === "focus"
      ), toggle_class$5(_, "hide-container", !/*explicit_call*/
      g[8] && !/*container*/
      g[9]), C & /*height*/
      1 && set_style$3(_, "height", typeof /*height*/
      g[0] == "number" ? (
        /*height*/
        g[0] + "px"
      ) : void 0), C & /*width*/
      2 && set_style$3(_, "width", typeof /*width*/
      g[1] == "number" ? `calc(min(${/*width*/
      g[1]}px, 100%))` : void 0), C & /*variant*/
      16 && set_style$3(
        _,
        "border-style",
        /*variant*/
        g[4]
      ), C & /*allow_overflow*/
      2048 && set_style$3(
        _,
        "overflow",
        /*allow_overflow*/
        g[11] ? "visible" : "hidden"
      ), C & /*scale*/
      4096 && set_style$3(
        _,
        "flex-grow",
        /*scale*/
        g[12]
      ), C & /*min_width*/
      8192 && set_style$3(_, "min-width", `calc(min(${/*min_width*/
      g[13]}px, 100%))`);
    },
    i(g) {
      v || (transition_in$5(E, g), v = !0);
    },
    o(g) {
      transition_out$5(E, g), v = !1;
    },
    d(g) {
      g && detach$7(_), E && E.d(g);
    }
  };
}
function create_fragment$7(P) {
  let _, s = (
    /*tag*/
    P[14] && create_dynamic_element(P)
  );
  return {
    c() {
      s && s.c();
    },
    m(v, M) {
      s && s.m(v, M), _ = !0;
    },
    p(v, [M]) {
      /*tag*/
      v[14] && s.p(v, M);
    },
    i(v) {
      _ || (transition_in$5(s, v), _ = !0);
    },
    o(v) {
      transition_out$5(s, v), _ = !1;
    },
    d(v) {
      s && s.d(v);
    }
  };
}
function instance$6(P, _, s) {
  let { $$slots: v = {}, $$scope: M } = _, { height: E = void 0 } = _, { width: A = void 0 } = _, { elem_id: h = "" } = _, { elem_classes: g = [] } = _, { variant: C = "solid" } = _, { border_mode: c = "base" } = _, { padding: S = !0 } = _, { type: y = "normal" } = _, { test_id: b = void 0 } = _, { explicit_call: w = !1 } = _, { container: t = !0 } = _, { visible: r = !0 } = _, { allow_overflow: u = !0 } = _, { scale: o = null } = _, { min_width: l = 0 } = _, e = y === "fieldset" ? "fieldset" : "div";
  return P.$$set = (n) => {
    "height" in n && s(0, E = n.height), "width" in n && s(1, A = n.width), "elem_id" in n && s(2, h = n.elem_id), "elem_classes" in n && s(3, g = n.elem_classes), "variant" in n && s(4, C = n.variant), "border_mode" in n && s(5, c = n.border_mode), "padding" in n && s(6, S = n.padding), "type" in n && s(15, y = n.type), "test_id" in n && s(7, b = n.test_id), "explicit_call" in n && s(8, w = n.explicit_call), "container" in n && s(9, t = n.container), "visible" in n && s(10, r = n.visible), "allow_overflow" in n && s(11, u = n.allow_overflow), "scale" in n && s(12, o = n.scale), "min_width" in n && s(13, l = n.min_width), "$$scope" in n && s(16, M = n.$$scope);
  }, [
    E,
    A,
    h,
    g,
    C,
    c,
    S,
    b,
    w,
    t,
    r,
    u,
    o,
    l,
    e,
    y,
    M,
    v
  ];
}
class Block extends SvelteComponent$7 {
  constructor(_) {
    super(), init$7(this, _, instance$6, create_fragment$7, safe_not_equal$8, {
      height: 0,
      width: 1,
      elem_id: 2,
      elem_classes: 3,
      variant: 4,
      border_mode: 5,
      padding: 6,
      type: 15,
      test_id: 7,
      explicit_call: 8,
      container: 9,
      visible: 10,
      allow_overflow: 11,
      scale: 12,
      min_width: 13
    });
  }
}
const Info_svelte_svelte_type_style_lang = "", BlockTitle_svelte_svelte_type_style_lang = "", BlockLabel_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$6,
  append: append$5,
  attr: attr$5,
  create_component: create_component$3,
  destroy_component: destroy_component$3,
  detach: detach$6,
  element: element$4,
  init: init$6,
  insert: insert$6,
  mount_component: mount_component$3,
  safe_not_equal: safe_not_equal$7,
  set_data: set_data$2,
  space: space$3,
  text: text$2,
  toggle_class: toggle_class$4,
  transition_in: transition_in$4,
  transition_out: transition_out$4
} = window.__gradio__svelte__internal;
function create_fragment$6(P) {
  let _, s, v, M, E, A;
  return v = new /*Icon*/
  P[1]({}), {
    c() {
      _ = element$4("label"), s = element$4("span"), create_component$3(v.$$.fragment), M = space$3(), E = text$2(
        /*label*/
        P[0]
      ), attr$5(s, "class", "svelte-9gxdi0"), attr$5(_, "for", ""), attr$5(_, "data-testid", "block-label"), attr$5(_, "class", "svelte-9gxdi0"), toggle_class$4(_, "hide", !/*show_label*/
      P[2]), toggle_class$4(_, "sr-only", !/*show_label*/
      P[2]), toggle_class$4(
        _,
        "float",
        /*float*/
        P[4]
      ), toggle_class$4(
        _,
        "hide-label",
        /*disable*/
        P[3]
      );
    },
    m(h, g) {
      insert$6(h, _, g), append$5(_, s), mount_component$3(v, s, null), append$5(_, M), append$5(_, E), A = !0;
    },
    p(h, [g]) {
      (!A || g & /*label*/
      1) && set_data$2(
        E,
        /*label*/
        h[0]
      ), (!A || g & /*show_label*/
      4) && toggle_class$4(_, "hide", !/*show_label*/
      h[2]), (!A || g & /*show_label*/
      4) && toggle_class$4(_, "sr-only", !/*show_label*/
      h[2]), (!A || g & /*float*/
      16) && toggle_class$4(
        _,
        "float",
        /*float*/
        h[4]
      ), (!A || g & /*disable*/
      8) && toggle_class$4(
        _,
        "hide-label",
        /*disable*/
        h[3]
      );
    },
    i(h) {
      A || (transition_in$4(v.$$.fragment, h), A = !0);
    },
    o(h) {
      transition_out$4(v.$$.fragment, h), A = !1;
    },
    d(h) {
      h && detach$6(_), destroy_component$3(v);
    }
  };
}
function instance$5(P, _, s) {
  let { label: v = null } = _, { Icon: M } = _, { show_label: E = !0 } = _, { disable: A = !1 } = _, { float: h = !0 } = _;
  return P.$$set = (g) => {
    "label" in g && s(0, v = g.label), "Icon" in g && s(1, M = g.Icon), "show_label" in g && s(2, E = g.show_label), "disable" in g && s(3, A = g.disable), "float" in g && s(4, h = g.float);
  }, [v, M, E, A, h];
}
class BlockLabel extends SvelteComponent$6 {
  constructor(_) {
    super(), init$6(this, _, instance$5, create_fragment$6, safe_not_equal$7, {
      label: 0,
      Icon: 1,
      show_label: 2,
      disable: 3,
      float: 4
    });
  }
}
const IconButton_svelte_svelte_type_style_lang = "", Empty_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$5,
  append: append$4,
  attr: attr$4,
  binding_callbacks: binding_callbacks$1,
  create_slot: create_slot$1,
  detach: detach$5,
  element: element$3,
  get_all_dirty_from_scope: get_all_dirty_from_scope$1,
  get_slot_changes: get_slot_changes$1,
  init: init$5,
  insert: insert$5,
  safe_not_equal: safe_not_equal$6,
  toggle_class: toggle_class$3,
  transition_in: transition_in$3,
  transition_out: transition_out$3,
  update_slot_base: update_slot_base$1
} = window.__gradio__svelte__internal;
function create_fragment$5(P) {
  let _, s, v;
  const M = (
    /*#slots*/
    P[5].default
  ), E = create_slot$1(
    M,
    P,
    /*$$scope*/
    P[4],
    null
  );
  return {
    c() {
      _ = element$3("div"), s = element$3("div"), E && E.c(), attr$4(s, "class", "icon svelte-3w3rth"), attr$4(_, "class", "empty svelte-3w3rth"), attr$4(_, "aria-label", "Empty value"), toggle_class$3(
        _,
        "small",
        /*size*/
        P[0] === "small"
      ), toggle_class$3(
        _,
        "large",
        /*size*/
        P[0] === "large"
      ), toggle_class$3(
        _,
        "unpadded_box",
        /*unpadded_box*/
        P[1]
      ), toggle_class$3(
        _,
        "small_parent",
        /*parent_height*/
        P[3]
      );
    },
    m(A, h) {
      insert$5(A, _, h), append$4(_, s), E && E.m(s, null), P[6](_), v = !0;
    },
    p(A, [h]) {
      E && E.p && (!v || h & /*$$scope*/
      16) && update_slot_base$1(
        E,
        M,
        A,
        /*$$scope*/
        A[4],
        v ? get_slot_changes$1(
          M,
          /*$$scope*/
          A[4],
          h,
          null
        ) : get_all_dirty_from_scope$1(
          /*$$scope*/
          A[4]
        ),
        null
      ), (!v || h & /*size*/
      1) && toggle_class$3(
        _,
        "small",
        /*size*/
        A[0] === "small"
      ), (!v || h & /*size*/
      1) && toggle_class$3(
        _,
        "large",
        /*size*/
        A[0] === "large"
      ), (!v || h & /*unpadded_box*/
      2) && toggle_class$3(
        _,
        "unpadded_box",
        /*unpadded_box*/
        A[1]
      ), (!v || h & /*parent_height*/
      8) && toggle_class$3(
        _,
        "small_parent",
        /*parent_height*/
        A[3]
      );
    },
    i(A) {
      v || (transition_in$3(E, A), v = !0);
    },
    o(A) {
      transition_out$3(E, A), v = !1;
    },
    d(A) {
      A && detach$5(_), E && E.d(A), P[6](null);
    }
  };
}
function _optionalChain(P) {
  let _, s = P[0], v = 1;
  for (; v < P.length; ) {
    const M = P[v], E = P[v + 1];
    if (v += 2, (M === "optionalAccess" || M === "optionalCall") && s == null)
      return;
    M === "access" || M === "optionalAccess" ? (_ = s, s = E(s)) : (M === "call" || M === "optionalCall") && (s = E((...A) => s.call(_, ...A)), _ = void 0);
  }
  return s;
}
function instance$4(P, _, s) {
  let v, { $$slots: M = {}, $$scope: E } = _, { size: A = "small" } = _, { unpadded_box: h = !1 } = _, g;
  function C(S) {
    if (!S)
      return !1;
    const { height: y } = S.getBoundingClientRect(), { height: b } = _optionalChain([
      S,
      "access",
      (w) => w.parentElement,
      "optionalAccess",
      (w) => w.getBoundingClientRect,
      "call",
      (w) => w()
    ]) || { height: y };
    return y > b + 2;
  }
  function c(S) {
    binding_callbacks$1[S ? "unshift" : "push"](() => {
      g = S, s(2, g);
    });
  }
  return P.$$set = (S) => {
    "size" in S && s(0, A = S.size), "unpadded_box" in S && s(1, h = S.unpadded_box), "$$scope" in S && s(4, E = S.$$scope);
  }, P.$$.update = () => {
    P.$$.dirty & /*el*/
    4 && s(3, v = C(g));
  }, [A, h, g, v, E, M, c];
}
class Empty extends SvelteComponent$5 {
  constructor(_) {
    super(), init$5(this, _, instance$4, create_fragment$5, safe_not_equal$6, { size: 0, unpadded_box: 1 });
  }
}
const DropdownArrow_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$4,
  append: append$3,
  attr: attr$3,
  detach: detach$4,
  init: init$4,
  insert: insert$4,
  noop: noop$4,
  safe_not_equal: safe_not_equal$5,
  svg_element: svg_element$1
} = window.__gradio__svelte__internal;
function create_fragment$4(P) {
  let _, s, v, M;
  return {
    c() {
      _ = svg_element$1("svg"), s = svg_element$1("rect"), v = svg_element$1("circle"), M = svg_element$1("polyline"), attr$3(s, "x", "3"), attr$3(s, "y", "3"), attr$3(s, "width", "18"), attr$3(s, "height", "18"), attr$3(s, "rx", "2"), attr$3(s, "ry", "2"), attr$3(v, "cx", "8.5"), attr$3(v, "cy", "8.5"), attr$3(v, "r", "1.5"), attr$3(M, "points", "21 15 16 10 5 21"), attr$3(_, "xmlns", "http://www.w3.org/2000/svg"), attr$3(_, "width", "100%"), attr$3(_, "height", "100%"), attr$3(_, "viewBox", "0 0 24 24"), attr$3(_, "fill", "none"), attr$3(_, "stroke", "currentColor"), attr$3(_, "stroke-width", "1.5"), attr$3(_, "stroke-linecap", "round"), attr$3(_, "stroke-linejoin", "round"), attr$3(_, "class", "feather feather-image");
    },
    m(E, A) {
      insert$4(E, _, A), append$3(_, s), append$3(_, v), append$3(_, M);
    },
    p: noop$4,
    i: noop$4,
    o: noop$4,
    d(E) {
      E && detach$4(_);
    }
  };
}
class Image extends SvelteComponent$4 {
  constructor(_) {
    super(), init$4(this, _, null, create_fragment$4, safe_not_equal$5, {});
  }
}
const color_values = [
  { color: "red", primary: 600, secondary: 100 },
  { color: "green", primary: 600, secondary: 100 },
  { color: "blue", primary: 600, secondary: 100 },
  { color: "yellow", primary: 500, secondary: 100 },
  { color: "purple", primary: 600, secondary: 100 },
  { color: "teal", primary: 600, secondary: 100 },
  { color: "orange", primary: 600, secondary: 100 },
  { color: "cyan", primary: 600, secondary: 100 },
  { color: "lime", primary: 500, secondary: 100 },
  { color: "pink", primary: 600, secondary: 100 }
], tw_colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
color_values.reduce(
  (P, { color: _, primary: s, secondary: v }) => ({
    ...P,
    [_]: {
      primary: tw_colors[_][s],
      secondary: tw_colors[_][v]
    }
  }),
  {}
);
const UploadText_svelte_svelte_type_style_lang = "", Toolbar_svelte_svelte_type_style_lang = "", SelectSource_svelte_svelte_type_style_lang = "";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(P) {
  return P && P.__esModule && Object.prototype.hasOwnProperty.call(P, "default") ? P.default : P;
}
var _3Dmol = { exports: {} };
/*!
 * 3dmol v2.0.6
 * JavaScript/TypeScript molecular visualization library
 * Author: David Koes and contributors
 */
(function(module, exports) {
  (function(_, s) {
    module.exports = s();
  })(commonjsGlobal, () => (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        "./node_modules/iobuffer/lib-esm/IOBuffer.js": (
          /*!***************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/IOBuffer.js ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              IOBuffer: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var v = s(
              /*! ./text */
              "./node_modules/iobuffer/lib-esm/text.browser.js"
            );
            const M = 1024 * 8, E = (() => {
              const g = new Uint8Array(4), C = new Uint32Array(g.buffer);
              return !((C[0] = 1) & g[0]);
            })(), A = {
              int8: globalThis.Int8Array,
              uint8: globalThis.Uint8Array,
              int16: globalThis.Int16Array,
              uint16: globalThis.Uint16Array,
              int32: globalThis.Int32Array,
              uint32: globalThis.Uint32Array,
              uint64: globalThis.BigUint64Array,
              int64: globalThis.BigInt64Array,
              float32: globalThis.Float32Array,
              float64: globalThis.Float64Array
            };
            class h {
              /**
               * @param data - The data to construct the IOBuffer with.
               * If data is a number, it will be the new buffer's length<br>
               * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
               * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
               * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
               * @param options
               */
              constructor(C = M, c = {}) {
                let S = !1;
                typeof C == "number" ? C = new ArrayBuffer(C) : (S = !0, this.lastWrittenByte = C.byteLength);
                const y = c.offset ? c.offset >>> 0 : 0, b = C.byteLength - y;
                let w = y;
                (ArrayBuffer.isView(C) || C instanceof h) && (C.byteLength !== C.buffer.byteLength && (w = C.byteOffset + y), C = C.buffer), S ? this.lastWrittenByte = b : this.lastWrittenByte = 0, this.buffer = C, this.length = b, this.byteLength = b, this.byteOffset = w, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, w, b), this._mark = 0, this._marks = [];
              }
              /**
               * Checks if the memory allocated to the buffer is sufficient to store more
               * bytes after the offset.
               * @param byteLength - The needed memory in bytes.
               * @returns `true` if there is sufficient space and `false` otherwise.
               */
              available(C = 1) {
                return this.offset + C <= this.length;
              }
              /**
               * Check if little-endian mode is used for reading and writing multi-byte
               * values.
               * @returns `true` if little-endian mode is used, `false` otherwise.
               */
              isLittleEndian() {
                return this.littleEndian;
              }
              /**
               * Set little-endian mode for reading and writing multi-byte values.
               */
              setLittleEndian() {
                return this.littleEndian = !0, this;
              }
              /**
               * Check if big-endian mode is used for reading and writing multi-byte values.
               * @returns `true` if big-endian mode is used, `false` otherwise.
               */
              isBigEndian() {
                return !this.littleEndian;
              }
              /**
               * Switches to big-endian mode for reading and writing multi-byte values.
               */
              setBigEndian() {
                return this.littleEndian = !1, this;
              }
              /**
               * Move the pointer n bytes forward.
               * @param n - Number of bytes to skip.
               */
              skip(C = 1) {
                return this.offset += C, this;
              }
              /**
               * Move the pointer n bytes backward.
               * @param n - Number of bytes to move back.
               */
              back(C = 1) {
                return this.offset -= C, this;
              }
              /**
               * Move the pointer to the given offset.
               * @param offset
               */
              seek(C) {
                return this.offset = C, this;
              }
              /**
               * Store the current pointer offset.
               * @see {@link IOBuffer#reset}
               */
              mark() {
                return this._mark = this.offset, this;
              }
              /**
               * Move the pointer back to the last pointer offset set by mark.
               * @see {@link IOBuffer#mark}
               */
              reset() {
                return this.offset = this._mark, this;
              }
              /**
               * Push the current pointer offset to the mark stack.
               * @see {@link IOBuffer#popMark}
               */
              pushMark() {
                return this._marks.push(this.offset), this;
              }
              /**
               * Pop the last pointer offset from the mark stack, and set the current
               * pointer offset to the popped value.
               * @see {@link IOBuffer#pushMark}
               */
              popMark() {
                const C = this._marks.pop();
                if (C === void 0)
                  throw new Error("Mark stack empty");
                return this.seek(C), this;
              }
              /**
               * Move the pointer offset back to 0.
               */
              rewind() {
                return this.offset = 0, this;
              }
              /**
               * Make sure the buffer has sufficient memory to write a given byteLength at
               * the current pointer offset.
               * If the buffer's memory is insufficient, this method will create a new
               * buffer (a copy) with a length that is twice (byteLength + current offset).
               * @param byteLength
               */
              ensureAvailable(C = 1) {
                if (!this.available(C)) {
                  const S = (this.offset + C) * 2, y = new Uint8Array(S);
                  y.set(new Uint8Array(this.buffer)), this.buffer = y.buffer, this.length = this.byteLength = S, this._data = new DataView(this.buffer);
                }
                return this;
              }
              /**
               * Read a byte and return false if the byte's value is 0, or true otherwise.
               * Moves pointer forward by one byte.
               */
              readBoolean() {
                return this.readUint8() !== 0;
              }
              /**
               * Read a signed 8-bit integer and move pointer forward by 1 byte.
               */
              readInt8() {
                return this._data.getInt8(this.offset++);
              }
              /**
               * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
               */
              readUint8() {
                return this._data.getUint8(this.offset++);
              }
              /**
               * Alias for {@link IOBuffer#readUint8}.
               */
              readByte() {
                return this.readUint8();
              }
              /**
               * Read `n` bytes and move pointer forward by `n` bytes.
               */
              readBytes(C = 1) {
                return this.readArray(C, "uint8");
              }
              /**
               * Creates an array of corresponding to the type `type` and size `size`.
               * For example type `uint8` will create a `Uint8Array`.
               * @param size - size of the resulting array
               * @param type - number type of elements to read
               */
              readArray(C, c) {
                const S = A[c].BYTES_PER_ELEMENT * C, y = this.byteOffset + this.offset, b = this.buffer.slice(y, y + S);
                if (this.littleEndian === E && c !== "uint8" && c !== "int8") {
                  const t = new Uint8Array(this.buffer.slice(y, y + S));
                  t.reverse();
                  const r = new A[c](t.buffer);
                  return this.offset += S, r.reverse(), r;
                }
                const w = new A[c](b);
                return this.offset += S, w;
              }
              /**
               * Read a 16-bit signed integer and move pointer forward by 2 bytes.
               */
              readInt16() {
                const C = this._data.getInt16(this.offset, this.littleEndian);
                return this.offset += 2, C;
              }
              /**
               * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
               */
              readUint16() {
                const C = this._data.getUint16(this.offset, this.littleEndian);
                return this.offset += 2, C;
              }
              /**
               * Read a 32-bit signed integer and move pointer forward by 4 bytes.
               */
              readInt32() {
                const C = this._data.getInt32(this.offset, this.littleEndian);
                return this.offset += 4, C;
              }
              /**
               * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
               */
              readUint32() {
                const C = this._data.getUint32(this.offset, this.littleEndian);
                return this.offset += 4, C;
              }
              /**
               * Read a 32-bit floating number and move pointer forward by 4 bytes.
               */
              readFloat32() {
                const C = this._data.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4, C;
              }
              /**
               * Read a 64-bit floating number and move pointer forward by 8 bytes.
               */
              readFloat64() {
                const C = this._data.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8, C;
              }
              /**
               * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
               */
              readBigInt64() {
                const C = this._data.getBigInt64(this.offset, this.littleEndian);
                return this.offset += 8, C;
              }
              /**
               * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
               */
              readBigUint64() {
                const C = this._data.getBigUint64(this.offset, this.littleEndian);
                return this.offset += 8, C;
              }
              /**
               * Read a 1-byte ASCII character and move pointer forward by 1 byte.
               */
              readChar() {
                return String.fromCharCode(this.readInt8());
              }
              /**
               * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
               */
              readChars(C = 1) {
                let c = "";
                for (let S = 0; S < C; S++)
                  c += this.readChar();
                return c;
              }
              /**
               * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
               * forward by `n` bytes.
               */
              readUtf8(C = 1) {
                return (0, v.decode)(this.readBytes(C));
              }
              /**
               * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
               * forward by `n` bytes.
               * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
               */
              decodeText(C = 1, c = "utf-8") {
                return (0, v.decode)(this.readBytes(C), c);
              }
              /**
               * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
               * forward by 1 byte.
               */
              writeBoolean(C) {
                return this.writeUint8(C ? 255 : 0), this;
              }
              /**
               * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
               */
              writeInt8(C) {
                return this.ensureAvailable(1), this._data.setInt8(this.offset++, C), this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
               * byte.
               */
              writeUint8(C) {
                return this.ensureAvailable(1), this._data.setUint8(this.offset++, C), this._updateLastWrittenByte(), this;
              }
              /**
               * An alias for {@link IOBuffer#writeUint8}.
               */
              writeByte(C) {
                return this.writeUint8(C);
              }
              /**
               * Write all elements of `bytes` as uint8 values and move pointer forward by
               * `bytes.length` bytes.
               */
              writeBytes(C) {
                this.ensureAvailable(C.length);
                for (let c = 0; c < C.length; c++)
                  this._data.setUint8(this.offset++, C[c]);
                return this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit signed integer and move pointer forward by 2
               * bytes.
               */
              writeInt16(C) {
                return this.ensureAvailable(2), this._data.setInt16(this.offset, C, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
               * bytes.
               */
              writeUint16(C) {
                return this.ensureAvailable(2), this._data.setUint16(this.offset, C, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit signed integer and move pointer forward by 4
               * bytes.
               */
              writeInt32(C) {
                return this.ensureAvailable(4), this._data.setInt32(this.offset, C, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
               * bytes.
               */
              writeUint32(C) {
                return this.ensureAvailable(4), this._data.setUint32(this.offset, C, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit floating number and move pointer forward by 4
               * bytes.
               */
              writeFloat32(C) {
                return this.ensureAvailable(4), this._data.setFloat32(this.offset, C, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit floating number and move pointer forward by 8
               * bytes.
               */
              writeFloat64(C) {
                return this.ensureAvailable(8), this._data.setFloat64(this.offset, C, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit signed bigint and move pointer forward by 8
               * bytes.
               */
              writeBigInt64(C) {
                return this.ensureAvailable(8), this._data.setBigInt64(this.offset, C, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
               * bytes.
               */
              writeBigUint64(C) {
                return this.ensureAvailable(8), this._data.setBigUint64(this.offset, C, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write the charCode of `str`'s first character as an 8-bit unsigned integer
               * and move pointer forward by 1 byte.
               */
              writeChar(C) {
                return this.writeUint8(C.charCodeAt(0));
              }
              /**
               * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
               * and move pointer forward by `str.length` bytes.
               */
              writeChars(C) {
                for (let c = 0; c < C.length; c++)
                  this.writeUint8(C.charCodeAt(c));
                return this;
              }
              /**
               * UTF-8 encode and write `str` to the current pointer offset and move pointer
               * forward according to the encoded length.
               */
              writeUtf8(C) {
                return this.writeBytes((0, v.encode)(C));
              }
              /**
               * Export a Uint8Array view of the internal buffer.
               * The view starts at the byte offset and its length
               * is calculated to stop at the last written byte or the original length.
               */
              toArray() {
                return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
              }
              /**
               * Update the last written byte offset
               * @private
               */
              _updateLastWrittenByte() {
                this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
              }
            }
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js": (
          /*!*****************************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js ***!
            \*****************************************************************/
          /***/
          function() {
            (function(P) {
              if (P.TextEncoder && P.TextDecoder)
                return !1;
              function _(v = "utf-8") {
                if (v !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${v}') is invalid.`);
              }
              Object.defineProperty(_.prototype, "encoding", {
                value: "utf-8"
              }), _.prototype.encode = function(v, M = { stream: !1 }) {
                if (M.stream)
                  throw new Error("Failed to encode: the 'stream' option is unsupported.");
                let E = 0;
                const A = v.length;
                let h = 0, g = Math.max(32, A + (A >> 1) + 7), C = new Uint8Array(g >> 3 << 3);
                for (; E < A; ) {
                  let c = v.charCodeAt(E++);
                  if (c >= 55296 && c <= 56319) {
                    if (E < A) {
                      const S = v.charCodeAt(E);
                      (S & 64512) === 56320 && (++E, c = ((c & 1023) << 10) + (S & 1023) + 65536);
                    }
                    if (c >= 55296 && c <= 56319)
                      continue;
                  }
                  if (h + 4 > C.length) {
                    g += 8, g *= 1 + E / v.length * 2, g = g >> 3 << 3;
                    const S = new Uint8Array(g);
                    S.set(C), C = S;
                  }
                  if (c & 4294967168)
                    if (!(c & 4294965248))
                      C[h++] = c >> 6 & 31 | 192;
                    else if (!(c & 4294901760))
                      C[h++] = c >> 12 & 15 | 224, C[h++] = c >> 6 & 63 | 128;
                    else if (!(c & 4292870144))
                      C[h++] = c >> 18 & 7 | 240, C[h++] = c >> 12 & 63 | 128, C[h++] = c >> 6 & 63 | 128;
                    else
                      continue;
                  else {
                    C[h++] = c;
                    continue;
                  }
                  C[h++] = c & 63 | 128;
                }
                return C.slice(0, h);
              };
              function s(v = "utf-8", M = { fatal: !1 }) {
                if (v !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${v}') is invalid.`);
                if (M.fatal)
                  throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
              }
              Object.defineProperty(s.prototype, "encoding", {
                value: "utf-8"
              }), Object.defineProperty(s.prototype, "fatal", { value: !1 }), Object.defineProperty(s.prototype, "ignoreBOM", {
                value: !1
              }), s.prototype.decode = function(v, M = { stream: !1 }) {
                if (M.stream)
                  throw new Error("Failed to decode: the 'stream' option is unsupported.");
                const E = new Uint8Array(v);
                let A = 0;
                const h = E.length, g = [];
                for (; A < h; ) {
                  const C = E[A++];
                  if (C === 0)
                    break;
                  if (!(C & 128))
                    g.push(C);
                  else if ((C & 224) === 192) {
                    const c = E[A++] & 63;
                    g.push((C & 31) << 6 | c);
                  } else if ((C & 240) === 224) {
                    const c = E[A++] & 63, S = E[A++] & 63;
                    g.push((C & 31) << 12 | c << 6 | S);
                  } else if ((C & 248) === 240) {
                    const c = E[A++] & 63, S = E[A++] & 63, y = E[A++] & 63;
                    let b = (C & 7) << 18 | c << 12 | S << 6 | y;
                    b > 65535 && (b -= 65536, g.push(b >>> 10 & 1023 | 55296), b = 56320 | b & 1023), g.push(b);
                  }
                }
                return String.fromCharCode.apply(null, g);
              }, P.TextEncoder = _, P.TextDecoder = s;
            })(typeof window < "u" ? window : typeof self < "u" ? self : this);
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text.browser.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text.browser.js ***!
            \*******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              decode: () => (
                /* binding */
                v
              ),
              /* harmony export */
              encode: () => (
                /* binding */
                E
              )
              /* harmony export */
            }), s(
              /*! ./text-encoding-polyfill */
              "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js"
            );
            function v(A, h = "utf8") {
              return new TextDecoder(h).decode(A);
            }
            const M = new TextEncoder();
            function E(A) {
              return M.encode(A);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/data.js": (
          /*!***********************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/data.js ***!
            \***********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              nonRecord: () => (
                /* binding */
                M
              ),
              /* harmony export */
              record: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            );
            function M(A, h) {
              const g = (0, v.str2num)(h.type), C = h.size / (0, v.num2bytes)(g), c = new Array(C);
              for (let S = 0; S < C; S++)
                c[S] = (0, v.readType)(A, g, 1);
              return c;
            }
            function E(A, h, g) {
              const C = (0, v.str2num)(h.type), c = h.size ? h.size / (0, v.num2bytes)(C) : 1, S = g.length, y = new Array(S), b = g.recordStep;
              if (b)
                for (let w = 0; w < S; w++) {
                  const t = A.offset;
                  y[w] = (0, v.readType)(A, C, c), A.seek(t + b);
                }
              else
                throw new Error("recordDimension.recordStep is undefined");
              return y;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/header.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/header.js ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              header: () => (
                /* binding */
                c
              )
              /* harmony export */
            });
            var v = s(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            ), M = s(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            const E = 0, A = 10, h = 11, g = 12, C = 0;
            function c(w, t) {
              const r = { version: t }, u = {
                length: w.readUint32()
              }, o = S(w);
              Array.isArray(o) || (u.id = o.recordId, u.name = o.recordName, r.dimensions = o.dimensions), r.globalAttributes = y(w);
              const l = b(w, u == null ? void 0 : u.id, t);
              return Array.isArray(l) || (r.variables = l.variables, u.recordStep = l.recordStep), r.recordDimension = u, r;
            }
            function S(w) {
              const t = {};
              let r, u;
              const o = w.readUint32();
              let l;
              if (o === E)
                return (0, M.notNetcdf)(w.readUint32() !== E, "wrong empty tag for list of dimensions"), [];
              {
                (0, M.notNetcdf)(o !== A, "wrong tag for list of dimensions");
                const e = w.readUint32();
                l = new Array(e);
                for (let n = 0; n < e; n++) {
                  const a = (0, M.readName)(w), p = w.readUint32();
                  p === C && (r = n, u = a), l[n] = {
                    name: a,
                    size: p
                  };
                }
              }
              return r !== void 0 && (t.recordId = r), u !== void 0 && (t.recordName = u), t.dimensions = l, t;
            }
            function y(w) {
              const t = w.readUint32();
              let r;
              if (t === E)
                return (0, M.notNetcdf)(w.readUint32() !== E, "wrong empty tag for list of attributes"), [];
              {
                (0, M.notNetcdf)(t !== g, "wrong tag for list of attributes");
                const u = w.readUint32();
                r = new Array(u);
                for (let o = 0; o < u; o++) {
                  const l = (0, M.readName)(w), e = w.readUint32();
                  (0, M.notNetcdf)(e < 1 || e > 6, `non valid type ${e}`);
                  const n = w.readUint32(), a = (0, v.readType)(w, e, n);
                  (0, M.padding)(w), r[o] = {
                    name: l,
                    type: (0, v.num2str)(e),
                    value: a
                  };
                }
              }
              return r;
            }
            function b(w, t, r) {
              const u = w.readUint32();
              let o = 0, l;
              if (u === E)
                return (0, M.notNetcdf)(w.readUint32() !== E, "wrong empty tag for list of variables"), [];
              {
                (0, M.notNetcdf)(u !== h, "wrong tag for list of variables");
                const e = w.readUint32();
                l = new Array(e);
                for (let n = 0; n < e; n++) {
                  const a = (0, M.readName)(w), p = w.readUint32(), x = new Array(p);
                  for (let B = 0; B < p; B++)
                    x[B] = w.readUint32();
                  const D = y(w), O = w.readUint32();
                  (0, M.notNetcdf)(O < 1 && O > 6, `non valid type ${O}`);
                  const R = w.readUint32();
                  let z = w.readUint32();
                  r === 2 && ((0, M.notNetcdf)(z > 0, "offsets larger than 4GB not supported"), z = w.readUint32());
                  let T = !1;
                  typeof t < "u" && x[0] === t && (o += R, T = !0), l[n] = {
                    name: a,
                    dimensions: x,
                    attributes: D,
                    type: (0, v.num2str)(O),
                    size: R,
                    offset: z,
                    record: T
                  };
                }
              }
              return {
                variables: l,
                recordStep: o
              };
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/index.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/index.js ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              NetCDFReader: () => (
                /* reexport safe */
                v.NetCDFReader
              )
              /* harmony export */
            });
            var v = s(
              /*! ./parser */
              "./node_modules/netcdfjs/lib-esm/parser.js"
            );
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/parser.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/parser.js ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              NetCDFReader: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! iobuffer */
              "./node_modules/iobuffer/lib-esm/IOBuffer.js"
            ), M = s(
              /*! ./data */
              "./node_modules/netcdfjs/lib-esm/data.js"
            ), E = s(
              /*! ./header */
              "./node_modules/netcdfjs/lib-esm/header.js"
            ), A = s(
              /*! ./toString */
              "./node_modules/netcdfjs/lib-esm/toString.js"
            ), h = s(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            class g {
              constructor(c) {
                this.toString = A.toString;
                const S = new v.IOBuffer(c);
                S.setBigEndian(), (0, h.notNetcdf)(S.readChars(3) !== "CDF", "should start with CDF");
                const y = S.readByte();
                (0, h.notNetcdf)(y > 2, "unknown version"), this.header = (0, E.header)(S, y), this.buffer = S;
              }
              /**
               * @return - Version for the NetCDF format
               */
              get version() {
                return this.header.version === 1 ? "classic format" : "64-bit offset format";
              }
              /**
               * @return {object} - Metadata for the record dimension
               *  * `length`: Number of elements in the record dimension
               *  * `id`: Id number in the list of dimensions for the record dimension
               *  * `name`: String with the name of the record dimension
               *  * `recordStep`: Number with the record variables step size
               */
              get recordDimension() {
                return this.header.recordDimension;
              }
              /**
               * @return - Array - List of dimensions with:
               *  * `name`: String with the name of the dimension
               *  * `size`: Number with the size of the dimension
               */
              get dimensions() {
                return this.header.dimensions;
              }
              /**
               * @return - Array - List of global attributes with:
               *  * `name`: String with the name of the attribute
               *  * `type`: String with the type of the attribute
               *  * `value`: A number or string with the value of the attribute
               */
              get globalAttributes() {
                return this.header.globalAttributes;
              }
              /**
               * Returns the value of an attribute
               * @param - AttributeName
               * @return - Value of the attributeName or null
               */
              getAttribute(c) {
                const S = this.globalAttributes.find((y) => y.name === c);
                return S ? S.value : null;
              }
              /**
               * Returns the value of a variable as a string
               * @param - variableName
               * @return - Value of the variable as a string or null
               */
              getDataVariableAsString(c) {
                const S = this.getDataVariable(c);
                return S ? S.join("") : null;
              }
              get variables() {
                return this.header.variables;
              }
              /**
               * Retrieves the data for a given variable
               * @param variableName - Name of the variable to search or variable object
               * @return The variable values
               */
              getDataVariable(c) {
                let S;
                if (typeof c == "string" ? S = this.header.variables.find((y) => y.name === c) : S = c, S === void 0)
                  throw new Error("Not a valid NetCDF v3.x file: variable not found");
                return this.buffer.seek(S.offset), S.record ? (0, M.record)(this.buffer, S, this.header.recordDimension) : (0, M.nonRecord)(this.buffer, S);
              }
              /**
               * Check if a dataVariable exists
               * @param variableName - Name of the variable to find
               * @return boolean
               */
              dataVariableExists(c) {
                return this.header.variables.find((y) => y.name === c) !== void 0;
              }
              /**
               * Check if an attribute exists
               * @param attributeName - Name of the attribute to find
               * @return boolean
               */
              attributeExists(c) {
                return this.globalAttributes.find((y) => y.name === c) !== void 0;
              }
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/toString.js": (
          /*!***************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/toString.js ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              toString: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v() {
              const M = [];
              M.push("DIMENSIONS");
              for (const A of this.dimensions)
                M.push(`  ${A.name.padEnd(30)} = size: ${A.size}`);
              M.push(""), M.push("GLOBAL ATTRIBUTES");
              for (const A of this.globalAttributes)
                M.push(`  ${A.name.padEnd(30)} = ${A.value}`);
              const E = JSON.parse(JSON.stringify(this.variables));
              M.push(""), M.push("VARIABLES:");
              for (const A of E) {
                A.value = this.getDataVariable(A);
                let h = JSON.stringify(A.value);
                h.length > 50 && (h = h.substring(0, 50)), isNaN(A.value.length) || (h += ` (length: ${A.value.length})`), M.push(`  ${A.name.padEnd(30)} = ${h}`);
              }
              return M.join(`
`);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/types.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/types.js ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              num2bytes: () => (
                /* binding */
                E
              ),
              /* harmony export */
              num2str: () => (
                /* binding */
                M
              ),
              /* harmony export */
              readType: () => (
                /* binding */
                g
              ),
              /* harmony export */
              str2num: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            const v = {
              BYTE: 1,
              CHAR: 2,
              SHORT: 3,
              INT: 4,
              FLOAT: 5,
              DOUBLE: 6
            };
            function M(c) {
              switch (Number(c)) {
                case v.BYTE:
                  return "byte";
                case v.CHAR:
                  return "char";
                case v.SHORT:
                  return "short";
                case v.INT:
                  return "int";
                case v.FLOAT:
                  return "float";
                case v.DOUBLE:
                  return "double";
                default:
                  return "undefined";
              }
            }
            function E(c) {
              switch (Number(c)) {
                case v.BYTE:
                  return 1;
                case v.CHAR:
                  return 1;
                case v.SHORT:
                  return 2;
                case v.INT:
                  return 4;
                case v.FLOAT:
                  return 4;
                case v.DOUBLE:
                  return 8;
                default:
                  return -1;
              }
            }
            function A(c) {
              switch (String(c)) {
                case "byte":
                  return v.BYTE;
                case "char":
                  return v.CHAR;
                case "short":
                  return v.SHORT;
                case "int":
                  return v.INT;
                case "float":
                  return v.FLOAT;
                case "double":
                  return v.DOUBLE;
                default:
                  return -1;
              }
            }
            function h(c, S) {
              if (c !== 1) {
                const y = new Array(c);
                for (let b = 0; b < c; b++)
                  y[b] = S();
                return y;
              } else
                return S();
            }
            function g(c, S, y) {
              switch (S) {
                case v.BYTE:
                  return Array.from(c.readBytes(y));
                case v.CHAR:
                  return C(c.readChars(y));
                case v.SHORT:
                  return h(y, c.readInt16.bind(c));
                case v.INT:
                  return h(y, c.readInt32.bind(c));
                case v.FLOAT:
                  return h(y, c.readFloat32.bind(c));
                case v.DOUBLE:
                  return h(y, c.readFloat64.bind(c));
                default:
                  throw new Error(`non valid type ${S}`);
              }
            }
            function C(c) {
              return c.charCodeAt(c.length - 1) === 0 ? c.substring(0, c.length - 1) : c;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/utils.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/utils.js ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              notNetcdf: () => (
                /* binding */
                v
              ),
              /* harmony export */
              padding: () => (
                /* binding */
                M
              ),
              /* harmony export */
              readName: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            function v(A, h) {
              if (A)
                throw new TypeError(`Not a valid NetCDF v3.x file: ${h}`);
            }
            function M(A) {
              A.offset % 4 !== 0 && A.skip(4 - A.offset % 4);
            }
            function E(A) {
              const h = A.readUint32(), g = A.readChars(h);
              return M(A), g;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.frag": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.frag ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 viewMatrix;
uniform float opacity;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
varying vec3 vColor;
//DEFINEFRAGCOLOR
void main() {
    gl_FragColor = vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.vert": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.vert ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

attribute vec3 position;
attribute vec3 color;

varying vec3 vColor;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.frag": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.frag ***!
            \********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.vert": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.vert ***!
            \********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 offset;
attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.frag ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.vert ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag ***!
            \****************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vLightBack;

varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    if ( gl_FrontFacing )
       gl_FragColor.xyz *= vLightFront;
    else
       gl_FragColor.xyz *= vLightBack;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert ***!
            \****************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;
varying vec3 vLightBack;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );
    vLightBack = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;
    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.frag ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
//DEFINEFRAGCOLOR

void main() {
    gl_FragColor = vec4( outlineColor, 1 );
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.vert ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

void main() {

    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    mvPosition.xy += norm.xy*outlineWidth;
    gl_Position = projectionMatrix * mvPosition;
    mvPosition.z -= outlinePushback; //go backwards in model space
    vec4 pushpos = projectionMatrix*mvPosition; //project to get z in projection space, I'm probably missing some simple math to do the same thing..
    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.frag ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform sampler2D colormap;
varying highp vec2 vTexCoords;
uniform vec2 dimensions;
//DEFINEFRAGCOLOR
void main (void) {
   gl_FragColor = texture2D(colormap, vTexCoords);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.vert ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.frag": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.frag ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform sampler2D colormap;
varying highp vec2 vTexCoords;
uniform vec2 dimensions;

// Basic FXAA implementation based on the code on geeks3d.com 
#define FXAA_REDUCE_MIN (1.0/ 128.0)
#define FXAA_REDUCE_MUL (1.0 / 8.0)
#define FXAA_SPAN_MAX 8.0

vec4 applyFXAA(vec2 fragCoord, sampler2D tex)
{
    vec4 color;
    vec2 inverseVP = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);
    vec3 rgbNW = texture2D(tex, fragCoord + vec2(-1.0, -1.0) * inverseVP).xyz;
    vec3 rgbNE = texture2D(tex, fragCoord + vec2(1.0, -1.0) * inverseVP).xyz;
    vec3 rgbSW = texture2D(tex, fragCoord + vec2(-1.0, 1.0) * inverseVP).xyz;
    vec3 rgbSE = texture2D(tex, fragCoord + vec2(1.0, 1.0) * inverseVP).xyz;
    vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
            dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
        texture2D(tex, fragCoord + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture2D(tex, fragCoord  + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture2D(tex, fragCoord  + dir * -0.5).xyz +
        texture2D(tex, fragCoord  + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, 1.0);
    else
        color = vec4(rgbB, 1.0);
    return color;
}
//DEFINEFRAGCOLOR
void main (void) {
   gl_FragColor = applyFXAA(vTexCoords, colormap);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.vert": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.vert ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag ***!
            \******************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `
uniform mat4 viewMatrix;
uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform float uDepth;
uniform vec3 directionalLightColor[ 1 ];

varying vec3 vColor;
varying vec2 mapping;
varying float rval;
varying vec3 vLight;
varying vec3 center;

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));
    float dotProduct = dot( norm, vLight );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;
    gl_FragColor = vec4(vLight*vColor, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, gl_FragDepthEXT/gl_FragCoord.w );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );


}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert ***!
            \******************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying vec3 vColor;
varying float rval;
varying vec3 vLight;
varying vec3 center;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz );
    mapping = normal.xy;
    rval = abs(normal.x);
    gl_Position = projPosition+adjust;

}
`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag ***!
            \********************************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform mat4 projectionMatrix;
varying vec2 mapping;
varying float rval;
varying vec3 center;

uniform float outlinePushback;

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragColor = vec4(outlineColor, 1 );
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert ***!
            \********************************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying float rval;
varying vec3 center;

void main() {

    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);
    vec4 adjust = projectionMatrix* vec4(norm,normal.z,0.0); adjust.z = 0.0; adjust.w = 0.0;
    mapping = norm.xy;
    rval = abs(norm.x);
    gl_Position = projPosition+adjust;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.frag ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform vec3 color;
uniform sampler2D map;
uniform float opacity;

uniform int fogType;
uniform vec3 fogColor;
uniform float fogDensity;
uniform float fogNear;
uniform float fogFar;
uniform float alphaTest;

varying vec2 vUV;
//DEFINEFRAGCOLOR

void main() {

    vec4 texture = texture2D(map, vUV);

    if (texture.a < alphaTest) discard;

    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);

    if (fogType > 0) {

        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float fogFactor = 0.0;

        if (fogType == 1) {
            fogFactor = smoothstep(fogNear, fogFar, depth);
        }

        else {
            const float LOG2 = 1.442695;
            float fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);
            fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);
        }

        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);

    }
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.vert ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform int useScreenCoordinates;
uniform vec3 screenPosition;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float rotation;
uniform vec2 scale;
uniform vec2 alignment;
uniform vec2 uvOffset;
uniform vec2 uvScale;

attribute vec2 position;
attribute vec2 uv;

varying vec2 vUV;

void main() {

    vUV = uvOffset + uv * uvScale;

    vec2 alignedPosition = position + alignment;

    vec2 rotatedPosition;
    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;
    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;

    vec4 finalPosition;

    if(useScreenCoordinates != 0) {
        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);
    }

    else {
        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;
        finalPosition.xy += rotatedPosition; 
    }

    gl_Position = finalPosition;

}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag": (
          /*!************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag ***!
            \************************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `    float dotProduct = dot( norm, vLight );
    vec3 light = vec3( max( dotProduct, 0.0 ) );
    gl_FragColor = vec4(light*color, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.vert ***!
            \****************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = color; vColor.z = abs(vColor.z); //z indicates which vertex and so would vary
    r = abs(radius);
    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }
    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p1);
         float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
         mvPosition.xyz = p1+t*pnorm; 
       } else { //orthographic
         mvPosition.xyz = p1;
       }
    } else {
      if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p2);
         float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
         mvPosition.xyz = p2+t*pnorm;
       } else { //orthographic
         mvPosition.xyz = p2;
       } 
       mult *= -1.0;
    }
    vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;
    mvPosition.xyz +=  mult*(cr + doublecr).xyz;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz )*directionalLightColor[0]; //not really sure this is right, but color is always white so..
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert": (
          /*!******************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert ***!
            \******************************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];
uniform vec3 outlineColor;
uniform float outlineWidth;
uniform float outlinePushback;


attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = outlineColor;
    float rad = radius+sign(radius)*outlineWidth;
    r = abs(rad);
    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
//pushback
    to.xyz += normalize(to.xyz)*outlinePushback;
    pt.xyz += normalize(pt.xyz)*outlinePushback;

    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }
    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       vec3 pnorm = normalize(p1);
       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
       mvPosition.xyz = p1+t*pnorm;
    } else {
       vec3 pnorm = normalize(p2);
       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
       mvPosition.xyz = p2+t*pnorm;
       mult *= -1.0;
    }
    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;
    mvPosition.xy +=  mult*(cr + doublecr).xy;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vLight = vec3(1.0,1.0,1.0);
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.frag": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.frag ***!
            \**********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `
uniform highp sampler3D data;
uniform highp sampler2D colormap;
uniform highp sampler2D depthmap;


uniform mat4 textmat;
uniform mat4 projinv;
uniform mat4 projectionMatrix;

uniform float step;
uniform float subsamples;
uniform float maxdepth;
uniform float transfermin;
uniform float transfermax;
in  vec4 mvPosition;
out vec4 color;
void main(void) {

   vec4 pos = mvPosition;
   bool seengood = false;
   float i = 0.0;
   color = vec4(1,1,1,0);
   float increment = 1.0/subsamples;
   float maxsteps = (maxdepth*subsamples/step);
//there's probably a better way to do this..
//calculate farthest possible point in model coordinates
   vec4 maxpos = vec4(pos.x,pos.y,pos.z-maxdepth,1.0);
// convert to projection
   maxpos = projectionMatrix*maxpos;
   vec4 startp = projectionMatrix*pos;
// homogonize
   maxpos /= maxpos.w;
   startp /= startp.w;
//take x,y from start and z from max
   maxpos = vec4(startp.x,startp.y,maxpos.z,1.0);
//convert back to model space
   maxpos = projinv*maxpos;
   maxpos /= maxpos.w;
   float incr = step/subsamples;
//get depth from depthmap
//startp is apparently [-1,1]
   vec2 tpos = startp.xy/2.0+0.5;
   float depth = texture(depthmap, tpos).r;
//compute vector between start and end
   vec4 direction = maxpos-pos;
   for( i = 0.0; i <= maxsteps; i++) {
      vec4 pt = (pos+(i/maxsteps)*direction);
      vec4 ppt = projectionMatrix*pt;
      float ptdepth = ppt.z/ppt.w;
      ptdepth = ((gl_DepthRange.diff * ptdepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
      if(ptdepth > depth) break;
      pt = textmat*pt;
//       pt /= pt.w;
      if(pt.x >= -0.01 && pt.y >= -0.01 && pt.z >= -0.01 && pt.x <= 1.01 && pt.y <= 1.01 && pt.z <= 1.01) {
         seengood = true;
      } else if(seengood) {
         break;
      }
      if( pt.x < -0.01 || pt.x > 1.01 || pt.y < -0.01 || pt.y > 1.01 || pt.z < -0.01 || pt.z > 1.01  ){
          color.a = 0.0;
          continue;
      }
      else {
         float val = texture(data, pt.zyx).r;
         if(isinf(val)) continue; //masked out
         float cval = (val-transfermin)/(transfermax-transfermin); //scale to texture 0-1 range
         vec4 val_color = texture(colormap, vec2(cval,0.5));
         color.rgb = color.rgb*color.a + (1.0-color.a)*val_color.a*val_color.rgb;
         color.a += (1.0 - color.a) * val_color.a; 
         if(color.a > 0.0) color.rgb /= color.a;
//          color = vec4(pt.x, pt.y, pt.z, 1.0);
      }
//       color = vec4(pt.x, pt.y, pt.z, 0.0)
    }
}

        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.vert": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.vert ***!
            \**********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;

in vec3 position;
out vec4 mvPosition;
void main() {

    mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix*mvPosition;
}
`;
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag": (
          /*!**************************************************************************!*\
            !*** ./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag ***!
            \**************************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              default: () => v
              /* harmony export */
            });
            const v = `uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLight;
varying vec3 vColor;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

//DEFINEFRAGCOLOR

//cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf
//also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl
//with a bit more care (caps) this could be a general cylinder imposter (see also outline)
void main() {
    vec3 color = abs(vColor);
    vec3 pos = cposition;
    vec3 p = pos; //ray point
    vec3 v = vec3(0.0,0.0,-1.0); //ray normal - orthographic
    if(projectionMatrix[3][3] == 0.0) v = normalize(pos); //ray normal - perspective
    vec3 pa = p1; //cyl start
    vec3 va = normalize(p2-p1); //cyl norm
    vec3 tmp1 = v-(dot(v,va)*va);
    vec3 deltap = p-pa;
    float A = dot(tmp1,tmp1);
    if(A == 0.0) discard;
    vec3 tmp2 = deltap-(dot(deltap,va)*va);
    float B = 2.0*dot(tmp1, tmp2);
    float C = dot(tmp2,tmp2)-r*r;
//quadratic equation!
    float det = (B*B) - (4.0*A*C);
    if(det < 0.0) discard;
    float sqrtDet = sqrt(det);
    float posT = (-B+sqrtDet)/(2.0*A);
    float negT = (-B-sqrtDet)/(2.0*A);
    float intersectionT = min(posT,negT);
    vec3 qi = p+v*intersectionT;
    float dotp1 = dot(va,qi-p1);
    float dotp2 = dot(va,qi-p2);
    vec3 norm;
    if( dotp1 < 0.0 || dotp2 > 0.0) { //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0
       vec3 cp;
       if( dotp1 < 0.0) {  
//        if(vColor.x < 0.0 ) discard; //color sign bit indicates if we should cap or not
        cp = p1;
       } else {
//          if(vColor.y < 0.0 ) discard;
          cp = p2;
       }
       vec3 diff = p-cp;
       A = dot(v,v);
       B = dot(diff,v)*2.0;
       C = dot(diff,diff)-r*r;
       det = (B*B) - (4.0*C);
       if(det < 0.0) discard;
       sqrtDet = sqrt(det);
       posT = (-B+sqrtDet)/(2.0);
       negT = (-B-sqrtDet)/(2.0);
       float t = min(posT,negT);
       qi = p+v*t; 
       norm = normalize(qi-cp); 
    } else {
       norm = normalize(qi-(dotp1*va + p1));
    }
    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragDepthEXT = depth;`;
          }
        ),
        /***/
        "./src/GLDraw.ts": (
          /*!***********************!*\
            !*** ./src/GLDraw.ts ***!
            \***********************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CAP: () => (
                /* binding */
                M
              ),
              /* harmony export */
              GLDraw: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), M;
            (function(A) {
              A[A.NONE = 0] = "NONE", A[A.FLAT = 1] = "FLAT", A[A.ROUND = 2] = "ROUND";
            })(M || (M = {}));
            var E;
            (function(A) {
              function h(t, r, u) {
                var o = Math.hypot(t, r), l, e, n, a, p;
                o < 1e-4 ? (e = 0, n = 1) : (e = -t / o, n = r / o), r = -e * t + n * r, l = Math.hypot(r, u), l < 1e-4 ? (a = 0, p = 1) : (a = u / l, p = r / l);
                var x = new Float32Array(9);
                return x[0] = n, x[1] = e, x[2] = 0, x[3] = -e * p, x[4] = n * p, x[5] = a, x[6] = e * a, x[7] = -n * a, x[8] = p, x;
              }
              class g {
                constructor() {
                  this.cache = {};
                  let r = [], u = 4, o = Math.pow(2, u), l = 2, e = Math.pow(2, l), n = o / e, a;
                  for (r[0] = new v.Vector3(-1, 0, 0), r[n] = new v.Vector3(0, 0, 1), r[n * 2] = new v.Vector3(1, 0, 0), r[n * 3] = new v.Vector3(0, 0, -1), l = 3; l <= u; l++) {
                    for (e = Math.pow(2, l - 1), n = o / e, a = 0; a < e - 1; a++)
                      r[n / 2 + a * n] = r[a * n].clone().add(r[(a + 1) * n]).normalize();
                    a = e - 1, r[n / 2 + a * n] = r[a * n].clone().add(r[0]).normalize();
                  }
                  this.basisVectors = r;
                }
                getVerticesForRadius(r, u, o) {
                  if (typeof this.cache < "u" && this.cache[r] !== void 0 && this.cache[r][u + o] !== void 0)
                    return this.cache[r][u + o];
                  for (var l = this.basisVectors.length, e = [], n = [], a, p = 0; p < l; p++)
                    e.push(this.basisVectors[p].clone().multiplyScalar(r)), e.push(this.basisVectors[p].clone().multiplyScalar(r)), a = this.basisVectors[p].clone().normalize(), n.push(a), n.push(a);
                  var x = [], D = 10, O = l, R = 0, z = Math.PI * 2, T = 0, B = Math.PI, W, k, F = !1, U = !1;
                  for (k = 0; k <= D; k++) {
                    F = k === 0 || k === D, U = k === D / 2;
                    var V = [], H = [];
                    for (W = 0; W <= O; W++) {
                      if (U) {
                        var G = W < O ? 2 * W : 0;
                        H.push(G + 1), V.push(G);
                        continue;
                      }
                      var Y = W / O, J = k / D;
                      if (!F || W === 0)
                        if (W < O) {
                          var re = new v.Vector3();
                          re.x = -r * Math.cos(R + Y * z) * Math.sin(T + J * B), u == 1 ? re.y = 0 : re.y = r * Math.cos(T + J * B), re.z = r * Math.sin(R + Y * z) * Math.sin(T + J * B), Math.abs(re.x) < 1e-5 && (re.x = 0), Math.abs(re.y) < 1e-5 && (re.y = 0), Math.abs(re.z) < 1e-5 && (re.z = 0), u == M.FLAT ? (a = new v.Vector3(0, Math.cos(T + J * B), 0), a.normalize()) : (a = new v.Vector3(re.x, re.y, re.z), a.normalize()), e.push(re), n.push(a), V.push(e.length - 1);
                        } else
                          V.push(e.length - O);
                      else
                        F && V.push(e.length - 1);
                    }
                    U && x.push(H), x.push(V);
                  }
                  var le = {
                    vertices: e,
                    normals: n,
                    verticesRows: x,
                    w: O,
                    h: D
                  };
                  return r in this.cache || (this.cache[r] = {}), this.cache[r][u + o] = le, le;
                }
              }
              var C = new g();
              function c(t, r, u, o, l, e = 0, n = 0) {
                if (!(!r || !u)) {
                  var a = n || e;
                  l = l || { r: 0, g: 0, b: 0 };
                  var p = h(u.x - r.x, u.y - r.y, u.z - r.z), x = C.getVerticesForRadius(o, n, "to"), D = x.w, O = x.h, R = a ? O * D + 2 : 2 * D, z = t.updateGeoGroup(R), T = x.vertices, B = x.normals, W = x.verticesRows, k = W[O / 2], F = W[O / 2 + 1], U = z.vertices, V, H, G, Y, J, re, le = z.vertexArray, ie = z.normalArray, xe = z.colorArray, se = z.faceArray;
                  for (G = 0; G < D; ++G) {
                    var ce = 2 * G;
                    Y = p[0] * T[ce].x + p[3] * T[ce].y + p[6] * T[ce].z, J = p[1] * T[ce].x + p[4] * T[ce].y + p[7] * T[ce].z, re = p[5] * T[ce].y + p[8] * T[ce].z, V = 3 * (U + ce), H = z.faceidx, le[V] = Y + r.x, le[V + 1] = J + r.y, le[V + 2] = re + r.z, le[V + 3] = Y + u.x, le[V + 4] = J + u.y, le[V + 5] = re + u.z, ie[V] = Y, ie[V + 3] = Y, ie[V + 1] = J, ie[V + 4] = J, ie[V + 2] = re, ie[V + 5] = re, xe[V] = l.r, xe[V + 3] = l.r, xe[V + 1] = l.g, xe[V + 4] = l.g, xe[V + 2] = l.b, xe[V + 5] = l.b, se[H] = F[G] + U, se[H + 1] = F[G + 1] + U, se[H + 2] = k[G] + U, se[H + 3] = k[G] + U, se[H + 4] = F[G + 1] + U, se[H + 5] = k[G + 1] + U, z.faceidx += 6;
                  }
                  if (a) {
                    var Ee = n ? 0 : O / 2, be = e ? O + 1 : O / 2 + 1, Le, ae, pe, we, Ge, We, je, Fe, ze, Be, Ie, Te, Re, ke, Ne, X, K, q, fe, ue, De, Se, Z, de, me, Pe, oe, Ce, j, Oe, He, I;
                    for (J = Ee; J < be; J++)
                      if (J !== O / 2) {
                        var ge = J <= O / 2 ? u : r, ve = C.getVerticesForRadius(o, n, "to"), $ = C.getVerticesForRadius(o, e, "from");
                        for (ge === u ? (T = ve.vertices, B = ve.normals, W = ve.verticesRows) : ge == r && (T = $.vertices, B = $.normals, W = $.verticesRows), Y = 0; Y < D; Y++)
                          H = z.faceidx, Le = W[J][Y + 1], j = (Le + U) * 3, ae = W[J][Y], Oe = (ae + U) * 3, pe = W[J + 1][Y], He = (pe + U) * 3, we = W[J + 1][Y + 1], I = (we + U) * 3, Ge = p[0] * T[Le].x + p[3] * T[Le].y + p[6] * T[Le].z, We = p[0] * T[ae].x + p[3] * T[ae].y + p[6] * T[ae].z, je = p[0] * T[pe].x + p[3] * T[pe].y + p[6] * T[pe].z, Fe = p[0] * T[we].x + p[3] * T[we].y + p[6] * T[we].z, ze = p[1] * T[Le].x + p[4] * T[Le].y + p[7] * T[Le].z, Be = p[1] * T[ae].x + p[4] * T[ae].y + p[7] * T[ae].z, Ie = p[1] * T[pe].x + p[4] * T[pe].y + p[7] * T[pe].z, Te = p[1] * T[we].x + p[4] * T[we].y + p[7] * T[we].z, Re = p[5] * T[Le].y + p[8] * T[Le].z, ke = p[5] * T[ae].y + p[8] * T[ae].z, Ne = p[5] * T[pe].y + p[8] * T[pe].z, X = p[5] * T[we].y + p[8] * T[we].z, le[j] = Ge + ge.x, le[Oe] = We + ge.x, le[He] = je + ge.x, le[I] = Fe + ge.x, le[j + 1] = ze + ge.y, le[Oe + 1] = Be + ge.y, le[He + 1] = Ie + ge.y, le[I + 1] = Te + ge.y, le[j + 2] = Re + ge.z, le[Oe + 2] = ke + ge.z, le[He + 2] = Ne + ge.z, le[I + 2] = X + ge.z, xe[j] = l.r, xe[Oe] = l.r, xe[He] = l.r, xe[I] = l.r, xe[j + 1] = l.g, xe[Oe + 1] = l.g, xe[He + 1] = l.g, xe[I + 1] = l.g, xe[j + 2] = l.b, xe[Oe + 2] = l.b, xe[He + 2] = l.b, xe[I + 2] = l.b, K = p[0] * B[Le].x + p[3] * B[Le].y + p[6] * B[Le].z, q = p[0] * B[ae].x + p[3] * B[ae].y + p[6] * B[ae].z, fe = p[0] * B[pe].x + p[3] * B[pe].y + p[6] * B[pe].z, ue = p[0] * B[we].x + p[3] * B[we].y + p[6] * B[we].z, De = p[1] * B[Le].x + p[4] * B[Le].y + p[7] * B[Le].z, Se = p[1] * B[ae].x + p[4] * B[ae].y + p[7] * B[ae].z, Z = p[1] * B[pe].x + p[4] * B[pe].y + p[7] * B[pe].z, de = p[1] * B[we].x + p[4] * B[we].y + p[7] * B[we].z, me = p[5] * B[Le].y + p[8] * B[Le].z, Pe = p[5] * B[ae].y + p[8] * B[ae].z, oe = p[5] * B[pe].y + p[8] * B[pe].z, Ce = p[5] * B[we].y + p[8] * B[we].z, J === 0 ? (ie[j] = K, ie[He] = fe, ie[I] = ue, ie[j + 1] = De, ie[He + 1] = Z, ie[I + 1] = de, ie[j + 2] = me, ie[He + 2] = oe, ie[I + 2] = Ce, se[H] = Le + U, se[H + 1] = pe + U, se[H + 2] = we + U, z.faceidx += 3) : J === be - 1 ? (ie[j] = K, ie[Oe] = q, ie[He] = fe, ie[j + 1] = De, ie[Oe + 1] = Se, ie[He + 1] = Z, ie[j + 2] = me, ie[Oe + 2] = Pe, ie[He + 2] = oe, se[H] = Le + U, se[H + 1] = ae + U, se[H + 2] = pe + U, z.faceidx += 3) : (ie[j] = K, ie[Oe] = q, ie[I] = ue, ie[j + 1] = De, ie[Oe + 1] = Se, ie[I + 1] = de, ie[j + 2] = me, ie[Oe + 2] = Pe, ie[I + 2] = Ce, ie[Oe] = q, ie[He] = fe, ie[I] = ue, ie[Oe + 1] = Se, ie[He + 1] = Z, ie[I + 1] = de, ie[Oe + 2] = Pe, ie[He + 2] = oe, ie[I + 2] = Ce, se[H] = Le + U, se[H + 1] = ae + U, se[H + 2] = we + U, se[H + 3] = ae + U, se[H + 4] = pe + U, se[H + 5] = we + U, z.faceidx += 6);
                      }
                  }
                  z.vertices += R;
                }
              }
              A.drawCylinder = c;
              function S(t, r, u, o, l) {
                if (!r || !u)
                  return;
                l = l || { r: 0, g: 0, b: 0 };
                let e = new v.Vector3(u.x - r.x, u.y - r.y, u.z - r.z);
                var n = h(e.x, e.y, e.z);
                e = e.normalize();
                var a = C.basisVectors.length, p = C.basisVectors, x = a + 2, D = t.updateGeoGroup(x), O = D.vertices, R, z, T, B, W, k, F = D.vertexArray, U = D.normalArray, V = D.colorArray, H = D.faceArray;
                for (R = O * 3, F[R] = r.x, F[R + 1] = r.y, F[R + 2] = r.z, U[R] = -e.x, U[R + 1] = -e.y, U[R + 2] = -e.z, V[R] = l.r, V[R + 1] = l.g, V[R + 2] = l.b, F[R + 3] = u.x, F[R + 4] = u.y, F[R + 5] = u.z, U[R + 3] = e.x, U[R + 4] = e.y, U[R + 5] = e.z, V[R + 3] = l.r, V[R + 4] = l.g, V[R + 5] = l.b, R += 6, T = 0; T < a; ++T) {
                  var G = p[T].clone();
                  G.multiplyScalar(o), B = n[0] * G.x + n[3] * G.y + n[6] * G.z, W = n[1] * G.x + n[4] * G.y + n[7] * G.z, k = n[5] * G.y + n[8] * G.z, F[R] = B + r.x, F[R + 1] = W + r.y, F[R + 2] = k + r.z, U[R] = B, U[R + 1] = W, U[R + 2] = k, V[R] = l.r, V[R + 1] = l.g, V[R + 2] = l.b, R += 3;
                }
                for (D.vertices += a + 2, z = D.faceidx, T = 0; T < a; T++) {
                  var Y = O + 2 + T, J = O + 2 + (T + 1) % a;
                  H[z] = Y, H[z + 1] = J, H[z + 2] = O, z += 3, H[z] = Y, H[z + 1] = J, H[z + 2] = O + 1, z += 3;
                }
                D.faceidx += 6 * a;
              }
              A.drawCone = S;
              class y {
                constructor() {
                  this.cache = /* @__PURE__ */ new Map();
                }
                getVerticesForRadius(r, u) {
                  u = u || 2, this.cache.has(u) || this.cache.set(u, /* @__PURE__ */ new Map());
                  let o = this.cache.get(u);
                  if (o.has(r))
                    return o.get(r);
                  var l = {
                    vertices: [],
                    verticesRows: [],
                    normals: []
                  }, e = 16 * u, n = 10 * u;
                  r < 1 && (e = 10 * u, n = 8 * u);
                  var a = 0, p = Math.PI * 2, x = 0, D = Math.PI, O, R;
                  for (R = 0; R <= n; R++) {
                    let T = [];
                    for (O = 0; O <= e; O++) {
                      let B = O / e, W = R / n, k = -r * Math.cos(a + B * p) * Math.sin(x + W * D), F = r * Math.cos(x + W * D), U = r * Math.sin(a + B * p) * Math.sin(x + W * D);
                      var z = new v.Vector3(k, F, U);
                      z.normalize(), l.vertices.push({ x: k, y: F, z: U }), l.normals.push(z), T.push(l.vertices.length - 1);
                    }
                    l.verticesRows.push(T);
                  }
                  return o.set(r, l), l;
                }
              }
              var b = new y();
              function w(t, r, u, o, l) {
                var e = b.getVerticesForRadius(u, l), n = e.vertices, a = e.normals, p = t.updateGeoGroup(n.length), x = p.vertices, D = p.vertexArray, O = p.colorArray, R = p.faceArray, z = p.lineArray, T = p.normalArray;
                for (let k = 0, F = n.length; k < F; ++k) {
                  let U = 3 * (x + k), V = n[k];
                  D[U] = V.x + r.x, D[U + 1] = V.y + r.y, D[U + 2] = V.z + r.z, O[U] = o.r, O[U + 1] = o.g, O[U + 2] = o.b;
                }
                p.vertices += n.length;
                let B = e.verticesRows, W = B.length - 1;
                for (let k = 0; k < W; k++) {
                  let F = B[k].length - 1;
                  for (let U = 0; U < F; U++) {
                    let V = p.faceidx, H = p.lineidx, G = B[k][U + 1] + x, Y = G * 3, J = B[k][U] + x, re = J * 3, le = B[k + 1][U] + x, ie = le * 3, xe = B[k + 1][U + 1] + x, se = xe * 3, ce = a[G - x], Ee = a[J - x], be = a[le - x], Le = a[xe - x];
                    Math.abs(n[G - x].y) === u ? (T[Y] = ce.x, T[ie] = be.x, T[se] = Le.x, T[Y + 1] = ce.y, T[ie + 1] = be.y, T[se + 1] = Le.y, T[Y + 2] = ce.z, T[ie + 2] = be.z, T[se + 2] = Le.z, R[V] = G, R[V + 1] = le, R[V + 2] = xe, z[H] = G, z[H + 1] = le, z[H + 2] = G, z[H + 3] = xe, z[H + 4] = le, z[H + 5] = xe, p.faceidx += 3, p.lineidx += 6) : Math.abs(n[le - x].y) === u ? (T[Y] = ce.x, T[re] = Ee.x, T[ie] = be.x, T[Y + 1] = ce.y, T[re + 1] = Ee.y, T[ie + 1] = be.y, T[Y + 2] = ce.z, T[re + 2] = Ee.z, T[ie + 2] = be.z, R[V] = G, R[V + 1] = J, R[V + 2] = le, z[H] = G, z[H + 1] = J, z[H + 2] = G, z[H + 3] = le, z[H + 4] = J, z[H + 5] = le, p.faceidx += 3, p.lineidx += 6) : (T[Y] = ce.x, T[re] = Ee.x, T[se] = Le.x, T[Y + 1] = ce.y, T[re + 1] = Ee.y, T[se + 1] = Le.y, T[Y + 2] = ce.z, T[re + 2] = Ee.z, T[se + 2] = Le.z, T[re] = Ee.x, T[ie] = be.x, T[se] = Le.x, T[re + 1] = Ee.y, T[ie + 1] = be.y, T[se + 1] = Le.y, T[re + 2] = Ee.z, T[ie + 2] = be.z, T[se + 2] = Le.z, R[V] = G, R[V + 1] = J, R[V + 2] = xe, R[V + 3] = J, R[V + 4] = le, R[V + 5] = xe, z[H] = G, z[H + 1] = J, z[H + 2] = G, z[H + 3] = xe, z[H + 4] = J, z[H + 5] = le, z[H + 6] = le, z[H + 7] = xe, p.faceidx += 6, p.lineidx += 8);
                  }
                }
              }
              A.drawSphere = w;
            })(E || (E = {}));
          }
        ),
        /***/
        "./src/GLModel.ts": (
          /*!************************!*\
            !*** ./src/GLModel.ts ***!
            \************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              GLModel: () => (
                /* binding */
                r
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), E = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), A = s(
              /*! ./colors */
              "./src/colors.ts"
            ), h = s(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), g = s(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), C = s(
              /*! ./utilities */
              "./src/utilities.ts"
            ), c = s(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), S = s(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), y = s(
              /*! netcdfjs */
              "./node_modules/netcdfjs/lib-esm/index.js"
            ), b = s(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            ), w = s(
              /*! ./parsers/utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function t(u) {
              let o;
              return typeof u == "string" ? o = new TextEncoder().encode(u) : o = new Uint8Array(u), (0, b.inflate)(o, {
                to: "string"
              });
            }
            class r {
              // class functions
              // return true if a and b represent the same style
              static sameObj(o, l) {
                return o && l ? JSON.stringify(o) == JSON.stringify(l) : o == l;
              }
              constructor(o, l) {
                this.atoms = [], this.frames = [], this.box = null, this.atomdfs = null, this.id = 0, this.hidden = !1, this.molObj = null, this.renderedMolObj = null, this.lastColors = null, this.modelData = {}, this.modelDatas = null, this.idMatrix = new E.Matrix4(), this.dontDuplicateAtoms = !0, this.defaultColor = A.elementColors.defaultColor, this.defaultStickRadius = 0.25, this.options = l || {}, this.ElementColors = this.options.defaultcolors ? this.options.defaultcolors : A.elementColors.defaultColors, this.defaultSphereRadius = this.options.defaultSphereRadius ? this.options.defaultSphereRadius : 1.5, this.defaultCartoonQuality = this.options.cartoonQuality ? this.options.cartoonQuality : 10, this.id = o;
              }
              // return proper radius for atom given style
              /**
               *
               * @param {AtomSpec} atom
               * @param {atomstyle} style
               * @return {number}
               *
               */
              getRadiusFromStyle(o, l) {
                var e = this.defaultSphereRadius;
                if (typeof l.radius < "u")
                  e = l.radius;
                else if (r.vdwRadii[o.elem])
                  e = r.vdwRadii[o.elem];
                else if (o.elem.length > 1) {
                  let n = o.elem;
                  n = n[0].toUpperCase() + n[1].toLowerCase(), r.vdwRadii[n] && (e = r.vdwRadii[n]);
                }
                return typeof l.scale < "u" && (e *= l.scale), e;
              }
              // cross drawing
              /**
               *
               * @param {AtomSpec} atom
               * @param {Record<number, Geometry>} geos
               */
              drawAtomCross(o, l) {
                if (o.style.cross) {
                  var e = o.style.cross;
                  if (!e.hidden) {
                    var n = e.linewidth || r.defaultlineWidth;
                    l[n] || (l[n] = new v.Geometry());
                    var a = l[n].updateGeoGroup(6), p = this.getRadiusFromStyle(o, e), x = [
                      [p, 0, 0],
                      [-p, 0, 0],
                      [0, p, 0],
                      [0, -p, 0],
                      [0, 0, p],
                      [0, 0, -p]
                    ], D = o.clickable || o.hoverable;
                    D && o.intersectionShape === void 0 && (o.intersectionShape = { sphere: [], cylinder: [], line: [] });
                    for (var O = (0, C.getColorFromStyle)(o, e), R = a.vertexArray, z = a.colorArray, T = 0; T < 6; T++) {
                      var B = a.vertices * 3;
                      if (a.vertices++, R[B] = o.x + x[T][0], R[B + 1] = o.y + x[T][1], R[B + 2] = o.z + x[T][2], z[B] = O.r, z[B + 1] = O.g, z[B + 2] = O.b, D) {
                        var W = new E.Vector3(x[T][0], x[T][1], x[T][2]);
                        W.multiplyScalar(0.1), W.set(W.x + o.x, W.y + o.y, W.z + o.z), o.intersectionShape.line.push(W);
                      }
                    }
                  }
                }
              }
              getGoodCross(o, l, e, n) {
                for (var a = null, p = -1, x = 0, D = o.bonds.length; x < D; x++)
                  if (o.bonds[x] != l.index) {
                    let R = o.bonds[x], z = this.atoms[R], B = new E.Vector3(z.x, z.y, z.z).clone();
                    B.sub(e);
                    let W = B.clone();
                    W.cross(n);
                    var O = W.lengthSq();
                    if (O > p && (p = O, a = W, p > 0.1))
                      return a;
                  }
                return a;
              }
              //from atom, return a normalized vector v that is orthogonal and along which
              //it is appropraite to draw multiple bonds
              getSideBondV(o, l, e) {
                var n, a, p, x, D, O = new E.Vector3(o.x, o.y, o.z), R = new E.Vector3(l.x, l.y, l.z), z = R.clone(), T = null;
                if (z.sub(O), o.bonds.length === 1)
                  l.bonds.length === 1 ? (T = z.clone(), Math.abs(T.x) > 1e-4 ? T.y += 1 : T.x += 1) : (n = (e + 1) % l.bonds.length, a = l.bonds[n], p = this.atoms[a], x = new E.Vector3(p.x, p.y, p.z), D = x.clone(), D.sub(O), T = D.clone(), T.cross(z));
                else if (T = this.getGoodCross(o, l, O, z), T.lengthSq() < 0.01) {
                  var B = this.getGoodCross(l, o, O, z);
                  B != null && (T = B);
                }
                return T.lengthSq() < 0.01 && (T = z.clone(), Math.abs(T.x) > 1e-4 ? T.y += 1 : T.x += 1), T.cross(z), T.normalize(), T;
              }
              addLine(o, l, e, n, a, p) {
                o[e] = n.x, o[e + 1] = n.y, o[e + 2] = n.z, l[e] = p.r, l[e + 1] = p.g, l[e + 2] = p.b, o[e + 3] = a.x, o[e + 4] = a.y, o[e + 5] = a.z, l[e + 3] = p.r, l[e + 4] = p.g, l[e + 5] = p.b;
              }
              // bonds - both atoms must match bond style
              // standardize on only drawing for lowest to highest
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSpec[]} atoms
               * @param {Record<number,Geometry>} geos
               */
              drawBondLines(o, l, e) {
                if (o.style.line) {
                  var n = o.style.line;
                  if (!n.hidden) {
                    var a, p, x, D, O = n.linewidth || r.defaultlineWidth;
                    e[O] || (e[O] = new v.Geometry());
                    for (var R = e[O].updateGeoGroup(6 * o.bonds.length), z = R.vertexArray, T = R.colorArray, B = 0; B < o.bonds.length; B++) {
                      var W = o.bonds[B], k = l[W];
                      if (k.style.line && !(o.index >= k.index)) {
                        var F = new E.Vector3(o.x, o.y, o.z), U = new E.Vector3(k.x, k.y, k.z), V = F.clone().add(U).multiplyScalar(0.5), H = !1, G = o.clickable || o.hoverable, Y = k.clickable || k.hoverable;
                        (G || Y) && (G && (o.intersectionShape === void 0 && (o.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), o.intersectionShape.line.push(F), o.intersectionShape.line.push(V)), Y && (k.intersectionShape === void 0 && (k.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), k.intersectionShape.line.push(V), k.intersectionShape.line.push(U)));
                        var J = (0, C.getColorFromStyle)(o, o.style.line), re = (0, C.getColorFromStyle)(k, k.style.line);
                        if (o.bondStyles && o.bondStyles[B]) {
                          var le = o.bondStyles[B];
                          if (!le.iswire)
                            continue;
                          le.singleBond && (H = !0), typeof le.color1 < "u" && (J = A.CC.color(le.color1)), typeof le.color2 < "u" && (re = A.CC.color(le.color2));
                        }
                        var ie = R.vertices * 3, xe, se;
                        if (o.bondOrder[B] > 1 && o.bondOrder[B] < 4 && !H) {
                          var ce = this.getSideBondV(o, k, B), Ee = U.clone();
                          Ee.sub(F), o.bondOrder[B] == 2 ? (ce.multiplyScalar(0.1), a = F.clone(), a.add(ce), p = F.clone(), p.sub(ce), x = a.clone(), x.add(Ee), D = p.clone(), D.add(Ee), J == re ? (R.vertices += 4, this.addLine(z, T, ie, a, x, J), this.addLine(z, T, ie + 6, p, D, J)) : (R.vertices += 8, Ee.multiplyScalar(0.5), xe = a.clone(), xe.add(Ee), se = p.clone(), se.add(Ee), this.addLine(z, T, ie, a, xe, J), this.addLine(z, T, ie + 6, xe, x, re), this.addLine(z, T, ie + 12, p, se, J), this.addLine(z, T, ie + 18, se, D, re))) : o.bondOrder[B] == 3 && (ce.multiplyScalar(0.1), a = F.clone(), a.add(ce), p = F.clone(), p.sub(ce), x = a.clone(), x.add(Ee), D = p.clone(), D.add(Ee), J == re ? (R.vertices += 6, this.addLine(z, T, ie, F, U, J), this.addLine(z, T, ie + 6, a, x, J), this.addLine(z, T, ie + 12, p, D, J)) : (R.vertices += 12, Ee.multiplyScalar(0.5), xe = a.clone(), xe.add(Ee), se = p.clone(), se.add(Ee), this.addLine(z, T, ie, F, V, J), this.addLine(z, T, ie + 6, V, U, re), this.addLine(z, T, ie + 12, a, xe, J), this.addLine(z, T, ie + 18, xe, x, re), this.addLine(z, T, ie + 24, p, se, J), this.addLine(z, T, ie + 30, se, D, re)));
                        } else
                          J == re ? (R.vertices += 2, this.addLine(z, T, ie, F, U, J)) : (R.vertices += 4, this.addLine(z, T, ie, F, V, J), this.addLine(z, T, ie + 6, V, U, re));
                      }
                    }
                  }
                }
              }
              //sphere drawing
              //See also: drawCylinder
              /**
               *
               * @param {AtomSpec} atom
               * @param {Geometry} geo
               */
              drawAtomSphere(o, l) {
                if (o.style.sphere) {
                  var e = o.style.sphere;
                  if (!e.hidden) {
                    var n = (0, C.getColorFromStyle)(o, e), a = this.getRadiusFromStyle(o, e);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var p = new E.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new M.Sphere(p, a));
                    }
                    h.GLDraw.drawSphere(l, o, a, n);
                  }
                }
              }
              /** Register atom shaped click handlers */
              drawAtomClickSphere(o) {
                if (o.style.clicksphere) {
                  var l = o.style.clicksphere;
                  if (!l.hidden) {
                    var e = this.getRadiusFromStyle(o, l);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var n = new E.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new M.Sphere(n, e));
                    }
                  }
                }
              }
              drawAtomInstanced(o, l) {
                if (o.style.sphere) {
                  var e = o.style.sphere;
                  if (!e.hidden) {
                    var n = this.getRadiusFromStyle(o, e), a = (0, C.getColorFromStyle)(o, e), p = l.updateGeoGroup(1), x = p.vertices, D = x * 3, O = p.vertexArray, R = p.colorArray, z = p.radiusArray;
                    if (O[D] = o.x, O[D + 1] = o.y, O[D + 2] = o.z, R[D] = a.r, R[D + 1] = a.g, R[D + 2] = a.b, z[x] = n, (o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var T = new E.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new M.Sphere(T, n));
                    }
                    p.vertices += 1;
                  }
                }
              }
              drawSphereImposter(o, l, e, n) {
                var a = o.updateGeoGroup(4), p, x = a.vertices, D = x * 3, O = a.vertexArray, R = a.colorArray;
                for (p = 0; p < 4; p++)
                  O[D + 3 * p] = l.x, O[D + 3 * p + 1] = l.y, O[D + 3 * p + 2] = l.z;
                var z = a.normalArray;
                for (p = 0; p < 4; p++)
                  R[D + 3 * p] = n.r, R[D + 3 * p + 1] = n.g, R[D + 3 * p + 2] = n.b;
                z[D + 0] = -e, z[D + 1] = e, z[D + 2] = 0, z[D + 3] = -e, z[D + 4] = -e, z[D + 5] = 0, z[D + 6] = e, z[D + 7] = -e, z[D + 8] = 0, z[D + 9] = e, z[D + 10] = e, z[D + 11] = 0, a.vertices += 4;
                var T = a.faceArray, B = a.faceidx;
                T[B + 0] = x, T[B + 1] = x + 1, T[B + 2] = x + 2, T[B + 3] = x + 2, T[B + 4] = x + 3, T[B + 5] = x, a.faceidx += 6;
              }
              //dkoes -  code for sphere imposters
              drawAtomImposter(o, l) {
                if (o.style.sphere) {
                  var e = o.style.sphere;
                  if (!e.hidden) {
                    var n = this.getRadiusFromStyle(o, e), a = (0, C.getColorFromStyle)(o, e);
                    if ((o.clickable === !0 || o.hoverable) && o.intersectionShape !== void 0) {
                      var p = new E.Vector3(o.x, o.y, o.z);
                      o.intersectionShape.sphere.push(new M.Sphere(p, n));
                    }
                    this.drawSphereImposter(l, o, n, a);
                  }
                }
              }
              static drawStickImposter(o, l, e, n, a) {
                for (var p = o.updateGeoGroup(4), x = p.vertices, D = x * 3, O = p.vertexArray, R = p.colorArray, z = p.radiusArray, T = p.normalArray, B = a.r, W = a.g, k = a.b, F = function(Y) {
                  var J = -Y;
                  return J == 0 && (J = -1e-4), J;
                }, U = D, V = 0; V < 4; V++)
                  O[U] = l.x, T[U] = e.x, R[U] = B, U++, O[U] = l.y, T[U] = e.y, R[U] = W, U++, O[U] = l.z, T[U] = e.z, V < 2 ? R[U] = k : R[U] = F(k), U++;
                p.vertices += 4, z[x] = -n, z[x + 1] = n, z[x + 2] = -n, z[x + 3] = n;
                var H = p.faceArray, G = p.faceidx;
                H[G + 0] = x, H[G + 1] = x + 1, H[G + 2] = x + 2, H[G + 3] = x + 2, H[G + 4] = x + 3, H[G + 5] = x, p.faceidx += 6;
              }
              // draws cylinders and small spheres (at bond radius)
              drawBondSticks(o, l, e) {
                if (o.style.stick) {
                  var n = o.style.stick;
                  if (!n.hidden) {
                    var a = n.radius || this.defaultStickRadius, p = n.doubleBondScaling || 0.4, x = n.tripleBondScaling || 0.25, D = a, O = n.singleBonds || !1, R = 0, z = 0, T, B, W, k, F, U, V, H, G, Y, J, re = (0, C.getColorFromStyle)(o, n), le, ie, xe;
                    !o.capDrawn && o.bonds.length < 4 && (R = 2);
                    var se = h.GLDraw.drawCylinder;
                    for (e.imposter && (se = r.drawStickImposter), W = 0; W < o.bonds.length; W++) {
                      var ce = o.bonds[W], Ee = l[ce];
                      if (le = ie = xe = null, o.index < Ee.index) {
                        var be = Ee.style;
                        if (!be.stick || be.stick.hidden)
                          continue;
                        var Le = (0, C.getColorFromStyle)(Ee, be.stick);
                        if (D = a, k = O, o.bondStyles && o.bondStyles[W]) {
                          if (F = o.bondStyles[W], F.iswire)
                            continue;
                          F.radius && (D = F.radius), F.singleBond && (k = !0), typeof F.color1 < "u" && (re = A.CC.color(F.color1)), typeof F.color2 < "u" && (Le = A.CC.color(F.color2));
                        }
                        var ae = new E.Vector3(o.x, o.y, o.z), pe = new E.Vector3(Ee.x, Ee.y, Ee.z);
                        if (o.bondOrder[W] <= 1 || k || o.bondOrder[W] > 3) {
                          if (o.bondOrder[W] < 1 && (D *= o.bondOrder[W]), !Ee.capDrawn && Ee.bonds.length < 4 && (z = 2), re != Le ? (le = new E.Vector3().addVectors(ae, pe).multiplyScalar(0.5), se(e, ae, le, D, re, R, 0), se(e, le, pe, D, Le, 0, z)) : se(e, ae, pe, D, re, R, z), T = o.clickable || o.hoverable, B = Ee.clickable || Ee.hoverable, T || B) {
                            if (le || (le = new E.Vector3().addVectors(ae, pe).multiplyScalar(0.5)), T) {
                              var we = new M.Cylinder(ae, le, D), Ge = new M.Sphere(ae, D);
                              o.intersectionShape.cylinder.push(we), o.intersectionShape.sphere.push(Ge);
                            }
                            if (B) {
                              var We = new M.Cylinder(pe, le, D), je = new M.Sphere(pe, D);
                              Ee.intersectionShape.cylinder.push(We), Ee.intersectionShape.sphere.push(je);
                            }
                          }
                        } else if (o.bondOrder[W] > 1) {
                          var Fe = 0, ze = 0;
                          D != a && (Fe = 2, ze = 2);
                          var Be = pe.clone(), Ie = null;
                          Be.sub(ae);
                          var Te, Re, ke, Ne, X;
                          Ie = this.getSideBondV(o, Ee, W), o.bondOrder[W] == 2 ? (Te = D * p, Ie.multiplyScalar(Te * 1.5), Re = ae.clone(), Re.add(Ie), ke = ae.clone(), ke.sub(Ie), Ne = Re.clone(), Ne.add(Be), X = ke.clone(), X.add(Be), re != Le ? (le = new E.Vector3().addVectors(Re, Ne).multiplyScalar(0.5), ie = new E.Vector3().addVectors(ke, X).multiplyScalar(0.5), se(e, Re, le, Te, re, Fe, 0), se(e, le, Ne, Te, Le, 0, ze), se(e, ke, ie, Te, re, Fe, 0), se(e, ie, X, Te, Le, 0, ze)) : (se(e, Re, Ne, Te, re, Fe, ze), se(e, ke, X, Te, re, Fe, ze)), T = o.clickable || o.hoverable, B = Ee.clickable || Ee.hoverable, (T || B) && (le || (le = new E.Vector3().addVectors(Re, Ne).multiplyScalar(0.5)), ie || (ie = new E.Vector3().addVectors(ke, X).multiplyScalar(0.5)), T && (U = new M.Cylinder(Re, le, Te), V = new M.Cylinder(ke, ie, Te), o.intersectionShape.cylinder.push(U), o.intersectionShape.cylinder.push(V)), B && (G = new M.Cylinder(Ne, le, Te), Y = new M.Cylinder(X, ie, Te), Ee.intersectionShape.cylinder.push(G), Ee.intersectionShape.cylinder.push(Y)))) : o.bondOrder[W] == 3 && (Te = D * x, Ie.cross(Be), Ie.normalize(), Ie.multiplyScalar(Te * 3), Re = ae.clone(), Re.add(Ie), ke = ae.clone(), ke.sub(Ie), Ne = Re.clone(), Ne.add(Be), X = ke.clone(), X.add(Be), re != Le ? (le = new E.Vector3().addVectors(Re, Ne).multiplyScalar(0.5), ie = new E.Vector3().addVectors(ke, X).multiplyScalar(0.5), xe = new E.Vector3().addVectors(ae, pe).multiplyScalar(0.5), se(e, Re, le, Te, re, Fe, 0), se(e, le, Ne, Te, Le, 0, ze), se(e, ae, xe, Te, re, R, 0), se(e, xe, pe, Te, Le, 0, z), se(e, ke, ie, Te, re, Fe, 0), se(e, ie, X, Te, Le, 0, ze)) : (se(e, Re, Ne, Te, re, Fe, ze), se(e, ae, pe, Te, re, R, z), se(e, ke, X, Te, re, Fe, ze)), T = o.clickable || o.hoverable, B = Ee.clickable || Ee.hoverable, (T || B) && (le || (le = new E.Vector3().addVectors(Re, Ne).multiplyScalar(0.5)), ie || (ie = new E.Vector3().addVectors(ke, X).multiplyScalar(0.5)), xe || (xe = new E.Vector3().addVectors(ae, pe).multiplyScalar(0.5)), T && (U = new M.Cylinder(Re.clone(), le.clone(), Te), V = new M.Cylinder(ke.clone(), ie.clone(), Te), H = new M.Cylinder(ae.clone(), xe.clone(), Te), o.intersectionShape.cylinder.push(U), o.intersectionShape.cylinder.push(V), o.intersectionShape.cylinder.push(H)), B && (G = new M.Cylinder(Ne.clone(), le.clone(), Te), Y = new M.Cylinder(X.clone(), ie.clone(), Te), J = new M.Cylinder(pe.clone(), xe.clone(), Te), Ee.intersectionShape.cylinder.push(G), Ee.intersectionShape.cylinder.push(Y), Ee.intersectionShape.cylinder.push(J))));
                        }
                      }
                    }
                    var K = !1, q = 0, fe = !1;
                    for (W = 0; W < o.bonds.length; W++)
                      k = O, o.bondStyles && o.bondStyles[W] && (F = o.bondStyles[W], F.singleBond && (k = !0), F.radius && F.radius != a && (fe = !0)), (k || o.bondOrder[W] == 1) && q++;
                    fe ? q > 0 && (K = !0) : q == 0 && (o.bonds.length > 0 || n.showNonBonded) && (K = !0), K && (D = a, e.imposter ? this.drawSphereImposter(e.sphereGeometry, o, D, re) : h.GLDraw.drawSphere(e, o, D, re));
                  }
                }
              }
              // go through all the atoms and regenerate their geometries
              // we try to have one geometry for each style since this is much much
              // faster
              // at some point we should optimize this to avoid unnecessary
              // recalculation
              /** param {AtomSpec[]} atoms */
              createMolObj(o, l) {
                l = l || {};
                var e = new v.Object3D(), n = [], a = {}, p = {}, x = this.drawAtomSphere, D = null, O = null;
                l.supportsImposters ? (x = this.drawAtomImposter, D = new v.Geometry(!0), D.imposter = !0, O = new v.Geometry(!0, !0), O.imposter = !0, O.sphereGeometry = new v.Geometry(!0), O.sphereGeometry.imposter = !0, O.drawnCaps = {}) : l.supportsAIA ? (x = this.drawAtomInstanced, D = new v.Geometry(!1, !0, !0), D.instanced = !0, O = new v.Geometry(!0)) : (D = new v.Geometry(!0), O = new v.Geometry(!0));
                var R, z, T, B, W = {}, k = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (R = 0, T = o.length; R < T; R++) {
                  var F = o[R];
                  if (F && F.style) {
                    (F.clickable || F.hoverable) && F.intersectionShape === void 0 && (F.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), B = { line: void 0, cross: void 0, stick: void 0, sphere: void 0 };
                    for (z in B)
                      F.style[z] ? F.style[z].opacity ? B[z] = parseFloat(F.style[z].opacity) : B[z] = 1 : B[z] = void 0, W[z] ? B[z] != null && W[z] != B[z] && (console.log("Warning: " + z + " opacity is ambiguous"), W[z] = 1) : W[z] = B[z];
                    x.call(this, F, D), this.drawAtomClickSphere(F), this.drawAtomCross(F, p), this.drawBondLines(F, o, a), this.drawBondSticks(F, o, O), typeof F.style.cartoon < "u" && !F.style.cartoon.hidden && (F.style.cartoon.color === "spectrum" && typeof F.resi == "number" && !F.hetflag && (F.resi < k[0] && (k[0] = F.resi), F.resi > k[1] && (k[1] = F.resi)), n.push(F));
                  }
                }
                if (n.length > 0 && (0, g.drawCartoon)(e, n, k, this.defaultCartoonQuality), D && D.vertices > 0) {
                  D.initTypedArrays();
                  var U = null, V = null;
                  D.imposter ? U = new v.SphereImposterMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }) : D.instanced ? (V = new v.Geometry(!0), h.GLDraw.drawSphere(V, { x: 0, y: 0, z: 0 }, 1, new A.Color(0.5, 0.5, 0.5)), V.initTypedArrays(), U = new v.InstancedMaterial({
                    sphereMaterial: new v.MeshLambertMaterial({
                      ambient: 0,
                      vertexColors: !0,
                      reflectivity: 0
                    }),
                    sphere: V
                  })) : U = new v.MeshLambertMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }), W.sphere < 1 && W.sphere >= 0 && (U.transparent = !0, U.opacity = W.sphere), V = new v.Mesh(D, U), e.add(V);
                }
                if (O.vertices > 0) {
                  var H = null, G = null, Y = O.sphereGeometry;
                  (!Y || typeof Y.vertices > "u" || Y.vertices == 0) && (Y = null), O.initTypedArrays(), Y && Y.initTypedArrays();
                  var J = { ambient: 0, vertexColors: !0, reflectivity: 0 };
                  O.imposter ? (H = new v.StickImposterMaterial(J), G = new v.SphereImposterMaterial(J)) : (H = new v.MeshLambertMaterial(J), G = new v.MeshLambertMaterial(J), H.wireframe && (O.setUpWireframe(), Y && Y.setUpWireframe())), W.stick < 1 && W.stick >= 0 && (H.transparent = !0, H.opacity = W.stick, G.transparent = !0, G.opacity = W.stick);
                  var re = new v.Mesh(O, H);
                  if (e.add(re), Y) {
                    var le = new v.Mesh(Y, G);
                    e.add(le);
                  }
                }
                var ie;
                for (R in a)
                  if (a.hasOwnProperty(R)) {
                    ie = R;
                    var xe = new v.LineBasicMaterial({
                      linewidth: ie,
                      vertexColors: !0
                    });
                    W.line < 1 && W.line >= 0 && (xe.transparent = !0, xe.opacity = W.line), a[R].initTypedArrays();
                    var se = new v.Line(a[R], xe, v.LineStyle.LinePieces);
                    e.add(se);
                  }
                for (R in p)
                  if (p.hasOwnProperty(R)) {
                    ie = R;
                    var ce = new v.LineBasicMaterial({
                      linewidth: ie,
                      vertexColors: !0
                    });
                    W.cross < 1 && W.cross >= 0 && (ce.transparent = !0, ce.opacity = W.cross), p[R].initTypedArrays();
                    var Ee = new v.Line(p[R], ce, v.LineStyle.LinePieces);
                    e.add(Ee);
                  }
                if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {
                  var be = new v.Object3D(), Le;
                  for (Le = 0; Le < this.modelData.symmetries.length; Le++) {
                    var ae = new v.Object3D();
                    ae = e.clone(), ae.matrix.copy(this.modelData.symmetries[Le]), ae.matrixAutoUpdate = !1, be.add(ae);
                  }
                  return be;
                }
                return e;
              }
              /**
               * Return object representing internal state of
               * the model appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                return {
                  atoms: this.atoms,
                  frames: this.frames
                };
              }
              /**
               * Overwrite the internal model state with the passed state.
               *
              */
              setInternalState(o) {
                this.atoms = o.atoms, this.frames = o.frames, this.molObj = null;
              }
              /**
               * Returns crystallographic information if present.
               *
               *
               */
              getCrystData() {
                if (this.modelData.cryst) {
                  if (!this.modelData.cryst.matrix) {
                    const o = this.modelData.cryst;
                    this.modelData.cryst.matrix = (0, E.conversionMatrix3)(o.a, o.b, o.c, o.alpha, o.beta, o.gamma);
                  }
                  return this.modelData.cryst;
                } else
                  return null;
              }
              /**
              	     * Set crystallographic information using three angles and three lengths
              	     *
              	     * @param {number} a - length of unit cell side
              	     * @param {number} b - length of unit cell side
              	     * @param {number} c - length of unit cell side
              	     * @param {number} alpha - unit cell angle in degrees (default 90)
              	     * @param {number} beta - unit cell angle in degrees (default 90)
              	     * @param {number} gamma - unit cell angle in degrees (default 90)
              
              	     */
              setCrystData(o, l, e, n, a, p) {
                o = o || 1, l = l || 1, e = e || 1, n = n || 90, a = a || 90, p = p || 90;
                const x = (0, E.conversionMatrix3)(o, l, e, n, a, p);
                this.modelData.cryst = {
                  a: o,
                  b: l,
                  c: e,
                  alpha: n,
                  beta: a,
                  gamma: p,
                  matrix: x
                };
              }
              /**
               * Set the crystallographic matrix to the given matrix.
               *
               * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from
               * the crystal data.
               *
               * @param {Matrix3} matrix - unit cell matrix
               */
              setCrystMatrix(o) {
                o = o || new E.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1), this.modelData.cryst = {
                  matrix: o
                };
              }
              /**
               * Returns list of rotational/translational matrices if there is BIOMT data
               * Otherwise returns a list of just the ID matrix
               *
               * @return {Array<Matrix4>}
               *
               */
              getSymmetries() {
                return typeof this.modelData.symmetries > "u" && (this.modelData.symmetries = [this.idMatrix]), this.modelData.symmetries;
              }
              /**
               * Sets symmetries based on specified matrices in list
               *
               * @param {Array<Matrix4>} list
               *
               */
              setSymmetries(o) {
                typeof o > "u" ? this.modelData.symmetries = [this.idMatrix] : this.modelData.symmetries = o;
              }
              /**
               * Returns model id number
               *
               * @return {number} Model ID
               */
              getID() {
                return this.id;
              }
              /**
               * Returns model's frames property, a list of atom lists
               *
               * @return {number}
               */
              getNumFrames() {
                return this.frames.numFrames != null ? this.frames.numFrames : this.frames.length;
              }
              adjustCoord(o, l, e, n) {
                var a = l - o;
                return a < -e ? l + n : a > e ? l - n : l;
              }
              //go over current atoms in depth first order and ensure that connected
              //attoms aren't split across the box
              adjustCoordinatesToBox() {
                if (this.box && this.atomdfs)
                  for (var o = this.box[0], l = this.box[1], e = this.box[2], n = o * 0.9, a = l * 0.9, p = e * 0.9, x = 0; x < this.atomdfs.length; x++)
                    for (var D = this.atomdfs[x], O = 1; O < D.length; O++) {
                      var R = this.atoms[D[O][0]], z = this.atoms[D[O][1]];
                      R.x = this.adjustCoord(z.x, R.x, n, o), R.y = this.adjustCoord(z.y, R.y, a, l), R.z = this.adjustCoord(z.z, R.z, p, e);
                    }
              }
              /**
               * Sets model's atomlist to specified frame
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - model's atoms are set to this index in frames list
               * @return {Promise}
               */
              setFrame(o, l) {
                var e = this.getNumFrames();
                let n = this;
                return new Promise(function(a, p) {
                  if (e == 0 && a(), (o < 0 || o >= e) && (o = e - 1), n.frames.url != null) {
                    var x = n.frames.url;
                    (0, C.getbin)(x + "/traj/frame/" + o + "/" + n.frames.path, void 0, "POST", void 0).then(function(D) {
                      for (var O = new Float32Array(D, 44), R = 0, z = 0; z < n.atoms.length; z++)
                        n.atoms[z].x = O[R++], n.atoms[z].y = O[R++], n.atoms[z].z = O[R++];
                      n.box && n.atomdfs && n.adjustCoordinatesToBox(), a();
                    }).catch(p);
                  } else
                    n.atoms = n.frames[o], a();
                  n.molObj = null, n.modelDatas && o < n.modelDatas.length && (n.modelData = n.modelDatas[o], n.unitCellObjects && l && (l.removeUnitCell(n), l.addUnitCell(n)));
                });
              }
              /**
               * Add atoms as frames of model
               *
               * @param {AtomSpec[]} atoms - atoms to be added
               */
              addFrame(o) {
                this.frames.push(o);
              }
              /**
              	     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.
              	     * Model can then be animated
              	     *
              	     * @param {number} numFrames - number of frames to be created, default to 10
              	     * @param {number} amplitude - amplitude of distortion, default to 1 (full)
              	     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
              	     * @param {GLViewer} viewer - required if arrowSpec is provided
              	     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
              	     *@example
              
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.vibrate(10, 1);
              	        viewer.animate({loop: "forward",reps: 1});
              
              	        viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              vibrate(o = 10, l = 1, e = !1, n, a) {
                var p = 0, x = o;
                e && (p = -o, x = o), this.frames !== void 0 && this.frames.origIndex !== void 0 ? this.setFrame(this.frames.origIndex) : this.setFrame(0), p < x && (this.frames = []), e && (this.frames.origIndex = o);
                for (var D = p; D < x; D++) {
                  var O = [], R = this.frames.length;
                  if (D == 0 && !a) {
                    this.frames.push(this.atoms);
                    continue;
                  }
                  for (var z = 0; z < this.atoms.length; z++) {
                    var T = (0, C.getAtomProperty)(this.atoms[z], "dx"), B = (0, C.getAtomProperty)(this.atoms[z], "dy"), W = (0, C.getAtomProperty)(this.atoms[z], "dz"), k = new E.Vector3(T, B, W), F = new E.Vector3(this.atoms[z].x, this.atoms[z].y, this.atoms[z].z), U = D * l / o;
                    k.multiplyScalar(U), F.add(k);
                    var V = {};
                    for (var H in this.atoms[z])
                      V[H] = this.atoms[z][H];
                    if (V.x = F.x, V.y = F.y, V.z = F.z, O.push(V), n && a) {
                      var G = (0, C.extend)({}, a), Y = new E.Vector3(T, B, W);
                      if (Y.multiplyScalar(l), Y.add(F), G.start = F, G.end = Y, G.frame = R, !G.color) {
                        var J = V.style.sphere;
                        J || (J = V.style.stick), J || (J = V.style.line), G.color = (0, C.getColorFromStyle)(V, J);
                      }
                      n.addArrow(G);
                    }
                  }
                  this.frames.push(O);
                }
              }
              // set default style and colors for atoms
              setAtomDefaults(o) {
                for (let l = 0; l < o.length; l++) {
                  let e = o[l];
                  e && (e.style = e.style || (0, C.deepCopy)(r.defaultAtomStyle), e.color = e.color || this.ElementColors[e.elem] || this.defaultColor, e.model = this.id, (e.clickable || e.hoverable) && (e.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }));
                }
              }
              /** add atoms to this model from molecular data string
               *
               * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer
               * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)
               * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format
               */
              addMolData(o, l, e = {}) {
                var n = r.parseMolData(o, l, e);
                this.dontDuplicateAtoms = !e.duplicateAssemblyAtoms;
                var a = n.modelData;
                if (a && (Array.isArray(a) ? (this.modelData = a[0], e.frames && (this.modelDatas = a)) : this.modelData = a), n.box ? this.box = n.box : this.box = null, this.frames.length == 0) {
                  for (let x = 0; x < n.length; x++)
                    n[x].length != 0 && this.frames.push(n[x]);
                  this.frames[0] && (this.atoms = this.frames[0]);
                } else if (e.frames)
                  for (let x = 0; x < n.length; x++)
                    this.frames.push(n[x]);
                else
                  for (var p = 0; p < n.length; p++)
                    this.addAtoms(n[p]);
                for (let x = 0; x < this.frames.length; x++)
                  this.setAtomDefaults(this.frames[x]);
                e.vibrate && e.vibrate.frames && e.vibrate.amplitude && this.vibrate(e.vibrate.frames, e.vibrate.amplitude), e.style && this.setStyle({}, e.style);
              }
              setDontDuplicateAtoms(o) {
                this.dontDuplicateAtoms = o;
              }
              setModelData(o) {
                this.modelData = o;
              }
              //return true if atom value matches property val
              propertyMatches(o, l) {
                if (o == l)
                  return !0;
                if (typeof l == "string" && typeof o == "number") {
                  var e = l.match(/(-?\d+)\s*-\s*(-?\d+)/);
                  if (e) {
                    var n = parseInt(e[1]), a = parseInt(e[2]);
                    if (e && o >= n && o <= a)
                      return !0;
                  }
                }
                return !1;
              }
              // make a deep copy of a selection object and create caches of expensive
              // selections.  We create a copy so caches are not attached to user
              // supplied objects where the user might change them invalidating the cache.
              // This does not support arbitrary
              // javascript objects, but support enough for eveything that is
              // used in selections: number, string, boolean, functions; as well
              // as arrays and nested objects with values of the aformentioned
              // types.
              static deepCopyAndCache(o, l) {
                if (typeof o != "object" || o == null || o.__cache_created)
                  return o;
                const e = {};
                for (const n in o) {
                  const a = o[n];
                  if (Array.isArray(a)) {
                    e[n] = [];
                    for (let p = 0; p < a.length; p++)
                      e[n].push(r.deepCopyAndCache(a[p], l));
                  } else
                    typeof a == "object" && n != "properties" && n != "model" ? e[n] = r.deepCopyAndCache(a, l) : e[n] = a;
                  if (n == "and" || n == "or") {
                    const p = [];
                    for (const x of e[n]) {
                      const D = /* @__PURE__ */ new Set();
                      for (const O of l.selectedAtoms(x))
                        D.add(O.index);
                      p.push(D);
                    }
                    if (n == "and") {
                      const x = function(O, R) {
                        const z = /* @__PURE__ */ new Set();
                        for (const T of R)
                          O.has(T) && z.add(T);
                        return z;
                      };
                      let D = new Set(p[0]);
                      for (const O of p.splice(1))
                        D = x(D, O);
                      e[n].__cached_results = D;
                    } else if (n == "or") {
                      const x = /* @__PURE__ */ new Set();
                      for (const D of p)
                        for (const O of D)
                          x.add(O);
                      e[n].__cached_results = x;
                    }
                  }
                }
                return e.__cache_created = !0, e;
              }
              /** given a selection specification, return true if atom is selected.
               * Does not support context-aware selectors like expand/within/byres.
               *
               * @param {AtomSpec} atom
               * @param {AtomSelectionSpec} sel
               * @return {boolean}
               */
              atomIsSelected(o, l) {
                if (typeof l > "u")
                  return !0;
                var e = !!l.invert, n = !0;
                for (var a in l)
                  if (a == "and" || a == "or" || a == "not") {
                    if (a == "not") {
                      if (this.atomIsSelected(o, l[a])) {
                        n = !1;
                        break;
                      }
                    } else if (l[a].__cached_results === void 0 && (l = r.deepCopyAndCache(l, this)), n = l[a].__cached_results.has(o.index), !n)
                      break;
                  } else if (a === "predicate") {
                    if (!l.predicate(o)) {
                      n = !1;
                      break;
                    }
                  } else if (a == "properties" && o[a]) {
                    for (var p in l.properties)
                      if (!p.startsWith("__cache")) {
                        if (typeof o.properties[p] > "u") {
                          n = !1;
                          break;
                        }
                        if (o.properties[p] != l.properties[p]) {
                          n = !1;
                          break;
                        }
                      }
                  } else if (l.hasOwnProperty(a) && !r.ignoredKeys.has(a) && !a.startsWith("__cache")) {
                    if (typeof o[a] > "u") {
                      n = !1;
                      break;
                    }
                    var x = !1;
                    if (a === "bonds") {
                      var D = l[a];
                      if (D != o.bonds.length) {
                        n = !1;
                        break;
                      }
                    } else if (Array.isArray(l[a])) {
                      var O = l[a], R = o[a];
                      for (let z = 0; z < O.length; z++)
                        if (this.propertyMatches(R, O[z])) {
                          x = !0;
                          break;
                        }
                      if (!x) {
                        n = !1;
                        break;
                      }
                    } else {
                      let z = l[a];
                      if (!this.propertyMatches(o[a], z)) {
                        n = !1;
                        break;
                      }
                    }
                  }
                return e ? !n : n;
              }
              static squaredDistance(o, l) {
                var e = l.x - o.x, n = l.y - o.y, a = l.z - o.z;
                return e * e + n * n + a * a;
              }
              /** returns a list of atoms in the expanded bounding box, but not in the current one
               *
               *  Bounding box:
               *
               *    [ [ xmin, ymin, zmin ],
               *      [ xmax, ymax, zmax ],
               *      [ xctr, yctr, zctr ] ]
               *
               **/
              expandAtomList(o, l) {
                if (l <= 0)
                  return o;
                for (var e = (0, C.getExtent)(o, void 0), n = [[], [], []], a = 0; a < 3; a++)
                  n[0][a] = e[0][a] - l, n[1][a] = e[1][a] + l, n[2][a] = e[2][a];
                var p = [];
                for (let R = 0; R < this.atoms.length; R++) {
                  var x = this.atoms[R].x, D = this.atoms[R].y, O = this.atoms[R].z;
                  x >= n[0][0] && x <= n[1][0] && D >= n[0][1] && D <= n[1][1] && O >= n[0][2] && O <= n[1][2] && (x >= e[0][0] && x <= e[1][0] && D >= e[0][1] && D <= e[1][1] && O >= e[0][2] && O <= e[1][2] || p.push(this.atoms[R]));
                }
                return p;
              }
              static getFloat(o) {
                return typeof o == "number" ? o : parseFloat(o);
              }
              /** return list of atoms selected by sel, this is specific to glmodel
               *
               * @param {AtomSelectionSpec} sel
               * @return {Object[]}
               * @example
               $3Dmol.download("pdb:4wwy",viewer,{},function(){
                        var atoms = viewer.selectedAtoms({chain:'A'});
                        for(var i = 0, n = atoms.length; i < n; i++) {
                           atoms[i].b = 0.0;
                        }
                        viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});
                        viewer.render();
                    });
               */
              selectedAtoms(o, l) {
                var e = [];
                o = r.deepCopyAndCache(o || {}, this), l || (l = this.atoms);
                for (var n = l.length, a = 0; a < n; a++) {
                  var p = l[a];
                  p && this.atomIsSelected(p, o) && e.push(p);
                }
                if (o.hasOwnProperty("expand")) {
                  const V = r.getFloat(o.expand);
                  let H = this.expandAtomList(e, V), G = e.length;
                  const Y = V * V;
                  for (let J = 0; J < H.length; J++)
                    for (let re = 0; re < G; re++) {
                      var x = r.squaredDistance(H[J], e[re]);
                      x < Y && x > 0 && e.push(H[J]);
                    }
                }
                if (o.hasOwnProperty("within") && o.within.hasOwnProperty("sel") && o.within.hasOwnProperty("distance")) {
                  var D = this.selectedAtoms(o.within.sel, this.atoms), O = {};
                  const V = r.getFloat(o.within.distance), H = V * V;
                  for (let G = 0; G < D.length; G++)
                    for (let Y = 0; Y < e.length; Y++) {
                      let J = r.squaredDistance(D[G], e[Y]);
                      J < H && J > 0 && (O[Y] = 1);
                    }
                  var R = [];
                  if (o.within.invert)
                    for (let G = 0; G < e.length; G++)
                      O[G] || R.push(e[G]);
                  else
                    for (let G in O)
                      R.push(e[G]);
                  e = R;
                }
                if (o.hasOwnProperty("byres")) {
                  var z = {}, T = [], B = [];
                  for (let V = 0; V < e.length; V++) {
                    let H = e[V];
                    var W = H.chain, k = H.resi;
                    if (z[W] === void 0 && (z[W] = {}), H.hasOwnProperty("resi") && z[W][k] === void 0) {
                      for (z[W][k] = !0, B.push(H); B.length > 0; )
                        if (H = B.pop(), W = H.chain, k = H.resi, T[H.index] === void 0) {
                          T[H.index] = !0;
                          for (var F = 0; F < H.bonds.length; F++) {
                            var U = this.atoms[H.bonds[F]];
                            T[U.index] === void 0 && U.hasOwnProperty("resi") && U.chain == W && U.resi == k && (B.push(U), e.push(U));
                          }
                        }
                    }
                  }
                }
                return e;
              }
              /** Add list of new atoms to model.  Adjusts bonds appropriately.
              	     *
              	     * @param {AtomSpec[]} newatoms
              	     * @example
              	     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];
              
              	        viewer.setBackgroundColor(0xffffffff);
              	        var m = viewer.addModel();
              	        m.addAtoms(atoms);
              	        m.setStyle({},{stick:{}});
              	        viewer.zoomTo();
              	        viewer.render();
              	     */
              addAtoms(o) {
                this.molObj = null;
                var l = this.atoms.length, e = [], n;
                for (n = 0; n < o.length; n++)
                  typeof o[n].index > "u" && (o[n].index = n), typeof o[n].serial > "u" && (o[n].serial = n), e[o[n].index] = l + n;
                for (n = 0; n < o.length; n++) {
                  var a = o[n], p = e[a.index], x = (0, C.extend)({}, a);
                  x.index = p, x.bonds = [], x.bondOrder = [], x.model = this.id, x.style = x.style || (0, C.deepCopy)(r.defaultAtomStyle), typeof x.color > "u" && (x.color = this.ElementColors[x.elem] || this.defaultColor);
                  for (var D = a.bonds ? a.bonds.length : 0, O = 0; O < D; O++) {
                    var R = e[a.bonds[O]];
                    typeof R < "u" && (x.bonds.push(R), x.bondOrder.push(a.bondOrder ? a.bondOrder[O] : 1));
                  }
                  this.atoms.push(x);
                }
              }
              /** Assign bonds based on atomic coordinates.
               *  This currently uses a primitive distance-based algorithm that does not
               * consider valence constraints and will only create single bonds.
               */
              assignBonds() {
                (0, w.assignBonds)(this.atoms);
              }
              /** Remove specified atoms from model
               *
               * @param {AtomSpec[]} badatoms - list of atoms
               */
              removeAtoms(o) {
                this.molObj = null;
                var l = [], e;
                for (e = 0; e < o.length; e++)
                  l[o[e].index] = !0;
                var n = [];
                for (e = 0; e < this.atoms.length; e++) {
                  var a = this.atoms[e];
                  l[a.index] || n.push(a);
                }
                this.atoms = [], this.addAtoms(n);
              }
              /** Set atom style of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel
              	     * @param {AtomStyleSpec} style
              	     * @param {boolean} add - if true, add to current style, don't replace
              	     @example
              	    $3Dmol.download("pdb:4UB9",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              
              	              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.render();
              	          });
              	     */
              setStyle(o, l, e) {
                typeof l > "u" && typeof e > "u" && (l = o, o = {}), o = o, typeof l == "string" && (l = (0, C.specStringToObject)(l));
                var n = !1, a = this, p = function(D) {
                  var O = a.selectedAtoms(o, D);
                  for (let R = 0; R < D.length; R++)
                    D[R] && (D[R].capDrawn = !1);
                  for (let R = 0; R < O.length; R++) {
                    n = !0, (O[R].clickable || O[R].hoverable) && (O[R].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), e || (O[R].style = {});
                    for (let z in l)
                      l.hasOwnProperty(z) && (O[R].style[z] = O[R].style[z] || {}, Object.assign(O[R].style[z], l[z]));
                  }
                };
                if (o.frame !== void 0 && o.frame < this.frames.length) {
                  let D = o.frame;
                  D < 0 && (D = this.frames.length + D), p(this.frames[D]);
                } else {
                  p(this.atoms);
                  for (var x = 0; x < this.frames.length; x++)
                    this.frames[x] !== this.atoms && p(this.frames[x]);
                }
                n && (this.molObj = null);
              }
              /** Set clickable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked
              
              	     */
              setClickable(o, l, e) {
                if (l = !!l, e = (0, C.makeFunction)(e), e === null) {
                  console.log("Callback is not a function");
                  return;
                }
                var n = this.selectedAtoms(o, this.atoms), a = n.length;
                for (let p = 0; p < a; p++)
                  n[p].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, n[p].clickable = l, e && (n[p].callback = e);
                a > 0 && (this.molObj = null);
              }
              /** Set hoverable and callback of selected atoms
              *
              * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              * @param {function} hover_callback - function called when an atom in the selection is hovered over
              * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              */
              setHoverable(o, l, e, n) {
                if (l = !!l, e = (0, C.makeFunction)(e), n = (0, C.makeFunction)(n), e === null) {
                  console.log("Hover_callback is not a function");
                  return;
                }
                if (n === null) {
                  console.log("Unhover_callback is not a function");
                  return;
                }
                var a = this.selectedAtoms(o, this.atoms), p = a.length;
                for (let x = 0; x < p; x++)
                  a[x].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, a[x].hoverable = l, e && (a[x].hover_callback = e), n && (a[x].unhover_callback = n);
                p > 0 && (this.molObj = null);
              }
              /** enable context menu of selected atoms
               *
               * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
               * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
               */
              enableContextMenu(o, l) {
                l = !!l;
                var e, n = this.selectedAtoms(o, this.atoms), a = n.length;
                for (e = 0; e < a; e++)
                  n[e].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, n[e].contextMenuEnabled = l;
                a > 0 && (this.molObj = null);
              }
              /** given a mapping from element to color, set atom colors
               *
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(o, l) {
                if (!(this.molObj !== null && r.sameObj(l, this.lastColors))) {
                  this.lastColors = l;
                  var e = this.selectedAtoms(o, e);
                  e.length > 0 && (this.molObj = null);
                  for (var n = 0; n < e.length; n++) {
                    var a = e[n];
                    typeof l[a.elem] < "u" && (a.color = l[a.elem]);
                  }
                }
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               */
              setColorByProperty(o, l, e, n) {
                var a, p, x = this.selectedAtoms(o, x);
                for (this.lastColors = null, x.length > 0 && (this.molObj = null), typeof e == "string" && typeof c.Gradient.builtinGradients[e] < "u" && (e = new c.Gradient.builtinGradients[e]()), e = e, n || (n = e.range()), n || (n = (0, C.getPropertyRange)(x, l)), a = 0; a < x.length; a++) {
                  p = x[a];
                  var D = (0, C.getAtomProperty)(p, l);
                  D != null && (p.color = e.valueToHex(parseFloat(p.properties[l]), n));
                }
              }
              /**
              	     * @deprecated use setStyle and colorfunc attribute
              	     * @param {AtomSelectionSpec} sel - selection object
              	     * @param {function} func - function to be used to set the color
              	     @example
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              	              var colorAsSnake = function(atom) {
              	                return atom.resi % 2 ? 'white': 'green'
              	              };
              
              	              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});
              
              	              viewer.render();
              	          });
              
              	     */
              setColorByFunction(o, l) {
                var e = this.selectedAtoms(o, e);
                if (typeof l == "function") {
                  this.lastColors = null, e.length > 0 && (this.molObj = null);
                  for (let n = 0; n < e.length; n++) {
                    let a = e[n];
                    a.color = l(a);
                  }
                }
              }
              /** Convert the model into an object in the format of a ChemDoodle JSON model.
               *
               * @param {boolean} whether or not to include style information. Defaults to false.
               * @return {Object}
               */
              toCDObject(o = !1) {
                var l = { a: [], b: [] };
                o && (l.s = []);
                for (let n = 0; n < this.atoms.length; n++) {
                  let a = {}, p = this.atoms[n];
                  if (a.x = p.x, a.y = p.y, a.z = p.z, p.elem != "C" && (a.l = p.elem), o) {
                    for (var e = 0; e < l.s.length && JSON.stringify(p.style) !== JSON.stringify(l.s[e]); )
                      e++;
                    e === l.s.length && l.s.push(p.style), e !== 0 && (a.s = e);
                  }
                  l.a.push(a);
                  for (let x = 0; x < p.bonds.length; x++) {
                    let D = n, O = p.bonds[x];
                    if (D >= O)
                      continue;
                    let R = {
                      b: D,
                      e: O
                    }, z = p.bondOrder[x];
                    z != 1 && (R.o = z), l.b.push(R);
                  }
                }
                return l;
              }
              /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add
               *
               * @param {Object3D} group
               * @param Object options
               */
              globj(o, l) {
                (this.molObj === null || l.regen) && (this.molObj = this.createMolObj(this.atoms, l), this.renderedMolObj && (o.remove(this.renderedMolObj), this.renderedMolObj = null), this.renderedMolObj = this.molObj.clone(), this.hidden && (this.renderedMolObj.setVisible(!1), this.molObj.setVisible(!1)), o.add(this.renderedMolObj));
              }
              /** return a VRML string representation of the model.  Does not include VRML header information
               * @return VRML
               */
              exportVRML() {
                var o = this.createMolObj(this.atoms, { supportsImposters: !1, supportsAIA: !1 });
                return o.vrml();
              }
              /** Remove any renderable mol object from scene
               *
               * @param {Object3D} group
               */
              removegl(o) {
                this.renderedMolObj && (this.renderedMolObj.geometry !== void 0 && this.renderedMolObj.geometry.dispose(), this.renderedMolObj.material !== void 0 && this.renderedMolObj.material.dispose(), o.remove(this.renderedMolObj), this.renderedMolObj = null), this.molObj = null;
              }
              /**
              	     * Don't show this model in future renderings. Keep all styles and state
              	     * so it can be efficiencly shown again.
              	     *
              	     * * @see GLModel#show
              
              	     * @example
              	        $3Dmol.download("pdb:3ucr",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.getModel().hide();
              	        viewer.render();
              	        });
              	     */
              hide() {
                this.hidden = !0, this.renderedMolObj && this.renderedMolObj.setVisible(!1), this.molObj && this.molObj.setVisible(!1);
              }
              /**
               * Unhide a hidden model
               * @see GLModel#hide
               * @example
                  $3Dmol.download("pdb:3ucr",viewer,{},function(){
                  viewer.setStyle({},{stick:{}});
                  viewer.getModel().hide();
                  viewer.render(  )
                  viewer.getModel().show()
                  viewer.render();
                  });
               */
              show() {
                this.hidden = !1, this.renderedMolObj && this.renderedMolObj.setVisible(!0), this.molObj && this.molObj.setVisible(!0);
              }
              /** Create labels for atoms that show the value of the passed property.
               *
               * @param {String} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               */
              addPropertyLabels(o, l, e, n) {
                for (var a = this.selectedAtoms(l, a), p = (0, C.deepCopy)(n), x = 0; x < a.length; x++) {
                  var D = a[x], O = null;
                  typeof D[o] < "u" ? O = String(D[o]) : typeof D.properties[o] < "u" && (O = String(D.properties[o])), O != null && (p.position = D, e.addLabel(O, p));
                }
              }
              /** Create labels for residues of selected atoms.
               * Will create a single label at the center of mass of all atoms
               * with the same chain,resn, and resi.
               *
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already
               */
              addResLabels(o, l, e, n = !1) {
                var a = [], p = function(D, O) {
                  for (var R = D.selectedAtoms(o, R), z = {}, T = 0; T < R.length; T++) {
                    var B = R[T], W = B.chain, k = B.resn, F = B.resi, U = k + "" + F;
                    z[W] || (z[W] = {}), z[W][U] || (z[W][U] = []), z[W][U].push(B);
                  }
                  var V = (0, C.deepCopy)(e);
                  for (let G in z)
                    if (z.hasOwnProperty(G)) {
                      var H = z[G];
                      for (let Y in H)
                        if (H.hasOwnProperty(Y)) {
                          let J = H[Y], re = new E.Vector3(0, 0, 0);
                          for (let ie = 0; ie < J.length; ie++) {
                            let xe = J[ie];
                            re.x += xe.x, re.y += xe.y, re.z += xe.z;
                          }
                          re.divideScalar(J.length), V.position = re, V.frame = O;
                          let le = l.addLabel(Y, V, void 0, !0);
                          a.push(le);
                        }
                    }
                };
                if (n) {
                  var x = this.getNumFrames();
                  let D = this.atoms;
                  for (let O = 0; O < x; O++)
                    this.frames[O] && (this.atoms = this.frames[O], p(this, O));
                  this.atoms = D;
                } else
                  p(this);
                return a;
              }
              //recurse over the current atoms to establish a depth first order
              setupDFS() {
                this.atomdfs = [];
                var o = this, l = new Int8Array(this.atoms.length);
                l.fill(0);
                for (var e = function(x, D, O) {
                  O.push([x, D]);
                  var R = o.atoms[x];
                  l[x] = 1;
                  for (var z = 0; z < R.bonds.length; z++) {
                    var T = R.bonds[z];
                    o.atoms[T] && !l[T] && e(T, x, O);
                  }
                }, n = 0; n < this.atoms.length; n++) {
                  var a = this.atoms[n];
                  if (a && !l[n]) {
                    var p = [];
                    e(n, -1, p), this.atomdfs.push(p);
                  }
                }
              }
              /**
              * Set coordinates from remote trajectory file.
              * @param {string} url - contains the url where mdsrv has been hosted
              * @param {string} path - contains the path of the file (<root>/filename)
              * @return {Promise}
              */
              setCoordinatesFromURL(o, l) {
                this.frames = [];
                var e = this;
                return this.box && this.setupDFS(), o.startsWith("http") || (o = "http://" + o), (0, C.get)(o + "/traj/numframes/" + l, function(n) {
                  if (!isNaN(parseInt(n)))
                    return e.frames.push(e.atoms), e.frames.numFrames = n, e.frames.url = o, e.frames.path = l, e.setFrame(0);
                });
              }
              /**
              * Set coordinates for the atoms from provided trajectory file.
              * @param {string|ArrayBuffer} str - contains the data of the file
              * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.
                @example
                   let m = viewer.addModel()  //create an empty model
                   m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms
                   viewer.setStyle({'sphere':{}})
                   m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');
                   viewer.animate({loop: "forward",reps: 1});
                   viewer.zoomTo();
                   viewer.zoom(0.5);
                   viewer.render();
              */
              setCoordinates(o, l) {
                if (l = l || "", !o)
                  return [];
                if (/\.gz$/.test(l)) {
                  l = l.replace(/\.gz$/, "");
                  try {
                    o = t(o);
                  } catch (z) {
                    console.log(z);
                  }
                }
                var e = { mdcrd: "", inpcrd: "", pdb: "", netcdf: "", array: "" };
                if (e.hasOwnProperty(l)) {
                  this.frames = [];
                  for (var n = this.atoms.length, a = r.parseCrd(o, l), p = 0; p < a.length; ) {
                    for (var x = [], D = 0; D < n; D++) {
                      var O = {};
                      for (var R in this.atoms[D])
                        O[R] = this.atoms[D][R];
                      x[D] = O, x[D].x = a[p++], x[D].y = a[p++], x[D].z = a[p++];
                    }
                    this.frames.push(x);
                  }
                  return this.atoms = this.frames[0], this.frames;
                }
                return [];
              }
              /**
               * add atomSpecs to validAtomSelectionSpecs
               * @deprecated
               * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs
               * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.
               * These messages are no longer generated as, in theory, typescript will catch problems at compile time.
               * In practice, there may still be issues at run-time but we don't check for them...
               *
               * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime
               * type checking, but it currently doesn't work with our types...
               */
              addAtomSpecs(o) {
              }
              static parseCrd(o, l) {
                var e = [], n = 0;
                if (l == "pdb")
                  for (var a = o.indexOf(`
ATOM`); a != -1; ) {
                    for (; o.slice(a, a + 5) == `
ATOM` || o.slice(a, a + 7) == `
HETATM`; )
                      e[n++] = parseFloat(o.slice(a + 31, a + 39)), e[n++] = parseFloat(o.slice(a + 39, a + 47)), e[n++] = parseFloat(o.slice(a + 47, a + 55)), a = o.indexOf(`
`, a + 54), o.slice(a, a + 4) == `
TER` && (a = o.indexOf(`
`, a + 5));
                    a = o.indexOf(`
ATOM`, a);
                  }
                else if (l == "netcdf") {
                  var p = new y.NetCDFReader(o);
                  e = [].concat.apply([], p.getDataVariable("coordinates"));
                } else {
                  if (l == "array" || Array.isArray(o))
                    return o.flat(2);
                  {
                    let x = o.indexOf(`
`);
                    l == "inpcrd" && (x = o.indexOf(`
`, x + 1)), o = o.slice(x + 1), e = o.match(/\S+/g).map(parseFloat);
                  }
                }
                return e;
              }
              static parseMolData(o, l = "", e) {
                if (!o)
                  return [];
                if (/\.gz$/.test(l)) {
                  l = l.replace(/\.gz$/, "");
                  try {
                    o = t(o);
                  } catch (p) {
                    console.log(p);
                  }
                }
                typeof S.Parsers[l] > "u" && (l = l.split(".").pop(), typeof S.Parsers[l] > "u" && (console.log("Unknown format: " + l), o instanceof Uint8Array ? l = "mmtf" : o.match(/^@<TRIPOS>MOLECULE/gm) ? l = "mol2" : o.match(/^data_/gm) && o.match(/^loop_/gm) ? l = "cif" : o.match(/^HETATM/gm) || o.match(/^ATOM/gm) ? l = "pdb" : o.match(/ITEM: TIMESTEP/gm) ? l = "lammpstrj" : o.match(/^.*\n.*\n.\s*(\d+)\s+(\d+)/gm) ? l = "sdf" : o.match(/^%VERSION\s+VERSION_STAMP/gm) ? l = "prmtop" : l = "xyz", console.log("Best guess: " + l)));
                var n = S.Parsers[l], a = n(o, e);
                return a;
              }
            }
            r.defaultAtomStyle = {
              line: {}
            }, r.defaultlineWidth = 1, r.vdwRadii = {
              H: 1.2,
              He: 1.4,
              Li: 1.82,
              Be: 1.53,
              B: 1.92,
              C: 1.7,
              N: 1.55,
              O: 1.52,
              F: 1.47,
              Ne: 1.54,
              Na: 2.27,
              Mg: 1.73,
              Al: 1.84,
              Si: 2.1,
              P: 1.8,
              S: 1.8,
              Cl: 1.75,
              Ar: 1.88,
              K: 2.75,
              Ca: 2.31,
              Ni: 1.63,
              Cu: 1.4,
              Zn: 1.39,
              Ga: 1.87,
              Ge: 2.11,
              As: 1.85,
              Se: 1.9,
              Br: 1.85,
              Kr: 2.02,
              Rb: 3.03,
              Sr: 2.49,
              Pd: 1.63,
              Ag: 1.72,
              Cd: 1.58,
              In: 1.93,
              Sn: 2.17,
              Sb: 2.06,
              Te: 2.06,
              I: 1.98,
              Xe: 2.16,
              Cs: 3.43,
              Ba: 2.68,
              Pt: 1.75,
              Au: 1.66,
              Hg: 1.55,
              Tl: 1.96,
              Pb: 2.02,
              Bi: 2.07,
              Po: 1.97,
              At: 2.02,
              Rn: 2.2,
              Fr: 3.48,
              Ra: 2.83,
              U: 1.86
            }, r.ignoredKeys = /* @__PURE__ */ new Set(["props", "invert", "model", "frame", "byres", "expand", "within", "and", "or", "not"]);
          }
        ),
        /***/
        "./src/GLShape.ts": (
          /*!************************!*\
            !*** ./src/GLShape.ts ***!
            \************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              GLShape: () => (
                /* binding */
                y
              ),
              /* harmony export */
              splitMesh: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), E = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), A = s(
              /*! ./colors */
              "./src/colors.ts"
            ), h = s(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), g = s(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), C = s(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), c = s(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), S = s(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            class y {
              static finalizeGeo(t) {
                var r = t.updateGeoGroup(0);
                r.vertices > 0 && r.truncateArrayBuffers(!0, !0);
              }
              /*
               *
               * @param {Geometry}
               *            geo
               * @param {Color | colorlike} color
               */
              static updateColor(t, r) {
                r = r || A.CC.color(r), t.colorsNeedUpdate = !0;
                var u, o, l;
                r.constructor !== Array && (u = r.r, o = r.g, l = r.b);
                for (let e in t.geometryGroups) {
                  let n = t.geometryGroups[e], a = n.colorArray;
                  for (let p = 0, x = n.vertices; p < x; ++p) {
                    if (r.constructor === Array) {
                      let D = r[p];
                      u = D.r, o = D.g, l = D.b;
                    }
                    a[p * 3] = u, a[p * 3 + 1] = o, a[p * 3 + 2] = l;
                  }
                }
              }
              /*
               * @param {GLShape}
               *            shape
               * @param {geometryGroup}
               *            geoGroup
               * @param {ArrowSpec}
               *            spec
               */
              static drawArrow(t, r, u) {
                var o = u.start, l = u.end, e = u.radius, n = u.radiusRatio, a = u.mid, p = u.midpos;
                if (!(o && l))
                  return;
                var x = r.updateGeoGroup(51), D = new E.Vector3(l.x, l.y, l.z).sub(o);
                if (p) {
                  let oe = D.length();
                  p > 0 ? a = p / oe : a = (oe + p) / oe;
                }
                D.multiplyScalar(a);
                var O = new E.Vector3(o.x, o.y, o.z).add(D), R = D.clone().negate();
                let z = new E.Vector3(o.x, o.y, o.z);
                t.intersectionShape.cylinder.push(new M.Cylinder(z, O.clone(), e)), t.intersectionShape.sphere.push(new M.Sphere(z, e));
                var T = [];
                T[0] = D.clone(), Math.abs(T[0].x) > 1e-4 ? T[0].y += 1 : T[0].x += 1, T[0].cross(D), T[0].normalize(), T[4] = T[0].clone(), T[4].crossVectors(T[0], D), T[4].normalize(), T[8] = T[0].clone().negate(), T[12] = T[4].clone().negate(), T[2] = T[0].clone().add(T[4]).normalize(), T[6] = T[4].clone().add(T[8]).normalize(), T[10] = T[8].clone().add(T[12]).normalize(), T[14] = T[12].clone().add(T[0]).normalize(), T[1] = T[0].clone().add(T[2]).normalize(), T[3] = T[2].clone().add(T[4]).normalize(), T[5] = T[4].clone().add(T[6]).normalize(), T[7] = T[6].clone().add(T[8]).normalize(), T[9] = T[8].clone().add(T[10]).normalize(), T[11] = T[10].clone().add(T[12]).normalize(), T[13] = T[12].clone().add(T[14]).normalize(), T[15] = T[14].clone().add(T[0]).normalize();
                var B = x.vertices, W = x.vertexArray, k = x.faceArray, F = x.normalArray, U = x.lineArray, V, H, G;
                for (H = 0, G = T.length; H < G; ++H) {
                  V = 3 * (B + 3 * H);
                  var Y = T[H].clone().multiplyScalar(e).add(o), J = T[H].clone().multiplyScalar(e).add(O), re = T[H].clone().multiplyScalar(e * n).add(O);
                  if (W[V] = Y.x, W[V + 1] = Y.y, W[V + 2] = Y.z, W[V + 3] = J.x, W[V + 4] = J.y, W[V + 5] = J.z, W[V + 6] = re.x, W[V + 7] = re.y, W[V + 8] = re.z, H > 0) {
                    var le = W[V - 3], ie = W[V - 2], xe = W[V - 1], se = new E.Vector3(le, ie, xe), ce = new E.Vector3(l.x, l.y, l.z), Ee = O.clone(), be = new E.Vector3(re.x, re.y, re.z);
                    t.intersectionShape.triangle.push(new M.Triangle(be, ce, se)), t.intersectionShape.triangle.push(new M.Triangle(se.clone(), Ee, be.clone()));
                  }
                }
                x.vertices += 48, V = x.vertices * 3, W[V] = o.x, W[V + 1] = o.y, W[V + 2] = o.z, W[V + 3] = O.x, W[V + 4] = O.y, W[V + 5] = O.z, W[V + 6] = l.x, W[V + 7] = l.y, W[V + 8] = l.z, x.vertices += 3;
                var Le, ae, pe, we, Ge, We, je, Fe, ze, Be, Ie, Te, Re, ke, Ne, X, K, q, fe, ue = x.vertices - 3, De = x.vertices - 2, Se = x.vertices - 1, Z = ue * 3, de = De * 3, me = Se * 3;
                for (H = 0, G = T.length - 1; H < G; ++H) {
                  var Pe = B + 3 * H;
                  V = Pe * 3, ae = x.faceidx, pe = x.lineidx, we = Pe, Be = we * 3, Ge = Pe + 1, Ie = Ge * 3, We = Pe + 2, Te = We * 3, je = Pe + 4, Re = je * 3, Fe = Pe + 5, ke = Fe * 3, ze = Pe + 3, Ne = ze * 3, X = K = T[H], q = fe = T[H + 1], F[Be] = X.x, F[Ie] = K.x, F[Ne] = fe.x, F[Be + 1] = X.y, F[Ie + 1] = K.y, F[Ne + 1] = fe.y, F[Be + 2] = X.z, F[Ie + 2] = K.z, F[Ne + 2] = fe.z, F[Ie] = K.x, F[Re] = q.x, F[Ne] = fe.x, F[Ie + 1] = K.y, F[Re + 1] = q.y, F[Ne + 1] = fe.y, F[Ie + 2] = K.z, F[Re + 2] = q.z, F[Ne + 2] = fe.z, F[Te] = K.x, F[ke] = q.x, F[Te + 1] = K.y, F[ke + 1] = q.y, F[Te + 2] = K.z, F[ke + 2] = q.z, k[ae] = we, k[ae + 1] = Ge, k[ae + 2] = ze, k[ae + 3] = Ge, k[ae + 4] = je, k[ae + 5] = ze, k[ae + 6] = we, k[ae + 7] = ze, k[ae + 8] = ue, k[ae + 9] = We, k[ae + 10] = De, k[ae + 11] = Fe, k[ae + 12] = We, k[ae + 13] = Se, k[ae + 14] = Fe, U[pe] = we, U[pe + 1] = Ge, U[pe + 2] = we, U[pe + 3] = ze, U[pe + 4] = je, U[pe + 5] = ze, U[pe + 6] = we, U[pe + 7] = ze, U[pe + 8] = We, U[pe + 9] = Ge, U[pe + 10] = We, U[pe + 11] = Fe, U[pe + 12] = je, U[pe + 13] = Fe, U[pe + 14] = We, U[pe + 15] = Se, U[pe + 16] = We, U[pe + 17] = Fe, U[pe + 18] = Se, U[pe + 19] = Fe, x.faceidx += 15, x.lineidx += 20;
                }
                Le = [
                  B + 45,
                  B + 46,
                  B + 1,
                  B,
                  B + 47,
                  B + 2
                ], ae = x.faceidx, pe = x.lineidx, we = Le[0], Be = we * 3, Ge = Le[1], Ie = Ge * 3, We = Le[4], Te = We * 3, je = Le[2], Re = je * 3, Fe = Le[5], ke = Fe * 3, ze = Le[3], Ne = ze * 3, X = K = T[15], q = fe = T[0], F[Be] = X.x, F[Ie] = K.x, F[Ne] = fe.x, F[Be + 1] = X.y, F[Ie + 1] = K.y, F[Ne + 1] = fe.y, F[Be + 2] = X.z, F[Ie + 2] = K.z, F[Ne + 2] = fe.z, F[Ie] = K.x, F[Re] = q.x, F[Ne] = fe.x, F[Ie + 1] = K.y, F[Re + 1] = q.y, F[Ne + 1] = fe.y, F[Ie + 2] = K.z, F[Re + 2] = q.z, F[Ne + 2] = fe.z, F[Te] = K.x, F[ke] = q.x, F[Te + 1] = K.y, F[ke + 1] = q.y, F[Te + 2] = K.z, F[ke + 2] = q.z, D.normalize(), R.normalize(), F[Z] = R.x, F[de] = F[me] = D.x, F[Z + 1] = R.y, F[de + 1] = F[me + 1] = D.y, F[Z + 2] = R.z, F[de + 2] = F[me + 2] = D.z, k[ae] = we, k[ae + 1] = Ge, k[ae + 2] = ze, k[ae + 3] = Ge, k[ae + 4] = je, k[ae + 5] = ze, k[ae + 6] = we, k[ae + 7] = ze, k[ae + 8] = ue, k[ae + 9] = We, k[ae + 10] = De, k[ae + 11] = Fe, k[ae + 12] = We, k[ae + 13] = Se, k[ae + 14] = Fe, U[pe] = we, U[pe + 1] = Ge, U[pe + 2] = we, U[pe + 3] = ze, U[pe + 4] = je, U[pe + 5] = ze, U[pe + 6] = we, U[pe + 7] = ze, U[pe + 8] = We, U[pe + 9] = Ge, U[pe + 10] = We, U[pe + 11] = Fe, U[pe + 12] = je, U[pe + 13] = Fe, U[pe + 14] = We, U[pe + 15] = Se, U[pe + 16] = We, U[pe + 17] = Fe, U[pe + 18] = Se, U[pe + 19] = Fe, x.faceidx += 15, x.lineidx += 20;
              }
              // Update a bounding sphere's position and radius
              // from list of centroids and new points
              /*
               * @param {Sphere}
               *            sphere
               * @param {Object}
               *            components, centroid of all objects in shape
               * @param {Array}
               *            points, flat array of all points in shape
               * @param {int} numPoints, number of valid poitns in points
               */
              static updateBoundingFromPoints(t, r, u, o) {
                t.center.set(0, 0, 0);
                let l = 1 / 0, e = 1 / 0, n = 1 / 0, a = -1 / 0, p = -1 / 0, x = -1 / 0;
                t.box && (l = t.box.min.x, a = t.box.max.x, e = t.box.min.y, p = t.box.max.y, n = t.box.min.z, x = t.box.max.z);
                for (let z = 0, T = o; z < T; z++) {
                  var D = u[z * 3], O = u[z * 3 + 1], R = u[z * 3 + 2];
                  D < l && (l = D), O < e && (e = O), R < n && (n = R), D > a && (a = D), O > p && (p = O), R > x && (x = R);
                }
                t.center.set((a + l) / 2, (p + e) / 2, (x + n) / 2), t.radius = t.center.distanceTo({ x: a, y: p, z: x }), t.box = { min: { x: l, y: e, z: n }, max: { x: a, y: p, z: x } };
              }
              //helper function for adding an appropriately sized mesh
              static addCustomGeo(t, r, u, o, l) {
                var e = r.addGeoGroup(), n = u.vertexArr, a = u.normalArr, p = u.faceArr;
                e.vertices = n.length, e.faceidx = p.length;
                var x, D, O, R, z, T, B, W, k, F = e.vertexArray, U = e.colorArray;
                for (o.constructor !== Array && (W = o.r, k = o.g, R = o.b), T = 0, B = e.vertices; T < B; ++T)
                  x = T * 3, D = n[T], F[x] = D.x, F[x + 1] = D.y, F[x + 2] = D.z, o.constructor === Array && (z = o[T], W = z.r, k = z.g, R = z.b), U[x] = W, U[x + 1] = k, U[x + 2] = R;
                if (l)
                  for (T = 0, B = e.faceidx / 3; T < B; ++T) {
                    x = T * 3, O = p[x], R = p[x + 1], z = p[x + 2];
                    var V = new E.Vector3(), H = new E.Vector3(), G = new E.Vector3();
                    t.intersectionShape.triangle.push(new M.Triangle(V.copy(n[O]), H.copy(n[R]), G.copy(n[z])));
                  }
                if (l) {
                  var Y = new E.Vector3(0, 0, 0), J = 0;
                  for (let ie = 0; ie < r.geometryGroups.length; ie++)
                    Y.add(r.geometryGroups[ie].getCentroid()), J++;
                  Y.divideScalar(J), y.updateBoundingFromPoints(t.boundingSphere, { centroid: Y }, F, e.vertices);
                }
                if (e.faceArray = new Uint16Array(p), e.truncateArrayBuffers(!0, !0), a.length < e.vertices)
                  e.setNormals();
                else {
                  var re = e.normalArray = new Float32Array(e.vertices * 3), le;
                  for (T = 0, B = e.vertices; T < B; ++T)
                    x = T * 3, le = a[T], re[x] = le.x, re[x + 1] = le.y, re[x + 2] = le.z;
                }
                e.setLineIndices(), e.lineidx = e.lineArray.length;
              }
              /*
               *
               * @param {$3Dmol.GLShape}
               *            shape
               * @param {ShapeSpec}
               *            stylespec
               * @returns {undefined}
               */
              static updateFromStyle(t, r) {
                typeof r.color < "u" ? (t.color = r.color || new A.Color(), r.color instanceof A.Color || (t.color = A.CC.color(r.color))) : t.color = A.CC.color(0), t.wireframe = !!r.wireframe, t.opacity = r.alpha ? (0, E.clamp)(r.alpha, 0, 1) : 1, typeof r.opacity < "u" && (t.opacity = (0, E.clamp)(r.opacity, 0, 1)), t.side = r.side !== void 0 ? r.side : v.DoubleSide, t.linewidth = typeof r.linewidth > "u" ? 1 : r.linewidth, t.clickable = !!r.clickable, t.callback = (0, S.makeFunction)(r.callback), t.hoverable = !!r.hoverable, t.hover_callback = (0, S.makeFunction)(r.hover_callback), t.unhover_callback = (0, S.makeFunction)(r.unhover_callback), t.hidden = r.hidden, t.frame = r.frame;
              }
              /**
               * Custom renderable shape
               *
               * @constructor
               *
               * @param {ShapeSpec} stylespec
               */
              constructor(t) {
                this.color = 16777215, this.hidden = !1, this.wireframe = !1, this.opacity = 1, this.linewidth = 1, this.clickable = !1, this.hoverable = !1, this.side = v.DoubleSide, this.stylespec = t || {}, this.boundingSphere = new M.Sphere(), this.intersectionShape = {
                  sphere: [],
                  cylinder: [],
                  line: [],
                  triangle: []
                }, y.updateFromStyle(this, this.stylespec), this.components = [], this.shapeObj = null, this.renderedShapeObj = null, this.geo = new v.Geometry(!0), this.linegeo = new v.Geometry(!0);
              }
              /** Update shape with new style specification
               * @param {ShapeSpec} newspec
                 @example
                  let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                  sphere.updateStyle({color:'yellow',opacity:0.5});
                  viewer.render();
               */
              updateStyle(t) {
                for (var r in t)
                  this.stylespec[r] = t[r];
                if (y.updateFromStyle(this, this.stylespec), t.voldata && t.volscheme) {
                  (0, S.adjustVolumeStyle)(t);
                  const u = t.volscheme, o = t.voldata, l = A.CC, e = u.range() || [-1, 1];
                  this.geo.setColors(function(n, a, p) {
                    let x = o.getVal(n, a, p);
                    return l.color(u.valueToHex(x, e));
                  }), delete this.color;
                }
              }
              /**
               * Creates a custom shape from supplied vertex and face arrays
               * @param {CustomShapeSpec} customSpec
               */
              addCustom(t) {
                t.vertexArr = t.vertexArr || [], t.faceArr = t.faceArr || [], t.normalArr = t.normalArr || [], y.drawCustom(this, this.geo, t);
              }
              /**
               * Creates a sphere shape
               * @param {SphereSpec} sphereSpec
               @example
               viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
               
               viewer.render();
               */
              addSphere(t) {
                t.center || (t.center = new E.Vector3(0, 0, 0)), t.radius = t.radius ? (0, E.clamp)(t.radius, 0, 1 / 0) : 1.5, t.color = A.CC.color(t.color), this.intersectionShape.sphere.push(new M.Sphere(t.center, t.radius)), C.GLDraw.drawSphere(this.geo, t.center, t.radius, t.color, t.quality), this.components.push({
                  centroid: new E.Vector3(t.center.x, t.center.y, t.center.z)
                });
                var r = this.geo.updateGeoGroup(0);
                y.updateBoundingFromPoints(this.boundingSphere, this.components, r.vertexArray, r.vertices);
              }
              /**
               * Creates a box
               * @param {BoxSpec} boxSpec
               @example
               var shape = viewer.addShape({color:'red'});
               shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});
               shape.addBox({corner: {x:-5,y:-3,z:0},
                             dimensions: { w: {x:1,y:1,z:0},
                                           h: {x:-1,y:1,z:0},
                                           d: {x:0,y:0,z:1} }});
               viewer.zoomTo();
               viewer.rotate(30);
               viewer.render();
               */
              addBox(t) {
                var r = t.dimensions || { w: 1, h: 1, d: 1 }, u;
                typeof r.w == "number" ? u = { x: r.w, y: 0, z: 0 } : u = r.w;
                var o;
                typeof r.h == "number" ? o = { x: 0, y: r.h, z: 0 } : o = r.h;
                var l;
                typeof r.d == "number" ? l = { x: 0, y: 0, z: r.d } : l = r.d;
                var e = t.corner;
                e == null && (t.center !== void 0 ? e = {
                  x: t.center.x - 0.5 * (u.x + o.x + l.x),
                  y: t.center.y - 0.5 * (u.y + o.y + l.y),
                  z: t.center.z - 0.5 * (u.z + o.z + l.z)
                } : e = { x: 0, y: 0, z: 0 });
                var n = [
                  { x: e.x, y: e.y, z: e.z },
                  { x: e.x + u.x, y: e.y + u.y, z: e.z + u.z },
                  { x: e.x + o.x, y: e.y + o.y, z: e.z + o.z },
                  { x: e.x + u.x + o.x, y: e.y + u.y + o.y, z: e.z + u.z + o.z },
                  { x: e.x + l.x, y: e.y + l.y, z: e.z + l.z },
                  { x: e.x + u.x + l.x, y: e.y + u.y + l.y, z: e.z + u.z + l.z },
                  { x: e.x + o.x + l.x, y: e.y + o.y + l.y, z: e.z + o.z + l.z },
                  { x: e.x + u.x + o.x + l.x, y: e.y + u.y + o.y + l.y, z: e.z + u.z + o.z + l.z }
                ], a = [], p = [];
                a.splice(a.length, 0, n[0], n[1], n[2], n[3]), p.splice(p.length, 0, 0, 2, 1, 1, 2, 3);
                var x = 4;
                a.splice(a.length, 0, n[2], n[3], n[6], n[7]), p.splice(p.length, 0, x + 0, x + 2, x + 1, x + 1, x + 2, x + 3), x += 4, a.splice(a.length, 0, n[4], n[5], n[0], n[1]), p.splice(p.length, 0, x + 0, x + 2, x + 1, x + 1, x + 2, x + 3), x += 4, a.splice(a.length, 0, n[6], n[7], n[4], n[5]), p.splice(p.length, 0, x + 0, x + 2, x + 1, x + 1, x + 2, x + 3), x += 4, a.splice(a.length, 0, n[3], n[1], n[7], n[5]), p.splice(p.length, 0, x + 0, x + 2, x + 1, x + 1, x + 2, x + 3), x += 4, a.splice(a.length, 0, n[2], n[6], n[0], n[4]), p.splice(p.length, 0, x + 0, x + 2, x + 1, x + 1, x + 2, x + 3), x += 4;
                var D = (0, S.extend)({}, t);
                D.vertexArr = a, D.faceArr = p, D.normalArr = [], y.drawCustom(this, this.geo, D);
                var O = new E.Vector3();
                this.components.push({
                  centroid: O.addVectors(n[0], n[7]).multiplyScalar(0.5)
                });
                var R = this.geo.updateGeoGroup(0);
                y.updateBoundingFromPoints(this.boundingSphere, this.components, R.vertexArray, R.vertices);
              }
              /**
               * Creates a cylinder shape
               * @param {CylinderSpec} cylinderSpec
               @example
                    viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
                                        end:{x:10.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        fromCap:1,
                                        toCap:2,
                                        color:'red',
                                        hoverable:true,
                                        clickable:true,
                                        callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
                                        hover_callback: function(){ viewer.render( );},
                                        unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
                                       });
                    viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
                                        end:{x:0.0,y:10.0,z:0.0},
                                        radius:0.5,
                                        fromCap:false,
                                        toCap:true,
                                        color:'teal'});
                    viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
                                        end:{x:20.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        color:'black',
                                        fromCap:false,
                                        toCap:false});
                    viewer.render();
               */
              addCylinder(t) {
                var r, u;
                t.start ? r = new E.Vector3(t.start.x || 0, t.start.y || 0, t.start.z || 0) : r = new E.Vector3(0, 0, 0), t.end ? (u = new E.Vector3(t.end.x, t.end.y || 0, t.end.z || 0), typeof u.x > "u" && (u.x = 3)) : u = new E.Vector3(0, 0, 0);
                var o = t.radius || 0.1, l = A.CC.color(t.color);
                this.intersectionShape.cylinder.push(new M.Cylinder(r, u, o)), C.GLDraw.drawCylinder(this.geo, r, u, o, l, t.fromCap, t.toCap);
                var e = new E.Vector3();
                this.components.push({
                  centroid: e.addVectors(r, u).multiplyScalar(0.5)
                });
                var n = this.geo.updateGeoGroup(0);
                y.updateBoundingFromPoints(this.boundingSphere, this.components, n.vertexArray, n.vertices);
              }
              /**
               * Creates a dashed cylinder shape
               * @param {CylinderSpec} cylinderSpec
               */
              addDashedCylinder(t) {
                t.dashLength = t.dashLength || 0.25, t.gapLength = t.gapLength || 0.25;
                var r;
                t.start ? r = new E.Vector3(t.start.x || 0, t.start.y || 0, t.start.z || 0) : r = new E.Vector3(0, 0, 0);
                var u;
                t.end ? (u = new E.Vector3(t.end.x, t.end.y || 0, t.end.z || 0), typeof u.x > "u" && (u.x = 3)) : u = new E.Vector3(3, 0, 0);
                for (var o = t.radius || 0.1, l = A.CC.color(t.color), e = Math.sqrt(Math.pow(r.x - u.x, 2) + Math.pow(r.y - u.y, 2) + Math.pow(r.z - u.z, 2)), n = e / (t.gapLength + t.dashLength), a = new E.Vector3(t.start.x || 0, t.start.y || 0, t.start.z || 0), p = new E.Vector3(t.end.x, t.end.y || 0, t.end.z || 0), x = new E.Vector3((u.x - r.x) / (e / t.gapLength), (u.y - r.y) / (e / t.gapLength), (u.z - r.z) / (e / t.gapLength)), D = new E.Vector3((u.x - r.x) / (e / t.dashLength), (u.y - r.y) / (e / t.dashLength), (u.z - r.z) / (e / t.dashLength)), O = 0; O < n; O++)
                  p = new E.Vector3(a.x + D.x, a.y + D.y, a.z + D.z), this.intersectionShape.cylinder.push(new M.Cylinder(a, p, o)), C.GLDraw.drawCylinder(this.geo, a, p, o, l, t.fromCap, t.toCap), a = new E.Vector3(p.x + x.x, p.y + x.y, p.z + x.z);
                var R = new E.Vector3();
                this.components.push({
                  centroid: R.addVectors(r, u).multiplyScalar(0.5)
                });
                var z = this.geo.updateGeoGroup(0);
                y.updateBoundingFromPoints(this.boundingSphere, this.components, z.vertexArray, z.vertices);
              }
              /**
               * Creates a curved shape
               * @param {CurveSpec} curveSpec
               */
              addCurve(t) {
                t.points = t.points || [], t.smooth = t.smooth || 10, typeof t.fromCap > "u" && (t.fromCap = 2), typeof t.toCap > "u" && (t.toCap = 2);
                var r = (0, c.subdivide_spline)(t.points, t.smooth);
                if (r.length < 3) {
                  console.log("Too few points in addCurve");
                  return;
                }
                var u = t.radius || 0.1, o = A.CC.color(t.color), l = 0, e = r.length - 1, n = r[0].distanceTo(r[1]), a = Math.ceil(2 * u / n);
                if (t.toArrow) {
                  e -= a;
                  let O = {
                    start: r[e],
                    end: r[r.length - 1],
                    radius: u,
                    color: o,
                    mid: 1e-4
                  };
                  this.addArrow(O);
                }
                if (t.fromArrow) {
                  l += a;
                  let O = {
                    start: r[l],
                    end: r[0],
                    radius: u,
                    color: o,
                    mid: 1e-4
                  };
                  this.addArrow(O);
                }
                for (var p = Math.ceil(r.length / 2), x = { radius: u, color: o, fromCap: 2, toCap: 2 }, D = l; D < e; D++)
                  x.start = r[D], x.end = r[D + 1], x.fromCap = 2, x.toCap = 2, D < p ? (x.fromCap = 2, x.toCap = 0) : D > p ? (x.fromCap = 0, x.toCap = 2) : (x.fromCap = 2, x.toCap = 2), this.addCylinder(x);
              }
              /**
               * Creates a line shape
               * @param {LineSpec} lineSpec
               @example
               $3Dmol.download("pdb:2ABJ",viewer,{},function(){
                        viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
                        viewer.render(callback);
                    });
              
               */
              addLine(t) {
                var r, u;
                t.start ? r = new E.Vector3(t.start.x || 0, t.start.y || 0, t.start.z || 0) : r = new E.Vector3(0, 0, 0), t.end ? (u = new E.Vector3(t.end.x, t.end.y || 0, t.end.z || 0), typeof u.x > "u" && (u.x = 3)) : u = new E.Vector3(3, 0, 0);
                var o = this.geo.updateGeoGroup(2), l = o.vertices, e = l * 3, n = o.vertexArray;
                n[e] = r.x, n[e + 1] = r.y, n[e + 2] = r.z, n[e + 3] = u.x, n[e + 4] = u.y, n[e + 5] = u.z, o.vertices += 2;
                var a = o.lineArray, p = o.lineidx;
                a[p] = l, a[p + 1] = l + 1, o.lineidx += 2;
                var x = new E.Vector3();
                this.components.push({
                  centroid: x.addVectors(r, u).multiplyScalar(0.5)
                }), o = this.geo.updateGeoGroup(0), y.updateBoundingFromPoints(this.boundingSphere, this.components, o.vertexArray, o.vertices);
              }
              /**
               * Creates an arrow shape
               * @param {ArrowSpec} arrowSpec
               @example
                $3Dmol.download("pdb:4DM7",viewer,{},function(){
                        viewer.setBackgroundColor(0xffffffff);
                        viewer.addArrow({
                            start: {x:-10.0, y:0.0, z:0.0},
                            end: {x:0.0, y:-10.0, z:0.0},
                            radius: 1.0,
                            radiusRadio:1.0,
                            mid:1.0,
                            clickable:true,
                            callback:function(){
                                this.color.setHex(0xFF0000FF);
                                viewer.render( );
                            }
                        });
                        viewer.render();
                      });
               */
              addArrow(t) {
                if (t.start ? t.start = new E.Vector3(t.start.x || 0, t.start.y || 0, t.start.z || 0) : t.start = new E.Vector3(0, 0, 0), t.dir instanceof E.Vector3 && typeof t.length == "number") {
                  var r = t.dir.clone().multiplyScalar(t.length).add(t.start);
                  t.end = r;
                } else
                  t.end ? (t.end = new E.Vector3(t.end.x, t.end.y || 0, t.end.z || 0), typeof t.end.x > "u" && (t.end.x = 3)) : t.end = new E.Vector3(3, 0, 0);
                t.radius = t.radius || 0.1, t.radiusRatio = t.radiusRatio || 1.618034, t.mid = 0 < t.mid && t.mid < 1 ? t.mid : 0.618034, y.drawArrow(this, this.geo, t);
                var u = new E.Vector3();
                this.components.push({
                  centroid: u.addVectors(t.start, t.end).multiplyScalar(0.5)
                });
                var o = this.geo.updateGeoGroup(0);
                y.updateBoundingFromPoints(this.boundingSphere, this.components, o.vertexArray, o.vertices);
              }
              static distance_from(t, r) {
                return Math.sqrt(Math.pow(t.x - r.x, 2) + Math.pow(t.y - r.y, 2) + Math.pow(t.z - r.z, 2));
              }
              static inSelectedRegion(t, r, u) {
                for (var o = 0; o < r.length; o++)
                  if (y.distance_from(r[o], t) <= u)
                    return !0;
                return !1;
              }
              /**
               * Create isosurface from voluemetric data.
               * @param {VolumeData} data - volumetric input data
               * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification
               * @example //the user can specify a selected region for the isosurface
               $.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue",
                                                       alpha: 0.5,
                                                       smoothness: 10});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red",
                                                       smoothness: 5,
                                                       opacity:0.5,
                                                       wireframe:true,
                                                       clickable:true,
                                                       callback:
                                                       function() {
                                                           this.opacity = 0.0;
                                                           viewer.render( );
                                                       }});
                        viewer.setStyle({}, {stick:{}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(t, r, u) {
                var o = r.isoval !== void 0 && typeof r.isoval == "number" ? r.isoval : 0, l = !!r.voxel, e = r.smoothness === void 0 ? 1 : r.smoothness, n = t.size.x, a = t.size.y, p = t.size.z, x = new Int16Array(n * a * p), D = t.data, O, R;
                for (O = 0, R = x.length; O < R; ++O)
                  x[O] = -1;
                var z = new Uint8Array(n * a * p);
                for (O = 0, R = D.length; O < R; ++O) {
                  var T = o >= 0 ? D[O] - o : o - D[O];
                  T > 0 && (z[O] |= y.ISDONE);
                }
                var B = [], W = [];
                h.MarchingCube.march(z, B, W, {
                  fulltable: !0,
                  voxel: l,
                  unitCube: t.unit,
                  origin: t.origin,
                  matrix: t.matrix,
                  nX: n,
                  nY: a,
                  nZ: p
                }), !l && e > 0 && h.MarchingCube.laplacianSmooth(e, B, W);
                var k = [], F = [], U = [];
                if (r.selectedRegion && r.coords === void 0 && (r.coords = r.selectedRegion), r.coords !== void 0) {
                  var V = r.coords[0].x, H = r.coords[0].y, G = r.coords[0].z, Y = r.coords[0].x, J = r.coords[0].y, re = r.coords[0].z;
                  for (let ae = 0; ae < r.coords.length; ae++)
                    r.coords[ae].x > V ? V = r.coords[ae].x : r.coords[ae].x < Y && (Y = r.coords[ae].x), r.coords[ae].y > H ? H = r.coords[ae].y : r.coords[ae].y < J && (J = r.coords[ae].y), r.coords[ae].z > G ? G = r.coords[ae].z : r.coords[ae].z < re && (re = r.coords[ae].z);
                  var le = 2;
                  r.radius !== void 0 && (le = r.radius), r.selectedOffset !== void 0 && (le = r.selectedOffset), r.seldist !== void 0 && (le = r.seldist), Y -= le, V += le, J -= le, H += le, re -= le, G += le;
                  for (let ae = 0; ae < B.length; ae++)
                    B[ae].x > Y && B[ae].x < V && B[ae].y > J && B[ae].y < H && B[ae].z > re && B[ae].z < G && y.inSelectedRegion(B[ae], r.coords, le) ? (k.push(F.length), F.push(B[ae])) : k.push(-1);
                  for (let ae = 0; ae + 2 < W.length; ae += 3)
                    k[W[ae]] !== -1 && k[W[ae + 1]] !== -1 && k[W[ae + 2]] !== -1 && (U.push(W[ae] - (W[ae] - k[W[ae]])), U.push(W[ae + 1] - (W[ae + 1] - k[W[ae + 1]])), U.push(W[ae + 2] - (W[ae + 2] - k[W[ae + 2]])));
                  B = F, W = U;
                }
                y.drawCustom(this, this.geo, {
                  vertexArr: B,
                  faceArr: W,
                  normalArr: [],
                  clickable: r.clickable,
                  hoverable: r.hoverable
                }), this.updateStyle(r);
                var ie = new E.Vector3(t.origin.x, t.origin.y, t.origin.z), xe = new E.Vector3(t.size.x * t.unit.x, t.size.y * t.unit.y, t.size.z * t.unit.z), se = new E.Vector3(0, 0, 0), ce = ie.clone(), Ee = ie.clone().add(xe);
                for (let ae = 0; ae < B.length; ae++)
                  se.add(B[ae]), ce.max(B[ae]), Ee.min(B[ae]);
                se.divideScalar(B.length);
                var be = se.distanceTo(Ee), Le = se.distanceTo(ce);
                this.boundingSphere.center = se, this.boundingSphere.radius = Math.max(be, Le), typeof u == "function" && u();
              }
              /**
               * @deprecated Use addIsosurface instead
               * Creates custom shape from volumetric data
               * @param {string} data - Volumetric input data
               * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)
               * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification
               */
              addVolumetricData(t, r, u) {
                t = new g.VolumeData(t, r), this.addIsosurface(t, u);
              }
              //for internal use, truncate buffers to save memory
              finalize() {
                return y.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.geo;
              }
              /*
               * Initialize webgl objects for rendering
               * @param {$3Dmol.Object3D} group
               *
               */
              globj(t) {
                if (this.renderedShapeObj && (t.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  y.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.wireframe && this.geo.setUpWireframe(), typeof this.color < "u" && y.updateColor(this.geo, this.color), this.shapeObj = new v.Object3D();
                  var r = null;
                  this.side == v.DoubleSide ? r = new v.MeshDoubleLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: v.Coloring.VertexColors
                  }) : r = new v.MeshLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: v.Coloring.VertexColors
                  });
                  var u = new v.Mesh(this.geo, r);
                  this.shapeObj.add(u);
                  var o = new v.LineBasicMaterial({
                    linewidth: this.linewidth,
                    color: this.color
                  }), l = new v.Line(this.linegeo, o, v.LineStyle.LinePieces);
                  this.shapeObj.add(l), this.renderedShapeObj = this.shapeObj.clone(), t.add(this.renderedShapeObj);
                }
              }
              removegl(t) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), t.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
            y.ISDONE = 2, y.drawCustom = function(w, t, r) {
              var u = r, o = u.vertexArr, l = u.faceArr;
              (o.length === 0 || l.length === 0) && console.warn("Error adding custom shape component: No vertices and/or face indices supplied!");
              var e = r.color;
              typeof e > "u" && (e = w.color), e = A.CC.color(e);
              for (var n = b(u), a = 0, p = n.length; a < p; a++)
                y.addCustomGeo(w, t, n[a], n[a].colorArr ? n[a].colorArr : e, r.clickable);
            };
            function b(w) {
              var t = 64e3;
              if (w.vertexArr.length < t)
                return [w];
              var r = [{ vertexArr: [], normalArr: [], faceArr: [] }];
              w.colorArr && (r.colorArr = []);
              var u = [], o = [], l = 0, e = w.faceArr;
              for (let a = 0, p = e.length; a < p; a += 3) {
                let x = r[l];
                for (let D = 0; D < 3; D++) {
                  var n = e[a + D];
                  u[n] !== l && (u[n] = l, o[n] = x.vertexArr.length, x.vertexArr.push(w.vertexArr[n]), w.normalArr && w.normalArr[n] && x.normalArr.push(w.normalArr[n]), w.colorArr && w.colorArr[n] && x.colorArr.push(w.colorArr[n])), x.faceArr.push(o[n]);
                }
                x.vertexArr.length >= t && (r.push({ vertexArr: [], normalArr: [], faceArr: [] }), w.colorArr && (r.colorArr = []), l++);
              }
              return r;
            }
          }
        ),
        /***/
        "./src/GLViewer.ts": (
          /*!*************************!*\
            !*** ./src/GLViewer.ts ***!
            \*************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              GLViewer: () => (
                /* binding */
                t
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* binding */
                o
              ),
              /* harmony export */
              createViewer: () => (
                /* binding */
                r
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), E = s(
              /*! ./colors */
              "./src/colors.ts"
            ), A = s(
              /*! ./utilities */
              "./src/utilities.ts"
            ), h = s(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), g = s(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), C = s(
              /*! ./Label */
              "./src/Label.ts"
            ), c = s(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), S = s(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), y = s(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), b = s(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), w = s(
              /*! upng-js */
              "./node_modules/upng-js/UPNG.js"
            );
            class t {
              //reimplement jquery getwidth/height
              getRect() {
                let e = this.container, n = e.getBoundingClientRect();
                if (n.width == 0 && n.height == 0 && e.style.display === "none") {
                  let a = e.style.position, p = e.style.visibility;
                  e.style.display = "block", e.style.visibility = "hidden", e.style.position = "absolute", n = e.getBoundingClientRect(), e.style.display = "none", e.style.visibility = p, e.style.position = a;
                }
                return n;
              }
              getWidth() {
                return this.getRect().width;
              }
              getHeight() {
                return this.getRect().height;
              }
              setupRenderer() {
                this.renderer = new v.Renderer({
                  antialias: this.config.antialias,
                  preserveDrawingBuffer: !0,
                  premultipliedAlpha: !1,
                  id: this.config.id,
                  row: this.config.row,
                  col: this.config.col,
                  rows: this.config.rows,
                  cols: this.config.cols,
                  canvas: this.config.canvas,
                  //cannot initialize with zero size
                  containerWidth: this.WIDTH || 1,
                  containerHeight: this.HEIGHT || 1
                }), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.renderer.domElement.style.padding = "0", this.renderer.domElement.style.position = "absolute", this.renderer.domElement.style.top = "0px", this.renderer.domElement.style.left = "0px", this.renderer.domElement.style.zIndex = "0";
              }
              initializeScene() {
                this.scene = new v.Scene(), this.scene.fog = new v.Fog(this.bgColor, 100, 200), this.modelGroup = new v.Object3D(), this.rotationGroup = new v.Object3D(), this.rotationGroup.useQuaternion = !0, this.rotationGroup.quaternion = new M.Quaternion(0, 0, 0, 1), this.rotationGroup.add(this.modelGroup), this.scene.add(this.rotationGroup);
                var e = new v.Light(16777215);
                e.position = new M.Vector3(0.2, 0.2, 1).normalize(), e.intensity = 1, this.scene.add(e);
              }
              initContainer(e) {
                this.container = e, this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.container.append(this.renderer.domElement), this.glDOM = this.renderer.domElement, this.nomouse || (this.glDOM.addEventListener("mousedown", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchstart", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("wheel", this._handleMouseScroll.bind(this), { passive: !1 }), this.glDOM.addEventListener("mousemove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchmove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("contextmenu", this._handleContextMenu.bind(this), { passive: !1 }));
              }
              decAnim() {
                this.animated--, this.animated < 0 && (this.animated = 0);
              }
              incAnim() {
                this.animated++;
              }
              nextSurfID() {
                var e = 0;
                for (let a in this.surfaces)
                  if (this.surfaces.hasOwnProperty(a)) {
                    var n = parseInt(a);
                    isNaN(n) || n > e && (e = n);
                  }
                return e + 1;
              }
              setSlabAndFog() {
                let e = this.camera.position.z - this.rotationGroup.position.z;
                e < 1 && (e = 1), this.camera.near = e + this.slabNear, this.camera.near < 1 && (this.camera.near = 1), this.camera.far = e + this.slabFar, this.camera.near + 1 > this.camera.far && (this.camera.far = this.camera.near + 1), this.camera.fov = this.fov, this.camera.right = e * Math.tan(Math.PI / 180 * this.fov), this.camera.left = -this.camera.right, this.camera.top = this.camera.right / this.ASPECT, this.camera.bottom = -this.camera.top, this.camera.updateProjectionMatrix(), this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near), this.scene.fog.far = this.camera.far, this.config.disableFog && (this.scene.fog.near = this.scene.fog.far);
              }
              // display scene
              //if nolink is set/true, don't propagate changes to linked viewers
              show(e) {
                if (this.renderer.setViewport(), !!this.scene && (this.setSlabAndFog(), this.renderer.render(this.scene, this.camera), this.viewChangeCallback && this.viewChangeCallback(this._viewer.getView()), !e && this.linkedViewers.length > 0))
                  for (var n = this._viewer.getView(), a = 0; a < this.linkedViewers.length; a++) {
                    var p = this.linkedViewers[a];
                    p.setView(n, !0);
                  }
              }
              //regenerate the list of clickables
              //also updates hoverables
              updateClickables() {
                this.clickables.splice(0, this.clickables.length), this.hoverables.splice(0, this.hoverables.length), this.contextMenuEnabledAtoms.splice(0, this.contextMenuEnabledAtoms.length);
                for (let e = 0, n = this.models.length; e < n; e++) {
                  let a = this.models[e];
                  if (a) {
                    let p = a.selectedAtoms({
                      clickable: !0
                    }), x = a.selectedAtoms({
                      hoverable: !0
                    }), D = a.selectedAtoms({ contextMenuEnabled: !0 });
                    for (let O = 0; O < x.length; O++)
                      this.hoverables.push(x[O]);
                    for (let O = 0; O < p.length; O++)
                      this.clickables.push(p[O]);
                    for (let O = 0; O < D.length; O++)
                      this.contextMenuEnabledAtoms.push(D[O]);
                  }
                }
                for (let e = 0, n = this.shapes.length; e < n; e++) {
                  let a = this.shapes[e];
                  a && a.clickable && this.clickables.push(a), a && a.hoverable && this.hoverables.push(a);
                }
              }
              // Checks for selection intersects on mousedown
              handleClickSelection(e, n, a) {
                let p = this.targetedObjects(e, n, this.clickables);
                if (p.length) {
                  var x = p[0].clickable;
                  x.callback !== void 0 && (typeof x.callback != "function" && (x.callback = (0, A.makeFunction)(x.callback)), typeof x.callback == "function" && x.callback(x, this._viewer, a, this.container, p));
                }
              }
              //return offset of container
              canvasOffset() {
                let e = this.glDOM, n = e.getBoundingClientRect(), a = e.ownerDocument, p = a.documentElement, x = a.defaultView;
                return {
                  top: n.top + x.pageYOffset - p.clientTop,
                  left: n.left + x.pageXOffset - p.clientLeft
                };
              }
              //set current_hover to sel (which can be null), calling appropraite callbacks
              setHover(e, n, a) {
                this.current_hover != e && (this.current_hover && (typeof this.current_hover.unhover_callback != "function" && (this.current_hover.unhover_callback = (0, A.makeFunction)(this.current_hover.unhover_callback)), this.current_hover.unhover_callback(this.current_hover, this._viewer, n, this.container, a)), this.current_hover = e, e && e.hover_callback !== void 0 && (typeof e.hover_callback != "function" && (e.hover_callback = (0, A.makeFunction)(e.hover_callback)), typeof e.hover_callback == "function" && e.hover_callback(e, this._viewer, n, this.container, a)));
              }
              //checks for selection intersects on hover
              handleHoverSelection(e, n, a) {
                if (this.hoverables.length == 0)
                  return;
                let p = this.targetedObjects(e, n, this.hoverables);
                if (p.length) {
                  var x = p[0].clickable;
                  this.setHover(x, a, p), this.current_hover = x;
                } else
                  this.setHover(null);
              }
              //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called
              handleHoverContinue(e, n) {
                let a = this.targetedObjects(e, n, this.hoverables);
                (a.length == 0 || a[0] === void 0) && this.setHover(null), a[0] !== void 0 && a[0].clickable !== this.current_hover && this.setHover(null);
              }
              /**
               * Determine if a positioned event is "close enough" to mouseStart to be considered a click.
               * With a mouse, the position should be exact, but allow a slight delta for a touch interface.
               * @param {Event} event
               * @param {{ allowTolerance, tolerance: number }} options
               */
              closeEnoughForClick(e, { allowTolerance: n = e.targetTouches, tolerance: a = 5 } = {}) {
                const p = this.getX(e), x = this.getY(e);
                if (n) {
                  const D = Math.abs(p - this.mouseStartX), O = Math.abs(x - this.mouseStartY);
                  return D <= a && O <= a;
                } else
                  return p === this.mouseStartX && x === this.mouseStartY;
              }
              calcTouchDistance(e) {
                var n = e.targetTouches[0].pageX - e.targetTouches[1].pageX, a = e.targetTouches[0].pageY - e.targetTouches[1].pageY;
                return Math.hypot(n, a);
              }
              //check targetTouches as well
              getX(e) {
                var n = e.pageX;
                return n == null && (n = e.pageX), e.targetTouches && e.targetTouches[0] ? n = e.targetTouches[0].pageX : e.changedTouches && e.changedTouches[0] && (n = e.changedTouches[0].pageX), n;
              }
              getY(e) {
                var n = e.pageY;
                return n == null && (n = e.pageY), e.targetTouches && e.targetTouches[0] ? n = e.targetTouches[0].pageY : e.changedTouches && e.changedTouches[0] && (n = e.changedTouches[0].pageY), n;
              }
              //for grid viewers, return true if point is in this viewer
              isInViewer(e, n) {
                if (this.viewers != null) {
                  var a = this.WIDTH / this.cols, p = this.HEIGHT / this.rows, x = this.canvasOffset(), D = e - x.left, O = n - x.top, R = this.rows - Math.floor(O / p) - 1, z = Math.floor(D / a);
                  if (R != this.row || z != this.col)
                    return !1;
                }
                return !0;
              }
              //if the user has specify zoom limits, readjust to fit within them
              //also, make sure we don't go past CAMERA_Z
              adjustZoomToLimits(e) {
                if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {
                  let n = this.CAMERA_Z - this.config.lowerZoomLimit;
                  e > n && (e = n);
                }
                if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {
                  let n = this.CAMERA_Z - this.config.upperZoomLimit;
                  e < n && (e = n);
                }
                return e > this.CAMERA_Z - 1 && (e = this.CAMERA_Z - 1), e;
              }
              //interpolate between two normalized quaternions (t between 0 and 1)
              //https://en.wikipedia.org/wiki/Slerp
              static slerp(e, n, a) {
                if (a == 1)
                  return n.clone();
                if (a == 0)
                  return e.clone();
                let p = e.x * n.x + e.y * n.y + e.z * n.z + e.w * n.w;
                if (p > 0.9995) {
                  let B = new M.Quaternion(e.x + a * (n.x - e.x), e.y + a * (n.y - e.y), e.z + a * (n.z - e.z), e.w + a * (n.w - e.w));
                  return B.normalize(), B;
                }
                p < 0 && (n = n.clone().multiplyScalar(-1), p = -p), p > 1 ? p = 1 : p < -1 && (p = -1);
                var x = Math.acos(p), D = x * a, O = n.clone();
                O.sub(e.clone().multiplyScalar(p)), O.normalize();
                var R = Math.cos(D), z = Math.sin(D), T = new M.Quaternion(e.x * R + O.x * z, e.y * R + O.y * z, e.z * R + O.z * z, e.w * R + O.w * z);
                return T.normalize(), T;
              }
              /* @param {Object} element HTML element within which to create viewer
               * @param {ViewerSpec} config Object containing optional configuration for the viewer
               */
              constructor(e, n = {}) {
                this.nomouse = !1, this.glDOM = null, this.models = [], this.surfaces = {}, this.shapes = [], this.labels = [], this.clickables = [], this.hoverables = [], this.contextMenuEnabledAtoms = [], this.current_hover = null, this.hoverDuration = 500, this.viewer_frame = 0, this.viewChangeCallback = null, this.stateChangeCallback = null, this.NEAR = 1, this.FAR = 800, this.CAMERA_Z = 150, this.fov = 20, this.linkedViewers = [], this.renderer = null, this.control_all = !1, this.scene = null, this.rotationGroup = null, this.modelGroup = null, this.fogStart = 0.4, this.slabNear = -50, this.slabFar = 50, this.cq = new M.Quaternion(0, 0, 0, 1), this.dq = new M.Quaternion(0, 0, 0, 1), this.animated = 0, this.animationTimers = /* @__PURE__ */ new Set(), this.isDragging = !1, this.mouseStartX = 0, this.mouseStartY = 0, this.touchDistanceStart = 0, this.touchHold = !1, this.currentModelPos = 0, this.cz = 0, this.cslabNear = 0, this.cslabFar = 0, this.userContextMenuHandler = null, this.config = n, this.callback = this.config.callback, this.defaultcolors = this.config.defaultcolors, this.defaultcolors || (this.defaultcolors = E.elementColors.defaultColors), this.nomouse = this.config.nomouse, this.bgColor = 0, this.config.backgroundColor = this.config.backgroundColor || "#ffffff", typeof this.config.backgroundColor < "u" && (this.bgColor = E.CC.color(this.config.backgroundColor).getHex()), this.config.backgroundAlpha = this.config.backgroundAlpha == null ? 1 : this.config.backgroundAlpha, this.camerax = 0, typeof this.config.camerax < "u" && (this.camerax = parseFloat(this.config.camerax)), this._viewer = this, this.container = e, this.config.hoverDuration != null && (this.hoverDuration = this.config.hoverDuration), this.config.antialias === void 0 && (this.config.antialias = !0), this.config.cartoonQuality === void 0 && (this.config.cartoonQuality = 10), this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.setupRenderer(), this.row = this.config.row == null ? 0 : this.config.row, this.col = this.config.col == null ? 0 : this.config.col, this.cols = this.config.cols, this.rows = this.config.rows, this.viewers = this.config.viewers, this.control_all = this.config.control_all, this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.camera = new v.Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic), this.camera.position = new M.Vector3(this.camerax, 0, this.CAMERA_Z), this.lookingAt = new M.Vector3(), this.camera.lookAt(this.lookingAt), this.raycaster = new v.Raycaster(new M.Vector3(0, 0, 0), new M.Vector3(0, 0, 0)), this.projector = new v.Projector(), this.initializeScene(), this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha), this.scene.fog.color = E.CC.color(this.bgColor), document.body.addEventListener("mouseup", this._handleMouseUp.bind(this)), document.body.addEventListener("touchend", this._handleMouseUp.bind(this)), this.initContainer(this.container), this.config.style && this.setViewStyle(this.config), window.addEventListener("resize", this.resize.bind(this)), typeof window.ResizeObserver < "u" && (this.divwatcher = new window.ResizeObserver(this.resize.bind(this)), this.divwatcher.observe(this.container));
                try {
                  typeof this.callback == "function" && this.callback(this);
                } catch (a) {
                  console.log("error with glviewer callback: " + a);
                }
              }
              /**
              * Return a list of objects that intersect that at the specified viewer position.
              *
              * @param x - x position in screen coordinates
              * @param y - y position in screen coordinates
              * @param {Object[]} - list of objects or selection object specifying what object to check for targeting
              */
              targetedObjects(e, n, a) {
                var p = {
                  x: e,
                  y: n,
                  z: -1
                };
                return Array.isArray(a) || (a = this.selectedAtoms(a)), a.length == 0 ? [] : (this.raycaster.setFromCamera(p, this.camera), this.raycaster.intersectObjects(this.modelGroup, a));
              }
              /** Convert model coordinates to screen coordinates.
               * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)
               * @return {object | list} - and object or list of {x: screenX, y: screenY}
               */
              modelToScreen(e) {
                let n = !1;
                Array.isArray(e) || (e = [e], n = !0);
                let a = this.renderer.getXRatio(), p = this.renderer.getYRatio(), x = this.col, D = this.row, O = x * (this.WIDTH / a), R = (p - D - 1) * (this.HEIGHT / p), z = [], T = this.canvasOffset();
                return e.forEach((B) => {
                  let W = new M.Vector3(B.x, B.y, B.z);
                  W.applyMatrix4(this.modelGroup.matrixWorld), this.projector.projectVector(W, this.camera);
                  let k = this.WIDTH / a * (W.x + 1) / 2 + T.left + O, F = -(this.HEIGHT / p) * (W.y - 1) / 2 + T.top + R;
                  z.push({ x: k, y: F });
                }), n && (z = z[0]), z;
              }
              /**
               * For a given screen (x,y) displacement return model displacement
               * @param{x} x displacement in screen coordinates
               * @param{y} y displacement in screen corodinates
               * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis
              */
              screenOffsetToModel(e, n, a) {
                var p = e / this.WIDTH, x = n / this.HEIGHT, D = a === void 0 ? this.rotationGroup.position.z : a, O = this.rotationGroup.quaternion, R = new M.Vector3(0, 0, D);
                return this.projector.projectVector(R, this.camera), R.x += p * 2, R.y -= x * 2, this.projector.unprojectVector(R, this.camera), R.z = 0, R.applyQuaternion(O), R;
              }
              /**
               * Distance from screen coordinate to model coordinate assuming screen point
               * is projected to the same depth as model coordinate
               * @param{screen} xy screen coordinate
               * @param{model} xyz model coordinate
              */
              screenToModelDistance(e, n) {
                let a = this.canvasOffset(), p = new M.Vector3(n.x, n.y, n.z);
                p.applyMatrix4(this.modelGroup.matrixWorld);
                let x = p.clone();
                this.projector.projectVector(p, this.camera);
                let D = new M.Vector3((e.x - a.left) * 2 / this.WIDTH - 1, (e.y - a.top) * 2 / -this.HEIGHT + 1, p.z);
                return this.projector.unprojectVector(D, this.camera), D.distanceTo(x);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setViewChangeCallback(e) {
                (typeof e == "function" || e == null) && (this.viewChangeCallback = e);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setStateChangeCallback(e) {
                (typeof e == "function" || e == null) && (this.stateChangeCallback = e);
              }
              /**
               * Return configuration of viewer
               */
              getConfig() {
                return this.config;
              }
              /**
               * Set the configuration object.  Note that some setting may only
               * have an effect at viewer creation time.
               */
              setConfig(e) {
                this.config = e;
              }
              /**
               * Return object representing internal state of
               * the viewer appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                var e = { models: [], surfaces: [], shapes: [], labels: [] };
                for (let n = 0; n < this.models.length; n++)
                  this.models[n] && (e.models[n] = this.models[n].getInternalState());
                return e;
              }
              /**
               * Overwrite internal state of the viewer with passed  object
               * which should come from getInternalState.
               *
              */
              setInternalState(e) {
                this.clear();
                var n = e.models;
                for (let a = 0; a < n.length; a++)
                  n[a] && (this.models[a] = new g.GLModel(a), this.models[a].setInternalState(n[a]));
                this.render();
              }
              /**
               * Set lower and upper limit stops for zoom.
               *
               * @param {lower} - limit on zoom in (positive number).  Default 0.
               * @param {upper} - limit on zoom out (positive number).  Default infinite.
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(moldata) {
                      var m = viewer.addModel(moldata);
                      viewer.setStyle({stick:{colorscheme:"Jmol"}});
                      viewer.setZoomLimits(100,200);
                      viewer.zoomTo();
                      viewer.zoom(10); //will not zoom all the way
                      viewer.render();
                  });
              */
              setZoomLimits(e, n) {
                typeof e < "u" && (this.config.lowerZoomLimit = e), n && (this.config.upperZoomLimit = n), this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
              }
              /**
               * Set camera parameters (distance to the origin and field of view)
               *
               * @param {parameters} - new camera parameters, with possible fields
               *                       being fov for the field of view, z for the
               *                       distance to the origin, and orthographic (boolean)
               *                       for kind of projection (default false).
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(data) {
                      var m = viewer.addModel(data);
                      viewer.setStyle({stick:{}});
                      viewer.zoomTo();
                      viewer.setCameraParameters({ fov: 10 , z: 300 });
                      viewer.render();
                  });
              */
              setCameraParameters(e) {
                e.fov !== void 0 && (this.fov = e.fov, this.camera.fov = this.fov), e.z !== void 0 && (this.CAMERA_Z = e.z, this.camera.z = this.CAMERA_Z), e.orthographic !== void 0 && (this.camera.ortho = e.orthographic);
              }
              _handleMouseDown(e) {
                if (e.preventDefault(), !this.scene)
                  return;
                var n = this.getX(e), a = this.getY(e);
                if (n === void 0)
                  return;
                this.isDragging = !0, this.mouseButton = e.which, this.mouseStartX = n, this.mouseStartY = a, this.touchHold = !0, this.touchDistanceStart = 0, e.targetTouches && e.targetTouches.length == 2 && (this.touchDistanceStart = this.calcTouchDistance(e)), this.cq = this.rotationGroup.quaternion.clone(), this.cz = this.rotationGroup.position.z, this.currentModelPos = this.modelGroup.position.clone(), this.cslabNear = this.slabNear, this.cslabFar = this.slabFar;
                let p = this;
                setTimeout(function() {
                  e.targetTouches && p.touchHold == !0 && (p.glDOM = p.renderer.domElement, p.glDOM.dispatchEvent(new Event("contextmenu")));
                }, 1e3);
              }
              _handleMouseUp(e) {
                if (this.touchHold = !1, this.isDragging && this.scene) {
                  var n = this.getX(e), a = this.getY(e);
                  if (this.closeEnoughForClick(e) && this.isInViewer(n, a)) {
                    let p = this.mouseXY(n, a);
                    this.handleClickSelection(p.x, p.y, e);
                  }
                }
                this.isDragging = !1;
              }
              _handleMouseScroll(e) {
                if (e.preventDefault(), !!this.scene) {
                  var n = this.getX(e), a = this.getY(e);
                  if (n !== void 0 && !(!this.control_all && !this.isInViewer(n, a))) {
                    var p = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, x = 1;
                    if (e.ctrlKey && (x = -1), e.detail)
                      this.rotationGroup.position.z += x * p * e.detail / 10;
                    else if (e.wheelDelta) {
                      let D = e.wheelDelta * 600 / (e.wheelDelta + 600);
                      this.rotationGroup.position.z -= x * p * D / 400;
                    }
                    this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
                  }
                }
              }
              /**
               * Return image URI of viewer contents (base64 encoded).     *
               */
              pngURI() {
                return this.getCanvas().toDataURL("image/png");
              }
              /**
               * Return a promise that resolves to an animated PNG image URI of
               viewer contents (base64 encoded) for nframes of viewer changes.
               * @return {Promise}
               */
              apngURI(e) {
                let n = this;
                return e = e || 1, new Promise(function(a) {
                  let p = 0, x = n.viewChangeCallback, D = [], O = [], R = Date.now();
                  n.viewChangeCallback = function() {
                    O.push(Date.now() - R), R = Date.now(), D.push(new Promise((z) => {
                      n.getCanvas().toBlob(function(T) {
                        T.arrayBuffer().then(z);
                      }, "image/png");
                    })), p += 1, p == e && (n.viewChangeCallback = x, Promise.all(D).then((z) => {
                      let T = [];
                      for (let V = 0; V < z.length; V++) {
                        let H = (0, w.decode)(z[V]);
                        T.push((0, w.toRGBA8)(H)[0]);
                      }
                      let B = n.getCanvas().width, W = n.getCanvas().height, k = (0, w.encode)(T, B, W, 0, O), F = new Blob([k], { type: "image/png" }), U = new FileReader();
                      U.onload = function(V) {
                        a(V.target.result);
                      }, U.readAsDataURL(F);
                    }));
                  };
                });
              }
              /**
               * Return underlying canvas element.
               */
              getCanvas() {
                return this.glDOM;
              }
              /**
               * Return renderer element.
               */
              getRenderer() {
                return this.renderer;
              }
              /**
                   * Set the duration of the hover delay
                   *
                   * @param {number}
                   *            [hoverDuration] - an optional parameter that denotes
                   *            the duration of the hover delay (in milliseconds) before the hover action is called
                   *
               */
              setHoverDuration(e) {
                this.hoverDuration = e;
              }
              mouseXY(e, n) {
                let a = this.canvasOffset(), p = this.renderer.getXRatio(), x = this.renderer.getYRatio(), D = this.col, O = this.row, R = D * (this.WIDTH / p), z = (x - O - 1) * (this.HEIGHT / x), T = (e - a.left - R) / (this.WIDTH / p) * 2 - 1, B = -((n - a.top - z) / (this.HEIGHT / x)) * 2 + 1;
                return { x: T, y: B };
              }
              _handleMouseMove(e) {
                clearTimeout(this.hoverTimeout), e.preventDefault();
                let n = this.getX(e), a = this.getY(e);
                if (n === void 0)
                  return;
                let p = this.renderer.getXRatio(), x = this.renderer.getYRatio(), D = this.mouseXY(n, a), O = this;
                this.current_hover !== null && this.handleHoverContinue(D.x, D.y);
                var R = 0;
                if (!(!this.control_all && !this.isInViewer(n, a)) && this.scene && (this.hoverables.length > 0 && (this.hoverTimeout = setTimeout(function() {
                  O.handleHoverSelection(D.x, D.y, e);
                }, this.hoverDuration)), !!this.isDragging)) {
                  var z = (n - this.mouseStartX) / this.WIDTH, T = (a - this.mouseStartY) / this.HEIGHT;
                  if (this.touchDistanceStart != 0 && e.targetTouches && e.targetTouches.length == 2) {
                    var B = this.calcTouchDistance(e);
                    R = 2, T = (B - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);
                  } else
                    e.targetTouches && e.targetTouches.length == 3 && (R = 1);
                  z *= p, T *= x;
                  var W = Math.hypot(z, T), k;
                  if (R == 3 || this.mouseButton == 3 && e.ctrlKey)
                    this.slabNear = this.cslabNear + z * 100, this.slabFar = this.cslabFar - T * 100;
                  else if (R == 2 || this.mouseButton == 3 || e.shiftKey)
                    k = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, k < 80 && (k = 80), this.rotationGroup.position.z = this.cz + T * k, this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  else if (R == 1 || this.mouseButton == 2 || e.ctrlKey) {
                    var F = this.screenOffsetToModel(p * (n - this.mouseStartX), x * (a - this.mouseStartY));
                    this.modelGroup.position.addVectors(this.currentModelPos, F);
                  } else if ((R === 0 || this.mouseButton == 1) && W !== 0) {
                    var U = Math.sin(W * Math.PI) / W;
                    this.dq.x = Math.cos(W * Math.PI), this.dq.y = 0, this.dq.z = U * z, this.dq.w = -U * T, this.rotationGroup.quaternion.set(1, 0, 0, 0), this.rotationGroup.quaternion.multiply(this.dq), this.rotationGroup.quaternion.multiply(this.cq);
                  }
                  this.show();
                }
              }
              _handleContextMenu(e) {
                e.preventDefault();
                var n = this.getX(e), a = this.getY(e);
                if (!(n != this.mouseStartX || a != this.mouseStartY)) {
                  var D = this.mouseStartX, O = this.mouseStartY, x = this.canvasOffset();
                  let R = this.mouseXY(D, O), z = R.x, T = R.y, B = this.targetedObjects(z, T, this.contextMenuEnabledAtoms);
                  var p = null;
                  B.length && (p = B[0].clickable);
                  var x = this.canvasOffset(), D = this.mouseStartX - x.left, O = this.mouseStartY - x.top;
                  this.userContextMenuHandler && this.userContextMenuHandler(p, D, O, B);
                }
              }
              /**
              	     * Change the viewer's container element
              	     * Also useful if the original container element was removed from the DOM.
              	     *
              	     * @param {Object | string} element
              	     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.
              
              	     */
              setContainer(e) {
                let n = (0, A.getElement)(e) || this.container;
                return this.initContainer(n), this;
              }
              /**
              	     * Set the background color (default white)
              	     *
              	     * @param {number}
              	     *            hex Hexcode specified background color, or standard color spec
              	     * @param {number}
              	     *            a Alpha level (default 1.0)
              	     *
              	     * @example
              	     *
              	     * viewer.setBackgroundColor(0x000000);
              
              
              	     *
              	     */
              setBackgroundColor(e, n) {
                (typeof n > "u" || n < 0 || n > 1) && (n = 1);
                var a = E.CC.color(e);
                return this.scene.fog.color = a, this.bgColor = a.getHex(), this.renderer.setClearColorHex(a.getHex(), n), this.show(), this;
              }
              /**
              	     * Set view projection scheme.  Either orthographic or perspective.
              	     * Default is perspective.  Orthographic can also be enabled on viewer creation
              	     * by setting orthographic to true in the config object.
              	     *
              	     *
              	     * @example
              	     viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              	              });
              	              viewer.zoomTo();
              
              	              viewer.setProjection("orthographic");
              	              viewer.render(callback);
              	          });
              	     *
              	     */
              setProjection(e) {
                this.camera.ortho = e === "orthographic", this.setSlabAndFog();
              }
              /**
               * Set global view styles.
               *
               * @example
               *   viewer.setViewStyle({style:"outline"});
                    $3Dmol.get('data/1fas.pqr', function(data){
                        viewer.addModel(data, "pqr");
                        $3Dmol.get("data/1fas.cube",function(volumedata){
                            viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                        });
                        viewer.zoomTo();
                        viewer.render(callback);
                    });
               *
               */
              setViewStyle(e) {
                if (e.style === "outline") {
                  var n = {};
                  e.color && (n.color = E.CC.color(e.color)), e.width && (n.width = e.width), this.renderer.enableOutline(n);
                } else
                  this.renderer.disableOutline();
                return this;
              }
              updateSize() {
                this.renderer.setSize(this.WIDTH, this.HEIGHT), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.camera.aspect = this.ASPECT, this.camera.updateProjectionMatrix();
              }
              /**
               * Set viewer width independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} w Width in pixels
               */
              setWidth(e) {
                return this.WIDTH = e || this.WIDTH, this.updateSize(), this;
              }
              /**
               * Set viewer height independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} h Height in pixels
               */
              setHeight(e) {
                return this.HEIGHT = e || this.HEIGHT, this.updateSize(), this;
              }
              /**
               * Resize viewer according to containing HTML element's dimensions
               *
               */
              resize() {
                this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight();
                let e = !1;
                if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0 && (this.container.querySelector("canvas").remove(), this.setupRenderer(), this.initContainer(this.container), e = !0), this.WIDTH == 0 || this.HEIGHT == 0 ? this.animated && this._viewer.pauseAnimate() : this.animated && this._viewer.resumeAnimate(), this.updateSize(), e) {
                  let n = this.renderer.supportedExtensions();
                  n.regen = !0, this._viewer.render(null, n);
                } else
                  this.show();
                return this;
              }
              /**
               * Return specified model
               *
               * @param {number}
               *            [id=last model id] - Retrieve model with specified id
               * @default Returns last model added to viewer or null if there are no models
               * @return {GLModel}
               *
               * @example // Retrieve reference to first GLModel added var m =
               *    $3Dmol.download("pdb:1UBQ",viewer,{},function(m1){
                        $3Dmol.download("pdb:1UBI", viewer,{}, function(m2) {
                          viewer.zoomTo();
                          m1.setStyle({cartoon: {color:'green'}});
                          //could use m2 here as well
                          viewer.getModel().setStyle({cartoon: {color:'blue'}});
                          viewer.render();
                      })
                    });
               */
              getModel(e) {
                return e === void 0 ? this.models.length == 0 ? null : this.models[this.models.length - 1] : e instanceof g.GLModel ? e : e in this.models ? this.models[e] : this.models.length == 0 ? null : this.models[this.models.length - 1];
              }
              /**
               * Continuously rotate a scene around the specified axis.
               *
               * Call `spin(false)` to stop spinning.
               *
               * @param  {string|boolean|Array} axis
               *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
               *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
               * @param  {number} speed
               *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative
               *             value reverses the direction of the spin.
               *
               */
              spin(e, n = 1) {
                if (clearInterval(this.spinInterval), typeof e > "u" && (e = "y"), typeof e == "boolean")
                  if (e)
                    e = "y";
                  else
                    return;
                Array.isArray(e) && (e = { x: e[0], y: e[1], z: e[2] });
                var a = this;
                this.spinInterval = setInterval(function() {
                  !a.getCanvas().isConnected && a.renderer.isLost() && clearInterval(a.spinInterval), a.rotate(1 * n, e);
                }, 25);
              }
              //animate motion between current position and passed position
              // can set some parameters to null
              //if fixed is true will enforce the request animation, otherwise
              //does relative updates
              //positions objects have modelggroup position, rotation group position.z,
              //and rotationgroup quaternion
              //return array includes final position, but not current
              //the returned array includes an animate method
              animateMotion(e, n, a, p, x, D) {
                var O = 20, R = Math.ceil(e / O);
                R < 1 && (R = 1), this.incAnim();
                var z = {
                  mpos: this.modelGroup.position.clone(),
                  rz: this.rotationGroup.position.z,
                  rot: this.rotationGroup.quaternion.clone(),
                  cam: this.lookingAt.clone()
                };
                if (n) {
                  let W = new Array(R);
                  for (let V = 0; V < R; V++) {
                    let H = (V + 1) / R, G = { mpos: z.mpos, rz: z.rz, rot: z.rot };
                    G.mpos = a.clone().sub(z.mpos).multiplyScalar(H).add(z.mpos), G.rz = z.rz + H * (p - z.rz), G.rot = t.slerp(z.rot, x, H), G.cam = D.clone().sub(z.cam).multiplyScalar(H).add(z.cam), W[V] = G;
                  }
                  let k = 0, F = this, U = function() {
                    var V = W[k];
                    k += 1, F.modelGroup.position = V.mpos, F.rotationGroup.position.z = V.rz, F.rotationGroup.quaternion = V.rot, F.camera.lookAt(V.cam), k < W.length ? setTimeout(U, O) : F.decAnim(), F.show();
                  };
                  setTimeout(U, O);
                } else {
                  var T = {};
                  let W = 1 / R;
                  if (a && (T.mpos = a.clone().sub(z.mpos).multiplyScalar(W)), typeof p < "u" && p != null && (T.rz = W * (p - z.rz)), x) {
                    var B = t.slerp(z.rot, x, W);
                    T.rot = z.rot.clone().inverse().multiply(B);
                  }
                  D && (T.cam = D.clone().sub(z.cam).multiplyScalar(W));
                  let k = 0, F = this, U = function() {
                    k += 1, T.mpos && F.modelGroup.position.add(T.mpos), T.rz && (F.rotationGroup.position.z += T.rz), T.rot && F.rotationGroup.quaternion.multiply(T.rot), T.cam && (F.lookingAt.add(T.cam), F.camera.lookAt(F.lookingAt)), k < R ? setTimeout(U, O) : F.decAnim(), F.show();
                  };
                  setTimeout(U, O);
                }
              }
              /**
              	     * Rotate scene by angle degrees around axis
              	     *
              	     * @param {number}
              	     *            [angle] - Angle, in degrees, to rotate by.
              	     * @param {string}
              	     *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
              	     *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
              	     *            Axis can also be specified as a vector.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of the rotation animation. Default 0 (no animation)
              	     * @param {boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {
              	    viewer.setStyle({stick:{}});
              	    viewer.zoomTo();
              	    viewer.rotate(90,'y',1);
              	    viewer.render(callback);
              	    });
              
              	     *
              	     */
              rotate(e, n = "y", a = 0, p = !1) {
                if (n == "x" ? n = { x: 1, y: 0, z: 0 } : n == "y" ? n = { x: 0, y: 1, z: 0 } : n == "z" && (n = { x: 0, y: 0, z: 1 }), n == "vx" ? n = { vx: 1, vy: 0, vz: 0 } : n == "vy" ? n = { vx: 0, vy: 1, vz: 0 } : n == "vz" && (n = { vx: 0, vy: 0, vz: 1 }), typeof n.vx < "u") {
                  var x = new M.Vector3(n.vx, n.vy, n.vz);
                  x.applyQuaternion(this.rotationGroup.quaternion), n = { x: x.x, y: x.y, z: x.z };
                }
                var D = function(T) {
                  var B = Math.sin(T / 2), W = Math.cos(T / 2), k = 0, F = 0, U = 0;
                  return k = n.x * B, F = n.y * B, U = n.z * B, new M.Quaternion(k, F, U, W).normalize();
                }, O = Math.PI * e / 180, R = D(O);
                if (a) {
                  var z = new M.Quaternion().copy(this.rotationGroup.quaternion).multiply(R);
                  this.animateMotion(a, p, this.modelGroup.position, this.rotationGroup.position.z, z, this.lookingAt);
                } else
                  this.rotationGroup.quaternion.multiply(R), this.show();
                return this;
              }
              surfacesFinished() {
                for (var e in this.surfaces)
                  if (!this.surfaces[e][0].done)
                    return !1;
                return !0;
              }
              /** Returns an array representing the current viewpoint.
               * Translation, zoom, and rotation quaternion.
               * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]
               *  */
              getView() {
                if (!this.modelGroup)
                  return [0, 0, 0, 0, 0, 0, 0, 1];
                var e = this.modelGroup.position, n = this.rotationGroup.quaternion;
                return [
                  e.x,
                  e.y,
                  e.z,
                  this.rotationGroup.position.z,
                  n.x,
                  n.y,
                  n.z,
                  n.w
                ];
              }
              /** Sets the view to the specified translation, zoom, and rotation.
               *
               * @param {Array.<number>} arg Array formatted identically to the return value of getView */
              setView(e, n) {
                return e === void 0 || !(e instanceof Array || e.length !== 8) ? this : !this.modelGroup || !this.rotationGroup ? this : (this.modelGroup.position.x = e[0], this.modelGroup.position.y = e[1], this.modelGroup.position.z = e[2], this.rotationGroup.position.z = e[3], this.rotationGroup.quaternion.x = e[4], this.rotationGroup.quaternion.y = e[5], this.rotationGroup.quaternion.z = e[6], this.rotationGroup.quaternion.w = e[7], typeof e[8] < "u" && (this.rotationGroup.position.x = e[8], this.rotationGroup.position.y = e[9]), this.show(n), this);
              }
              // apply styles, models, etc in viewer
              /**
               * Render current state of viewer, after
               * adding/removing models, applying styles, etc.
               *
               */
              render(e, n) {
                this.renderer.setViewport(), this.updateClickables();
                var a = this.getView();
                this.stateChangeCallback && this.stateChangeCallback(this.getInternalState());
                var p, x;
                for (n || (n = this.renderer.supportedExtensions()), p = 0; p < this.models.length; p++)
                  this.models[p] && this.models[p].globj(this.modelGroup, n);
                for (p = 0; p < this.shapes.length; p++)
                  this.shapes[p] && (typeof this.shapes[p].frame > "u" || this.viewer_frame < 0 || this.shapes[p].frame < 0 || this.shapes[p].frame == this.viewer_frame ? this.shapes[p].globj(this.modelGroup, n) : this.shapes[p].removegl(this.modelGroup));
                for (p = 0; p < this.labels.length; p++)
                  this.labels[p] && typeof this.labels[p].frame < "u" && this.labels[p].frame >= 0 && (this.modelGroup.remove(this.labels[p].sprite), (this.viewer_frame < 0 || this.labels[p].frame == this.viewer_frame) && this.modelGroup.add(this.labels[p].sprite));
                for (p in this.surfaces)
                  if (this.surfaces.hasOwnProperty(p)) {
                    var D = this.surfaces[p];
                    for (x = 0; x < D.length; x++)
                      if (D.hasOwnProperty(x)) {
                        var O = D[x].geo;
                        if (!D[x].finished || n.regen) {
                          O.verticesNeedUpdate = !0, O.elementsNeedUpdate = !0, O.normalsNeedUpdate = !0, O.colorsNeedUpdate = !0, O.buffersNeedUpdate = !0, O.boundingSphere = null, D[x].done && (D[x].finished = !0), D[x].lastGL && this.modelGroup.remove(D[x].lastGL);
                          var R = null;
                          if (D[x].mat instanceof v.LineBasicMaterial ? R = new v.Line(O, D[x].mat) : R = new v.Mesh(O, D[x].mat), D[x].mat.transparent && D[x].mat.opacity == 0 ? R.visible = !1 : R.visible = !0, D[x].symmetries.length > 1 || D[x].symmetries.length == 1 && !D[x].symmetries[x].isIdentity()) {
                            var z, T = new v.Object3D();
                            for (z = 0; z < D[x].symmetries.length; z++) {
                              var B = R.clone();
                              B.matrix = D[x].symmetries[z], B.matrixAutoUpdate = !1, T.add(B);
                            }
                            D[x].lastGL = T, this.modelGroup.add(T);
                          } else
                            D[x].lastGL = R, this.modelGroup.add(R);
                        }
                      }
                  }
                return this.setView(a), typeof e == "function" && e(this), this;
              }
              /* @param {AtomSelectionSpec|any} sel
               * @return list of models specified by sel
               */
              getModelList(e) {
                let n = [];
                if (typeof e > "u" || typeof e.model > "u")
                  for (let p = 0; p < this.models.length; p++)
                    this.models[p] && n.push(this.models[p]);
                else {
                  let p = e.model;
                  Array.isArray(p) || (p = [p]);
                  for (let x = 0; x < p.length; x++)
                    if (typeof p[x] == "number") {
                      var a = p[x];
                      a < 0 && (a += this.models.length), n.push(this.models[a]);
                    } else
                      n.push(p[x]);
                }
                return n;
              }
              /**
               *
               * @param {AtomSelectionSpec}
               *            sel
               * @return {AtomSpec[]}
               */
              getAtomsFromSel(e) {
                var n = [];
                typeof e > "u" && (e = {});
                var a = this.getModelList(e);
                for (let p = 0; p < a.length; p++)
                  n = n.concat(a[p].selectedAtoms(e));
                return n;
              }
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSelectionSpec}
               *            sel
               * @return {boolean}
               */
              atomIsSelected(e, n) {
                typeof n > "u" && (n = {});
                for (var a = this.getModelList(n), p = 0; p < a.length; p++)
                  if (a[p].atomIsSelected(e, n))
                    return !0;
                return !1;
              }
              /** return list of atoms selected by sel
               *
               * @param {AtomSelectionSpec} sel
               * @return {AtomSpec[]}
               */
              selectedAtoms(e) {
                return this.getAtomsFromSel(e);
              }
              /**
              * Returns valid values for the specified attribute in the given selection
              * @param {string} attribute
              * @param {AtomSelectionSpec} sel
              * @return {Array.<Object>}
              *
              */
              getUniqueValues(e, n) {
                typeof n > "u" && (n = {});
                var a = this.getAtomsFromSel(n), p = {};
                for (var x in a)
                  if (a[x].hasOwnProperty(e)) {
                    var D = a[x][e];
                    p[D] = !0;
                  }
                return Object.keys(p);
              }
              /**
               * Return pdb output of selected atoms (if atoms from pdb input)
               *
               * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer
               * @return {string} PDB string of selected atoms
               */
              pdbData(e) {
                for (var n = this.getAtomsFromSel(e), a = "", p = 0, x = n.length; p < x; ++p)
                  a += n[p].pdbline + `
`;
                return a;
              }
              /**
              	     * Zoom current view by a constant factor
              	     *
              	     * @param {number}
              	     *            [factor] - Magnification factor. Values greater than 1
              	     *            will zoom in, less than one will zoom out. Default 2.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation
              	     * @example
              	    $3Dmol.get('data/4csv.pdb', function(data) {
              	    viewer.addModel(data,'pdb');
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo()
              	    viewer.zoom(2,1000);
              	    viewer.render();
              	    });
              
              	         */
              zoom(e = 2, n = 0, a = !1) {
                var p = (this.CAMERA_Z - this.rotationGroup.position.z) / e, x = this.CAMERA_Z - p;
                return n > 0 ? this.animateMotion(n, a, this.modelGroup.position, this.adjustZoomToLimits(x), this.rotationGroup.quaternion, this.lookingAt) : (this.rotationGroup.position.z = this.adjustZoomToLimits(x), this.show()), this;
              }
              /**
               * Translate current view by x,y screen coordinates
               * This pans the camera rather than translating the model.
               *
               * @param {number} x Relative change in view coordinates of camera
               * @param {number} y Relative change in view coordinates of camera
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translate(200,50);
              viewer.rotate(90,'z');
              viewer.render(callback);
              });
               */
              translate(e, n, a = 0, p = !1) {
                var x = e / this.WIDTH, D = n / this.HEIGHT, O = new M.Vector3(0, 0, -this.CAMERA_Z);
                this.projector.projectVector(O, this.camera), O.x -= x, O.y -= D, this.projector.unprojectVector(O, this.camera), O.z = 0;
                var R = this.lookingAt.clone().add(O);
                return a > 0 ? this.animateMotion(a, p, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, R) : (this.lookingAt = R, this.camera.lookAt(this.lookingAt), this.show()), this;
              }
              /**
               * Translate current models by x,y screen coordinates
               * This translates the models relative to the current view. It does
               * not change the center of rotation.
               *
               * @param {number} x Relative change in x screen coordinate
               * @param {number} y Relative change in y screen coordinate
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translateScene(200,50);
              viewer.rotate(90,'z'); // will no longer be around model center
              viewer.render(callback);
              });
               */
              translateScene(e, n, a = 0, p = !1) {
                var x = this.screenOffsetToModel(e, n), D = this.modelGroup.position.clone().add(x);
                return a > 0 ? this.animateMotion(a, p, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = D, this.show()), this;
              }
              /**
               * Adjust slab to fully enclose selection (default everything).
               *
               * @param {AtomSelectionSpec} sel
               *            Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               */
              fitSlab(e) {
                e = e || {};
                var n = this.getAtomsFromSel(e), a = (0, A.getExtent)(n), p = a[1][0] - a[0][0], x = a[1][1] - a[0][1], D = a[1][2] - a[0][2], O = Math.hypot(p, x, D);
                return O < 5 && (O = 5), this.slabNear = -O / 1.9, this.slabFar = O / 2, this;
              }
              /**
               * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).
               *
               * @param {AtomSelectionSpec}
               *            [sel] - Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example // if the user were to pass the animationDuration value to
               *           // the function like so viewer.zoomTo({resn:'STI'},1000);
               *         //   the program would center on resn 'STI' over the course
               *         //   of 1 second(1000 milleseconds).
               *  // Reposition to centroid of all atoms of all models in this
               * //viewer glviewer.center();
              $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.center();
              viewer.render(callback);
              });
               */
              center(e = {}, n = 0, a = !1) {
                var p, x, D = this.getAtomsFromSel(e), O = (0, A.getExtent)(D);
                (0, A.isEmptyObject)(e) ? (this.shapes.forEach((H) => {
                  if (H && H.boundingSphere && H.boundingSphere.center) {
                    var G = H.boundingSphere.center, Y = H.boundingSphere.radius;
                    Y > 0 ? (D.push(new M.Vector3(G.x + Y, G.y, G.z)), D.push(new M.Vector3(G.x - Y, G.y, G.z)), D.push(new M.Vector3(G.x, G.y + Y, G.z)), D.push(new M.Vector3(G.x, G.y - Y, G.z)), D.push(new M.Vector3(G.x, G.y, G.z + Y)), D.push(new M.Vector3(G.x, G.y, G.z - Y))) : D.push(G);
                  }
                }), O = (0, A.getExtent)(D), p = D, x = O) : (p = this.getAtomsFromSel({}), x = (0, A.getExtent)(p));
                var R = new M.Vector3(O[2][0], O[2][1], O[2][2]), z = x[1][0] - x[0][0], T = x[1][1] - x[0][1], B = x[1][2] - x[0][2], W = Math.hypot(z, T, B);
                W < 5 && (W = 5), this.slabNear = -W / 1.9, this.slabFar = W / 2, z = O[1][0] - O[0][0], T = O[1][1] - O[0][1], B = O[1][2] - O[0][2], W = Math.hypot(z, T, B), W < 5 && (W = 5);
                for (var k = 25, F = 0; F < D.length; F++)
                  if (D[F]) {
                    var U = R.distanceToSquared(D[F]);
                    U > k && (k = U);
                  }
                W = Math.sqrt(k) * 2;
                var V = R.clone().multiplyScalar(-1);
                return n > 0 ? this.animateMotion(n, a, V, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = V, this.show()), this;
              }
              /**
              	     * Zoom to center of atom selection.  The slab will be set appropriately for
              	     * the selection, unless an empty selection is provided, in which case there will be no slab.
              	     *
              	     * @param {Object}
              	     *            [sel] - Selection specification specifying model and atom
              	     *            properties to select. Default: all atoms in viewer
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	      * @example
              
              
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {
              	                      opacity:0.85,
              	                      voldata: new $3Dmol.VolumeData(volumedata, "cube"),
              	                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))
              	                  },{});
              
              	              viewer.render();
              	              });
              	              viewer.zoomTo();
              	            });
              	     */
              zoomTo(e = {}, n = 0, a = !1) {
                let p = this.getAtomsFromSel(e), x = (0, A.getExtent)(p), D = x;
                if ((0, A.isEmptyObject)(e)) {
                  let G = p && p.length;
                  if (this.shapes.forEach((Y) => {
                    if (Y && Y.boundingSphere) {
                      if (Y.boundingSphere.box) {
                        let le = Y.boundingSphere.box;
                        p.push(new M.Vector3(le.min.x, le.min.y, le.min.z)), p.push(new M.Vector3(le.max.x, le.max.y, le.max.z));
                      } else if (Y.boundingSphere.center) {
                        var J = Y.boundingSphere.center, re = Y.boundingSphere.radius;
                        re > 0 ? (p.push(new M.Vector3(J.x + re, J.y, J.z)), p.push(new M.Vector3(J.x - re, J.y, J.z)), p.push(new M.Vector3(J.x, J.y + re, J.z)), p.push(new M.Vector3(J.x, J.y - re, J.z)), p.push(new M.Vector3(J.x, J.y, J.z + re)), p.push(new M.Vector3(J.x, J.y, J.z - re))) : p.push(J);
                      }
                    }
                  }), D = (0, A.getExtent)(p), !G)
                    for (let Y = 0; Y < 3; Y++)
                      x[2][Y] = (D[0][Y] + D[1][Y]) / 2;
                } else {
                  let G = this.getAtomsFromSel({});
                  D = (0, A.getExtent)(G);
                }
                var O = new M.Vector3(x[2][0], x[2][1], x[2][2]), R = D[1][0] - D[0][0], z = D[1][1] - D[0][1], T = D[1][2] - D[0][2], B = Math.hypot(R, z, T);
                B < 5 && (B = 5), this.slabNear = -B / 1.9, this.slabFar = B / 2, Object.keys(e).length === 0 && (this.slabNear = Math.min(-B * 2, -50), this.slabFar = Math.max(B * 2, 50));
                var W = this.config.minimumZoomToDistance || 5;
                R = x[1][0] - x[0][0], z = x[1][1] - x[0][1], T = x[1][2] - x[0][2], B = Math.hypot(R, z, T), B < W && (B = W);
                for (var k = W * W, F = 0; F < p.length; F++)
                  if (p[F]) {
                    var U = O.distanceToSquared(p[F]);
                    U > k && (k = U);
                  }
                B = Math.sqrt(k) * 2;
                var V = O.clone().multiplyScalar(-1), H = -(B * 0.5 / Math.tan(Math.PI / 180 * this.camera.fov / 2) - this.CAMERA_Z);
                return H = this.adjustZoomToLimits(H), n > 0 ? this.animateMotion(n, a, V, H, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = V, this.rotationGroup.position.z = H, this.show()), this;
              }
              /**
               * Set slab of view (contents outside of slab are clipped).
               * Must call render to update.
               *
               * @param {number} near near clipping plane distance
               * @param {number} far far clipping plane distance
               */
              setSlab(e, n) {
                this.slabNear = e, this.slabFar = n;
              }
              /**
               * Get slab of view (contents outside of slab are clipped).
               *
               * @return {Object}
               *      @property {number} near - near clipping plane distance
               *      @property {number} far - far clipping plane distance
               */
              getSlab() {
                return { near: this.slabNear, far: this.slabFar };
              }
              /**
              	     * Add label to viewer
              	     *
              	     * @param {string}
              	     *            text - Label text
              	     * @param {LabelSpec}
              	     *            options - Label style specification
              	      @param {AtomSelection}
              	     *            sel - Set position of label to center of this selection
              	     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient
              	     * @return {Label}
              	     *
              	     * @example
              	     *  $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              
              	              viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.setStyle({chain:'A'},{cross:{hidden:true}});
              	              viewer.setStyle({chain:'B'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  radius:0.5}});
              	              viewer.setStyle({chain:'D'},{cross:{hidden:false,
              	                                                  linewidth:10.0}});
              	              viewer.setStyle({chain:'E'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  color:'black'}});
              
              	              viewer.render();
              
              
              	            });
              
              	     */
              addLabel(e, n = {}, a, p = !1) {
                if (a) {
                  var x = (0, A.getExtent)(this.getAtomsFromSel(a));
                  n.position = { x: x[2][0], y: x[2][1], z: x[2][2] };
                }
                var D = new C.Label(e, n);
                return D.setContext(), this.modelGroup.add(D.sprite), this.labels.push(D), p || this.show(), D;
              }
              /** Add residue labels.  This will generate one label per a
               * residue within the selected atoms.  The label will be at the
               * centroid of the atoms and styled according to the passed style.
               * The label text will be [resn][resi]
               *
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current
               *
               * @example
                   $3Dmol.download("mmtf:2ll5",viewer,{},function(){
                        viewer.setStyle({stick:{radius:0.15},cartoon:{}});
                        viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addResLabels(e, n, a = !1) {
                let p = this.labels.length;
                return this.applyToModels("addResLabels", e, this, n, a), this.show(), this.labels.slice(p);
              }
              /** Add property labels.  This will generate one label per a selected
               * atom at the atom's coordinates with the property value as the label text.
               *
               * @param {string} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               *
               * * @example
                   $3Dmol.download("cid:5291",viewer,{},function(){
                        viewer.setStyle({stick: {radius:.2}});
                        viewer.addPropertyLabels("index",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addPropertyLabels(e, n, a) {
                return this.applyToModels("addPropertyLabels", e, n, this, a), this.show(), this;
              }
              /**
              	     * Remove label from viewer
              	     *
              	     * @param {Label} label - $3Dmol label
              	     *
              	     * @example // Remove labels created in
              	     $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              	              var toremove = viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.removeLabel(toremove);
              	              viewer.render();
              
              
              	            });
              
              	     */
              removeLabel(e) {
                for (var n = 0; n < this.labels.length; n++)
                  if (this.labels[n] == e) {
                    this.labels.splice(n, 1), e.dispose(), this.modelGroup.remove(e.sprite);
                    break;
                  }
                return this.show(), this;
              }
              /**
              	     * Remove all labels from viewer
              	     *
              	     *         @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.addResLabels();
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render( ); //show labels
              
              	           viewer.removeAllLabels();
              	           viewer.render(); //hide labels
              	    });
              	     */
              removeAllLabels() {
                for (var e = 0; e < this.labels.length; e++)
                  this.labels[e] && this.labels[e].sprite && this.modelGroup.remove(this.labels[e].sprite);
                return this.labels.splice(0, this.labels.length), this.show(), this;
              }
              // Modify label style
              /**
               * Modify existing label's style
               *
               * @param {Label} label - $3Dmol label
               * @param {LabelSpec}
               *            stylespec - Label style specification
               * @return {Label}
               */
              setLabelStyle(e, n) {
                return this.modelGroup.remove(e.sprite), e.dispose(), e.stylespec = n, e.setContext(), this.modelGroup.add(e.sprite), this.show(), e;
              }
              // Change label text
              /**
               * Modify existing label's text
               *
               * @param {Label}  label - $3Dmol label
               * @param {String}
               *            text - Label text
               * @return {Label}
               */
              setLabelText(e, n) {
                return this.modelGroup.remove(e.sprite), e.dispose(), e.text = n, e.setContext(), this.modelGroup.add(e.sprite), this.show(), e;
              }
              /**
               * Add shape object to viewer
               * @see {GLShape}
               *
               * @param {ShapeSpec} shapeSpec - style specification for label
               * @return {GLShape}
               */
              addShape(e) {
                e = e || {};
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, this.shapes.push(n), n;
              }
              /**
               * Remove shape object from viewer
               *
               * @param {GLShape} shape - Reference to shape object to remove
               */
              removeShape(e) {
                if (!e)
                  return this;
                for (e.removegl(this.modelGroup), delete this.shapes[e.shapePosition]; this.shapes.length > 0 && typeof this.shapes[this.shapes.length - 1] > "u"; )
                  this.shapes.pop();
                return this;
              }
              /**
               * Remove all shape objects from viewer
               */
              removeAllShapes() {
                for (var e = 0; e < this.shapes.length; e++) {
                  var n = this.shapes[e];
                  n && n.removegl(this.modelGroup);
                }
                return this.shapes.splice(0, this.shapes.length), this;
              }
              //gets the center of the selection
              getSelectionCenter(e) {
                if (e.hasOwnProperty("x") && e.hasOwnProperty("y") && e.hasOwnProperty("z"))
                  return e;
                var n = this.getAtomsFromSel(e);
                if (n.length == 0)
                  return { x: 0, y: 0, z: 0 };
                var a = (0, A.getExtent)(n);
                return { x: a[0][0] + (a[1][0] - a[0][0]) / 2, y: a[0][1] + (a[1][1] - a[0][1]) / 2, z: a[0][2] + (a[1][2] - a[0][2]) / 2 };
              }
              /**
              	     * Create and add sphere shape. This method provides a shorthand
              	     * way to create a spherical shape object
              	     *
              	     * @param {SphereShapeSpec} spec - Sphere shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
              
              	     viewer.render();
              	     */
              addSphere(e) {
                e = e || {}, e.center = this.getSelectionCenter(e.center);
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, n.addSphere(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add box shape. This method provides a shorthand
              	     * way to create a box shape object
              	     *
              	     * @param {BoxSpec} spec - Box shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});
              	     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});
              	     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});
              
              	     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});
              	     viewer.zoomTo();
              	     viewer.rotate(45, {x:1,y:1,z:1});
              	     viewer.render();
              	     */
              addBox(e = {}) {
                e.corner != null && (e.corner = this.getSelectionCenter(e.corner)), e.center != null && (e.center = this.getSelectionCenter(e.center));
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, n.addBox(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add arrow shape
              	     *
              	     * @param {ArrowSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	    $3Dmol.download("pdb:4DM7",viewer,{},function(){
              
              	              viewer.setBackgroundColor(0xffffffff);
              	              viewer.addArrow({
              	                  start: {x:-10.0, y:0.0, z:0.0},
              	                  end: {x:0.0, y:-10.0, z:0.0},
              	                  radius: 1.0,
              	                  radiusRadio:1.0,
              	                  mid:1.0,
              	                  clickable:true,
              	                  callback:function(){
              	                      this.color.setHex(0xFF0000FF);
              	                      viewer.render( );
              	                  }
              	              });
              	              viewer.render();
              	            });
              	     */
              addArrow(e = {}) {
                e.start = this.getSelectionCenter(e.start), e.end = this.getSelectionCenter(e.end);
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, n.addArrow(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add cylinder shape
              	     *
              	     * @param {CylinderSpec} spec - Style specification
              	     * @return {GLShape}
              
              	      @example
              	     viewer.setBackgroundColor(0xffffffff);
              	          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
              	                              end:{x:10.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              fromCap:1,
              	                              toCap:2,
              	                              color:'red',
              	                              hoverable:true,
              	                              clickable:true,
              	                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
              	                              hover_callback: function(){ viewer.render( );},
              	                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
              	                             });
              	          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
              	                              end:{x:0.0,y:10.0,z:0.0},
              	                              radius:0.5,
              	                              fromCap:false,
              	                              toCap:true,
              	                              color:'teal'});
              	          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
              	                              end:{x:20.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              color:'black',
              	                              fromCap:false,
              	                              toCap:false});
              	          viewer.render();
              	     */
              addCylinder(e = {}) {
                e.start = this.getSelectionCenter(e.start), e.end = this.getSelectionCenter(e.end);
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, e.dashed ? n.addDashedCylinder(e) : n.addCylinder(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add Curve shape
              	     *
              	     * @param {CurveSpec} spec - Style specification
              	     * @return {GLShape}
              
              	     @example
              	          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],
              	                              radius:0.5,
              	                              smooth: 10,
              	                              fromArrow:false,
              	                              toArrow: true,
              	                              color:'orange',
              	                              });
              	          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],
              	                              radius:1,
              	                              fromArrow:true,
              	                              toArrow: false,
              	                              color:'purple',
              	                              });
              	          viewer.zoomTo();
              	          viewer.render();
              	     */
              addCurve(e = {}) {
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, n.addCurve(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add line shape
              	     *
              	     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength
              	     * @return {GLShape}
              	     @example
              	     $3Dmol.download("pdb:2ABJ",viewer,{},function(){
              
              	              viewer.setViewStyle({style:"outline"});
              	              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});
              	              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});
              	              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});
              	              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
              	              viewer.render();
              	          });
              
              	     */
              addLine(e = {}) {
                e.start = this.getSelectionCenter(e.start), e.end = this.getSelectionCenter(e.end), e.wireframe = !0;
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, e.dashed ? n = this.addLineDashed(e, n) : n.addLine(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Create and add unit cell visualization.
              	     *
              	     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              	     * @param {UnitCellStyleSpec} spec - visualization style
              	       @example
              
              	            $3Dmol.get('data/1jpy.cif', function(data) {
              	              let m = viewer.addModel(data);
              	              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});
              	              viewer.zoomTo();
              	              viewer.render();
              	    });
              	     */
              addUnitCell(e, n) {
                e = this.getModel(e), n = n || { alabel: "a", blabel: "b", clabel: "c" }, n.box = n.box || {}, n.astyle = n.astyle || { color: "red", radius: 0.1, midpos: -1 }, n.bstyle = n.bstyle || { color: "green", radius: 0.1, midpos: -1 }, n.cstyle = n.cstyle || { color: "blue", radius: 0.1, midpos: -1 }, n.alabelstyle = n.alabelstyle || { fontColor: "red", showBackground: !1, alignment: "center", inFront: !1 }, n.blabelstyle = n.blabelstyle || { fontColor: "green", showBackground: !1, alignment: "center", inFront: !1 }, n.clabelstyle = n.clabelstyle || { fontColor: "blue", showBackground: !1, alignment: "center", inFront: !1 }, e.unitCellObjects && this.removeUnitCell(e), e.unitCellObjects = { shapes: [], labels: [] };
                var a = e.getCrystData(), p = null;
                if (a) {
                  if (a.matrix)
                    p = a.matrix;
                  else {
                    var x = a.a, D = a.b, O = a.c, R = a.alpha, z = a.beta, T = a.gamma;
                    R = R * Math.PI / 180, z = z * Math.PI / 180, T = T * Math.PI / 180;
                    var B, W, k;
                    B = Math.cos(z), W = (Math.cos(R) - Math.cos(z) * Math.cos(T)) / Math.sin(T), k = Math.sqrt(Math.max(0, 1 - B * B - W * W)), p = new M.Matrix3(x, D * Math.cos(T), O * B, 0, D * Math.sin(T), O * W, 0, 0, O * k);
                  }
                  var F = [
                    new M.Vector3(0, 0, 0),
                    new M.Vector3(1, 0, 0),
                    new M.Vector3(0, 1, 0),
                    new M.Vector3(0, 0, 1),
                    new M.Vector3(1, 1, 0),
                    new M.Vector3(0, 1, 1),
                    new M.Vector3(1, 0, 1),
                    new M.Vector3(1, 1, 1)
                  ];
                  if (a.matrix4)
                    for (let V = 0; V < F.length; V++)
                      a.size && F[V].multiplyVectors(F[V], a.size), F[V] = F[V].applyMatrix4(a.matrix4);
                  else
                    for (let V = 0; V < F.length; V++)
                      F[V] = F[V].applyMatrix3(p);
                  if (n.box && !n.box.hidden) {
                    n.box.wireframe = !0;
                    var U = new c.GLShape(n.box);
                    U.shapePosition = this.shapes.length, U.addLine({ start: F[0], end: F[1] }), U.addLine({ start: F[0], end: F[2] }), U.addLine({ start: F[1], end: F[4] }), U.addLine({ start: F[2], end: F[4] }), U.addLine({ start: F[0], end: F[3] }), U.addLine({ start: F[3], end: F[5] }), U.addLine({ start: F[2], end: F[5] }), U.addLine({ start: F[1], end: F[6] }), U.addLine({ start: F[4], end: F[7] }), U.addLine({ start: F[6], end: F[7] }), U.addLine({ start: F[3], end: F[6] }), U.addLine({ start: F[5], end: F[7] }), this.shapes.push(U), e.unitCellObjects.shapes.push(U), U.finalize();
                  }
                  if (!n.astyle.hidden) {
                    n.astyle.start = F[0], n.astyle.end = F[1];
                    let V = this.addArrow(n.astyle);
                    e.unitCellObjects.shapes.push(V);
                  }
                  if (!n.bstyle.hidden) {
                    n.bstyle.start = F[0], n.bstyle.end = F[2];
                    let V = this.addArrow(n.bstyle);
                    e.unitCellObjects.shapes.push(V);
                  }
                  if (!n.cstyle.hidden) {
                    n.cstyle.start = F[0], n.cstyle.end = F[3];
                    let V = this.addArrow(n.cstyle);
                    e.unitCellObjects.shapes.push(V);
                  }
                  if (n.alabel) {
                    n.alabelstyle.position = F[1];
                    let V = this.addLabel(n.alabel, n.alabelstyle);
                    e.unitCellObjects.labels.push(V);
                  }
                  if (n.blabel) {
                    n.blabelstyle.position = F[2];
                    let V = this.addLabel(n.blabel, n.blabelstyle);
                    e.unitCellObjects.labels.push(V);
                  }
                  if (n.clabel) {
                    n.clabelstyle.position = F[3];
                    let V = this.addLabel(n.clabel, n.clabelstyle);
                    e.unitCellObjects.labels.push(V);
                  }
                }
              }
              /**
              * Remove unit cell visualization from model.
              *
              * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.removeUnitCell();
                       viewer.render();
                 });
              */
              removeUnitCell(e) {
                if (e = this.getModel(e), e.unitCellObjects) {
                  let n = this;
                  e.unitCellObjects.shapes.forEach(function(a) {
                    n.removeShape(a);
                  }), e.unitCellObjects.labels.forEach(function(a) {
                    n.removeLabel(a);
                  });
                }
                delete e.unitCellObjects;
              }
              /**
              * Replicate atoms in model to form a super cell of the specified dimensions.
              * Original cell will be centered as much as possible.
              *
              * @param {integer} A - number of times to replicate cell in X dimension.
              * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.
              * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.
              * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              * @param {boolean} addBonds - Create bonds between unit cells based on distances.
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{scale:.25}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.replicateUnitCell(3,2,1,m);
                       viewer.render();
                 });
              */
              replicateUnitCell(e = 3, n = e, a = n, p, x) {
                p = this.getModel(p);
                let D = p.getCrystData();
                if (D) {
                  const O = p.selectedAtoms({}), R = D.matrix;
                  let z = function(T) {
                    return T % 2 == 0 ? -T / 2 : Math.ceil(T / 2);
                  };
                  for (let T = 0; T < e; T++)
                    for (let B = 0; B < n; B++)
                      for (let W = 0; W < a; W++) {
                        if (T == 0 && B == 0 && W == 0)
                          continue;
                        let k = new M.Vector3(z(T), z(B), z(W));
                        k.applyMatrix3(R);
                        let F = [];
                        for (let U = 0; U < O.length; U++) {
                          let V = {};
                          for (let H in O[U])
                            V[H] = O[U][H];
                          V.x += k.x, V.y += k.y, V.z += k.z, F.push(V);
                        }
                        p.addAtoms(F);
                      }
                  x && p.assignBonds();
                }
              }
              /** Add dashed line to shape */
              addLineDashed(e, n) {
                e.dashLength = e.dashLength || 0.5, e.gapLength = e.gapLength || 0.5;
                var a;
                e.start ? a = new M.Vector3(e.start.x || 0, e.start.y || 0, e.start.z || 0) : a = new M.Vector3(0, 0, 0);
                var p;
                e.end ? p = new M.Vector3(e.end.x, e.end.y || 0, e.end.z || 0) : p = new M.Vector3(0, 0, 0);
                var x = new M.Vector3(), D = new M.Vector3(), O = new M.Vector3(), R, z, T, B = a.clone(), W = 0;
                for (x.subVectors(p, a), R = x.length(), x.normalize(), D = x.clone(), O = x.clone(), D.multiplyScalar(e.dashLength), O.multiplyScalar(e.gapLength), z = D.length(), T = O.length(); W < R; ) {
                  if (W + z > R) {
                    e.start = a, e.end = p, n.addLine(e);
                    break;
                  }
                  B.addVectors(a, D), e.start = a, e.end = B, n.addLine(e), a = B.clone(), W += z, B.addVectors(a, O), a = B.clone(), W += T;
                }
                return n.finalize(), n;
              }
              /**
              	     * Add custom shape component from user supplied function
              	     *
              	     * @param {CustomSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	     function triangle(viewer) {
              	        var vertices = [];
              	        var normals = [];
              	        var colors = [];
              	        var r = 20;
              	        //triangle
              	        vertices.push(new $3Dmol.Vector3(0,0,0));
              	        vertices.push(new $3Dmol.Vector3(r,0,0));
              	        vertices.push(new $3Dmol.Vector3(0,r,0));
              
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              
              	        colors.push({r:1,g:0,b:0});
              	        colors.push({r:0,g:1,b:0});
              	        colors.push({r:0,g:0,b:1});
              
              	        var faces = [ 0,1,2 ];
              
              	        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};
              	        viewer.addCustom(spec);
              	    }
              	    triangle(viewer);
              	    viewer.render();
              	     */
              addCustom(e) {
                e = e || {};
                var n = new c.GLShape(e);
                return n.shapePosition = this.shapes.length, n.addCustom(e), this.shapes.push(n), n.finalize(), n;
              }
              /**
              	     * Construct isosurface from volumetric data in gaussian cube format
              	     * @param {String} data - Input file contents
              	     * @param {String} format - Input file format
              	     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification
              	     * @return {GLShape}
              	     *
              	     * @example
              
              
              	    $3Dmol.get('data/bohr.cube', function(data) {
              
              	    viewer.addVolumetricData(data, "cube", {isoval: -0.01, color: "red", opacity: 0.95});
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo();
              	    viewer.render();
              	    });
              
              
              	     */
              addVolumetricData(e, n, a = {}) {
                var p = new S.VolumeData(e, n);
                return a.hasOwnProperty("transferfn") ? this.addVolumetricRender(p, a) : this.addIsosurface(p, a);
              }
              /**
               * Construct isosurface from volumetric data.  This is more flexible
              * than addVolumetricData, but can not be used with py3Dmol.
               * @param {VolumeData} data - volumetric data
               * @param {IsoSurfaceSpec} spec - Shape style specification
               * @return {GLShape}
               *
               @example
               $3Dmol.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue"});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red"});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(e, n = {}, a) {
                var p = new c.GLShape(n);
                return p.shapePosition = this.shapes.length, p.addIsosurface(e, n, a), this.shapes.push(p), p;
              }
              /**
               * Create volumetric renderer for volumetricData
               * @param {VolumeData} data - volumetric data
               * @param {VolumetricRenderSpec} spec - specification of volumetric render
               *
               * @return {GLShape}
               *
               */
              addVolumetricRender(e, n) {
                n = n || {};
                var a = new b.GLVolumetricRender(e, n);
                return a.shapePosition = this.shapes.length, this.shapes.push(a), a;
              }
              /**
               * Return true if volumetric rendering is supported (WebGL 2.0 required)
               *
               * @return {boolean}
               */
              hasVolumetricRender() {
                return this.renderer.supportsVolumetric();
              }
              /**
               * Enable/disable fog for content far from the camera
               *
               * @param {boolean} fog whether to enable or disable the fog
               */
              enableFog(e) {
                e ? this.scene.fog = new v.Fog(this.bgColor, 100, 200) : (this.config.disableFog = !0, this.show());
              }
              /**
               * Sets the atomlists of all models in the viewer to specified frame.
               * Shapes and labels can also be displayed by frame.
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - fame index to use, starts at zero
               * @return {Promise}
               */
              setFrame(e) {
                this.viewer_frame = e;
                let n = this;
                return new Promise(function(a) {
                  var p = n.models.map(function(x) {
                    return x.setFrame(e, n);
                  });
                  Promise.all(p).then(function() {
                    a();
                  });
                });
              }
              /**
               * Gets the current viewer frame.
               *
               */
              getFrame() {
                return this.viewer_frame;
              }
              /**
               * Returns the number of frames that the model with the most frames in the viewer has
               *
               * @return {number}
               */
              getNumFrames() {
                var e = 0;
                for (let n = 0; n < this.models.length; n++)
                  this.models[n].getNumFrames() > e && (e = this.models[n].getNumFrames());
                for (let n = 0; n < this.shapes.length; n++)
                  this.shapes[n].frame && this.shapes[n].frame >= e && (e = this.shapes[n].frame + 1);
                for (let n = 0; n < this.labels.length; n++)
                  this.labels[n].frame && this.labels[n].frame >= e && (e = this.labels[n].frame + 1);
                return e;
              }
              /**
               * Animate all models in viewer from their respective frames
               * @param {Object} options - can specify interval (speed of animation), loop (direction
               * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)
               *
               */
              animate(e) {
                this.incAnim();
                var n = 100, a = "forward", p = 0;
                e = e || {}, e.interval && (n = e.interval), e.loop && (a = e.loop), e.reps && (p = e.reps);
                var x = this.getNumFrames(), D = this, O = 0;
                e.startFrame && (O = e.startFrame % x);
                var R = 1;
                e.step && (R = e.step, p /= R);
                var z = 0, T = x * p, B = /* @__PURE__ */ new Date(), W, k, F = function(U) {
                  B = /* @__PURE__ */ new Date(), U == "forward" ? D.setFrame(O).then(function() {
                    O = (O + R) % x, W();
                  }) : U == "backward" ? D.setFrame(x - 1 - O).then(function() {
                    O = (O + R) % x, W();
                  }) : D.setFrame(O).then(function() {
                    O += R, R *= O % (x - 1) == 0 ? -1 : 1, W();
                  });
                };
                return W = function() {
                  if (D.render(), !D.getCanvas().isConnected)
                    D.stopAnimate();
                  else if (++z == T || !D.isAnimated())
                    k.cancel(), D.animationTimers.delete(k), D.decAnim();
                  else {
                    var U = n - ((/* @__PURE__ */ new Date()).getTime() - B.getTime());
                    U = U > 0 ? U : 0, D.animationTimers.delete(k), k = new A.PausableTimer(F, U, a), D.animationTimers.add(k);
                  }
                }, k = new A.PausableTimer(F, 0, a), this.animationTimers.add(k), this;
              }
              /**
               * Stop animation of all models in viewer
               */
              stopAnimate() {
                return this.animated = 0, this.animationTimers.forEach(function(e) {
                  e.cancel();
                }), this.animationTimers = /* @__PURE__ */ new Set(), this;
              }
              /**
               * Pause animation of all models in viewer
               */
              pauseAnimate() {
                return this.animationTimers.forEach(function(e) {
                  e.pause();
                }), this;
              }
              /**
               * Resume animation of all models in viewer
               */
              resumeAnimate() {
                return this.animationTimers.forEach(function(e) {
                  e.resume();
                }), this;
              }
              /**
               * Return true if viewer is currently being animated, false otherwise
               * @return {boolean}
               */
              isAnimated() {
                return this.animated > 0;
              }
              /**
              	     * Create and add model to viewer, given molecular data and its format
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')
              	     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.
              	     * @example
              
              
              	          viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              
              	              viewer.render();
              	              });
              	              viewer.zoomTo();
              	          });
              	     *
              	     * @return {GLModel}
              	     */
              addModel(e, n = "", a) {
                a && !a.defaultcolors ? (a.defaultcolors = this.defaultcolors, a.cartoonQuality = a.cartoonQuality || this.config.cartoonQuality) : typeof a > "u" && (a = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality });
                var p = new g.GLModel(this.models.length, a);
                return p.addMolData(e, n, a), this.models.push(p), p;
              }
              /**
               * Given multimodel file and its format, add atom data to the viewer as separate models
               * and return list of these models
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {Array<GLModel>}
               */
              addModels(e, n, a) {
                a = a || {}, a.multimodel = !0, a.frames = !0;
                for (var p = g.GLModel.parseMolData(e, n, a), x = 0; x < p.length; x++) {
                  var D = new g.GLModel(this.models.length, this.defaultcolors);
                  D.setAtomDefaults(p[x]), D.addFrame(p[x]), D.setFrame(0), p.modelData && D.setModelData(p.modelData[x]), D.setDontDuplicateAtoms(!a.duplicateAssemblyAtoms), this.models.push(D);
                }
                return this.models;
              }
              /**
               * Create and add model to viewer. Given multimodel file and its format,
               * different atomlists are stored in model's frame
               * property and model's atoms are set to the 0th frame
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {GLModel}
               *
               * @example
                      $3Dmol.get('../test_structs/multiple2.xyz', function(data){
                        viewer.addModelsAsFrames(data, "xyz");
                        viewer.animate({loop: "forward",reps: 1});
                        viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});
                        viewer.zoomTo();
                        viewer.render();
                    });
               */
              addModelsAsFrames(e, n, a) {
                a = a || {}, a.multimodel = !0, a.frames = !0;
                var p = new g.GLModel(this.models.length, this.defaultcolors);
                return p.addMolData(e, n, a), this.models.push(p), p;
              }
              /**
              	     * Create and add model to viewer. Given multimodel file and its format,
              	     * all atoms are added to one model
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format (see {@link FileFormats})
              	     * @return {GLModel}
              	     @example
              
              
              	          $3Dmol.get('../test_structs/multiple.sdf', function(data){
              	              viewer.addAsOneMolecule(data, "sdf");
              	              viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              addAsOneMolecule(e, n, a) {
                a = a || {}, a.multimodel = !0, a.onemol = !0;
                var p = new g.GLModel(this.models.length, this.defaultcolors);
                return p.addMolData(e, n, a), this.models.push(p), p;
              }
              /**
               * Delete specified model from viewer
               *
               * @param {GLModel|number} model
               */
              removeModel(e) {
                if (e = this.getModel(e), !!e) {
                  for (e.removegl(this.modelGroup), delete this.models[e.getID()]; this.models.length > 0 && typeof this.models[this.models.length - 1] > "u"; )
                    this.models.pop();
                  return this;
                }
              }
              /**
               * Delete all existing models
               */
              removeAllModels() {
                for (var e = 0; e < this.models.length; e++) {
                  var n = this.models[e];
                  n && n.removegl(this.modelGroup);
                }
                return this.models.splice(0, this.models.length), this;
              }
              /**
               * Export one or all of the loaded models into ChemDoodle compatible JSON.
               * @param {boolean} includeStyles - Whether or not to include style information.
               * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.
               * @return {string}
               */
              exportJSON(e, n) {
                var a = {};
                return n === void 0 ? a.m = this.models.map(function(p) {
                  return p.toCDObject(e);
                }) : a.m = [this.models[n].toCDObject()], JSON.stringify(a);
              }
              /** return a VRML string representation of the scene.  Include VRML header information
               * @return VRML
               */
              exportVRML() {
                var e = this.modelGroup;
                this.applyToModels("removegl", this.modelGroup), this.modelGroup = new v.Object3D(), this.render(null, { supportsImposters: !1, supportsAIA: !1, regen: !0 });
                var n = `#VRML V2.0 utf8
` + this.modelGroup.vrml() + `
`;
                return this.applyToModels("removegl", this.modelGroup), this.modelGroup = e, n;
              }
              /**
               * Create a new model from atoms specified by sel.
               * If extract, removes selected atoms from existing models
               *
               * @param {AtomSelectionSpec} sel - Atom selection specification
               * @param {boolean=} extract - If true, remove selected atoms from existing models
               * @return {GLModel}
               */
              createModelFrom(e, n = !1) {
                for (var a = new g.GLModel(this.models.length, this.defaultcolors), p = 0; p < this.models.length; p++)
                  if (this.models[p]) {
                    var x = this.models[p].selectedAtoms(e);
                    a.addAtoms(x), n && this.models[p].removeAtoms(x);
                  }
                return this.models.push(a), a;
              }
              applyToModels(e, n, a, p, x, D, O) {
                for (var R = this.getModelList(n), z = 0; z < R.length; z++)
                  R[z][e](n, a, p, x, D, O);
              }
              setStyle(e, n) {
                return typeof n > "u" && (n = e, e = {}), this.applyToModels("setStyle", e, n, !1), this;
              }
              addStyle(e, n) {
                return typeof n > "u" && (n = e, e = {}), this.applyToModels("setStyle", e, n, !0), this;
              }
              /**
              	     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed
              	     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list
              	     * of all intersecting objects with their distances from the viewer.
              	     *
              	     * @example
              	        $3Dmol.download("cid:307900",viewer,{},function(){
              
              	               viewer.setStyle({},{sphere:{}});
              	               viewer.setClickable({},true,function(atom,viewer,event,container) {
              	                   viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});
              	               });
              	               viewer.render();
              	    });
              	     */
              setClickable(e, n, a) {
                return this.applyToModels("setClickable", e, n, a), this;
              }
              /** Set hoverable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              	     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.
              	     * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              	    @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.setHoverable({},true,function(atom,viewer,event,container) {
              	               if(!atom.label) {
              	                atom.label = viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});
              	               }
              	           },
              	           function(atom) {
              	               if(atom.label) {
              	                viewer.removeLabel(atom.label);
              	                delete atom.label;
              	               }
              	            }
              	           );
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render();
              	    });
              
              	     */
              setHoverable(e, n, a, p) {
                return this.applyToModels("setHoverable", e, n, a, p), this;
              }
              /** enable context menu and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
              
              	     */
              enableContextMenu(e, n) {
                return this.applyToModels("enableContextMenu", e, n), this;
              }
              /**
               * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.
               * Models can then be animated
               *
               * @param {number} numFrames - number of frames to be created, default to 10
               * @param {number} amplitude - amplitude of distortion, default to 1 (full)
               * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
               * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
               */
              vibrate(e, n, a, p) {
                return this.applyToModels("vibrate", e, n, a, this, p), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               * @param {object} range
               */
              setColorByProperty(e, n, a, p) {
                return this.applyToModels("setColorByProperty", e, n, a, p), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(e, n) {
                return this.applyToModels("setColorByElement", e, n), this;
              }
              /**
               *
               * @param {AtomSpec[]} atomlist
               * @param {Array}
               *            extent
               * @return {Array}
               */
              static getAtomsWithin(e, n) {
                var a = [];
                for (let x = 0; x < e.length; x++) {
                  var p = e[x];
                  typeof p > "u" || p.x < n[0][0] || p.x > n[1][0] || p.y < n[0][1] || p.y > n[1][1] || p.z < n[0][2] || p.z > n[1][2] || a.push(p);
                }
                return a;
              }
              // return volume of extent
              static volume(e) {
                var n = e[1][0] - e[0][0], a = e[1][1] - e[0][1], p = e[1][2] - e[0][2];
                return n * a * p;
              }
              // volume
              /*
               * Break up bounding box/atoms into smaller pieces so we can parallelize
               * with webworkers and also limit the size of the working memory Returns
               * a list of bounding boxes with the corresponding atoms. These extents
               * are expanded by 4 angstroms on each side.
               */
              /**
               *
               * @param {Array}
               *            extent
               * @param {AtomSpec[]} atomlist
               * @param {AtomSpec[]} atomstoshow
               * @return {Array}
               */
              carveUpExtent(e, n, a) {
                let p = [], x = {};
                for (let B = 0, W = n.length; B < W; B++)
                  x[n[B].index] = B;
                let D = function(B) {
                  let W = [];
                  for (let k = 0, F = B.length; k < F; k++)
                    B[k].index in x && W.push(x[B[k].index]);
                  return W;
                }, O = function(B) {
                  let W = [];
                  return W[0] = [B[0][0], B[0][1], B[0][2]], W[1] = [B[1][0], B[1][1], B[1][2]], W;
                }, R = function(B) {
                  if (t.volume(B) < t.maxVolume)
                    return [B];
                  var W = B[1][0] - B[0][0], k = B[1][1] - B[0][1], F = B[1][2] - B[0][2], U;
                  W > k && W > F ? U = 0 : k > W && k > F ? U = 1 : U = 2;
                  var V = O(B), H = O(B), G = (B[1][U] - B[0][U]) / 2 + B[0][U];
                  V[1][U] = G, H[0][U] = G;
                  var Y = R(V), J = R(H);
                  return Y.concat(J);
                }, z = R(e), T = 6;
                for (let B = 0, W = z.length; B < W; B++) {
                  let k = O(z[B]);
                  k[0][0] -= T, k[0][1] -= T, k[0][2] -= T, k[1][0] += T, k[1][1] += T, k[1][2] += T;
                  let F = t.getAtomsWithin(n, k), U = t.getAtomsWithin(a, z[B]);
                  p.push({
                    extent: z[B],
                    atoms: D(F),
                    toshow: D(U)
                  });
                }
                return p;
              }
              // create a mesh defined from the passed vertices and faces and material
              // Just create a single geometry chunk - broken up whether sync or not
              /**
               *
               * @param {AtomSpec[]} atoms
               * @param {{vertices:number,faces:number}}
               *            VandF
               * @param {MeshLambertMaterial}
               *            mat
               * @return {Mesh}
               */
              static generateSurfaceMesh(e, n, a) {
                var p = new v.Geometry(!0), x = p.updateGeoGroup(0), D = [];
                for (let be = 0, Le = e.length; be < Le; be++) {
                  var O = e[be];
                  O && (typeof O.surfaceColor < "u" ? D[be] = O.surfaceColor : O.color && (D[be] = E.CC.color(O.color)));
                }
                var R = x.vertexArray, z = n.vertices;
                for (let be = 0, Le = z.length; be < Le; be++) {
                  let ae = x.vertices * 3;
                  R[ae] = z[be].x, R[ae + 1] = z[be].y, R[ae + 2] = z[be].z, x.vertices++;
                }
                var T = x.colorArray;
                if (a.voldata && a.volscheme) {
                  var B = a.volscheme, W = a.voldata, k = B.range() || [-1, 1];
                  for (let be = 0, Le = z.length; be < Le; be++) {
                    let ae = W.getVal(z[be].x, z[be].y, z[be].z), pe = E.CC.color(B.valueToHex(ae, k)), we = be * 3;
                    T[we] = pe.r, T[we + 1] = pe.g, T[we + 2] = pe.b;
                  }
                } else if (D.length > 0)
                  for (let be = 0, Le = z.length; be < Le; be++) {
                    let ae = z[be].atomid, pe = be * 3;
                    T[pe] = D[ae].r, T[pe + 1] = D[ae].g, T[pe + 2] = D[ae].b;
                  }
                var F = n.faces;
                x.faceidx = F.length, p.initTypedArrays();
                var U = x.vertexArray, V = x.normalArray, H, G, Y, J;
                for (let be = 0, Le = F.length; be < Le; be += 3) {
                  var re = F[be], le = F[be + 1], ie = F[be + 2], xe = re * 3, se = le * 3, ce = ie * 3;
                  H = new M.Vector3(U[xe], U[xe + 1], U[xe + 2]), G = new M.Vector3(U[se], U[se + 1], U[se + 2]), Y = new M.Vector3(U[ce], U[ce + 1], U[ce + 2]), Y.subVectors(Y, G), H.subVectors(H, G), Y.cross(H), J = Y, J.normalize(), V[xe] += J.x, V[se] += J.x, V[ce] += J.x, V[xe + 1] += J.y, V[se + 1] += J.y, V[ce + 1] += J.y, V[xe + 2] += J.z, V[se + 2] += J.z, V[ce + 2] += J.z;
                }
                x.faceArray = new Uint16Array(F);
                var Ee = new v.Mesh(p, a);
                return Ee;
              }
              // do same thing as worker in main thread
              /**
               *
               * @param {SurfaceType}
               *            type
               * @param {Array}
               *            expandedExtent
               * @param {AtomSpec[]}
               *            extendedAtoms
               * @param {AtomSpec[]}
               *            atomsToShow
               * @param {AtomSpec[]} atoms
               * @param {number}
               *            vol
               * @return {Object}
               */
              static generateMeshSyncHelper(e, n, a, p, x, D) {
                var O = new y.ProteinSurface();
                return O.initparm(n, e !== 1, D), O.fillvoxels(x, a), O.buildboundary(), (e == y.SurfaceType.SES || e == y.SurfaceType.MS) && (O.fastdistancemap(), O.boundingatom(!1), O.fillvoxelswaals(x, a)), O.marchingcube(e), O.getFacesAndVertices(p);
              }
              /*
               *
               * @param {SurfaceStyleSpec}
               *            style
               * @return {MeshLambertMaterial}
               */
              static getMatWithStyle(e) {
                var n = new v.MeshLambertMaterial();
                n.vertexColors = v.Coloring.VertexColors;
                for (var a in e)
                  a === "color" || a === "map" || e.hasOwnProperty(a) && (n[a] = e[a]);
                return e.opacity !== void 0 && (e.opacity === 1 ? n.transparent = !1 : n.transparent = !0), n;
              }
              /**
               * Adds an explicit mesh as a surface object.
               * @param {Mesh}
               *            mesh
               * @param {Object}
               *            style
               * @returns {number} surfid
               */
              addMesh(e) {
                var n = {
                  geo: e.geometry,
                  mat: e.material,
                  done: !0,
                  finished: !1
                  //the rendered finishes surfaces when they are done
                }, a = this.nextSurfID();
                return this.surfaces[a] = n, a;
              }
              //return a shallow copy of list l, e.g., for atoms so we can
              //ignore superficial changes (ie surfacecolor, position) that happen
              //while we're surface building
              static shallowCopy(e) {
                var n = [];
                let a = e.length;
                for (let p = 0; p < a; p++)
                  n[p] = (0, A.extend)({}, e[p]);
                return n;
              }
              /**
               * Add surface representation to atoms
               * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)
               * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)
               * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection
               * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'
               * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms
               * @param {function} surfacecallback - function to be called after setting the surface
               * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.
               */
              addSurface(e, n = {}, a = {}, p, x, D) {
                let O = this.nextSurfID(), R = null, z = this, T = y.SurfaceType.VDW;
                typeof e == "string" ? t.surfaceTypeMap[e.toUpperCase()] !== void 0 ? T = t.surfaceTypeMap[e] : console.log("Surface type : " + e + " is not recognized") : typeof e == "number" && (T = e);
                var B = null, W = null, k = t.shallowCopy(this.getAtomsFromSel(a));
                p ? B = t.shallowCopy(this.getAtomsFromSel(p)) : B = k, (0, A.adjustVolumeStyle)(n);
                var F = !1, U;
                for (U = 0; U < this.models.length; U++)
                  if (this.models[U]) {
                    var V = this.models[U].getSymmetries();
                    if (V.length > 1 || V.length == 1 && !V[0].isIdentity()) {
                      F = !0;
                      break;
                    }
                  }
                var H = function(xe, se, ce) {
                  x ? W = t.shallowCopy(z.getAtomsFromSel(x)) : W = ce;
                  var Ee, be = (0, A.getExtent)(ce, !0);
                  if (n.map && n.map.prop) {
                    var Le = n.map.prop;
                    let Te = (0, h.getGradient)(n.map.scheme || n.map.gradient || new h.Gradient.RWB()), Re = Te.range();
                    Re || (Re = (0, A.getPropertyRange)(ce, Le)), n.colorscheme = { prop: Le, gradient: Te };
                  }
                  for (let Te = 0, Re = se.length; Te < Re; Te++)
                    Ee = se[Te], Ee.surfaceColor = (0, A.getColorFromStyle)(Ee, n);
                  var ae = t.volume(be), pe = z.carveUpExtent(be, se, ce);
                  if (W && W.length && W.length > 0) {
                    var we = (0, A.getExtent)(W, !0), Ge = function(Te, Re) {
                      var ke = function(K, q) {
                        var fe = K.extent, ue = fe[1][0] - fe[0][0], De = fe[1][1] - fe[0][1], Se = fe[1][2] - fe[0][2], Z = ue - q[2][0];
                        Z *= Z;
                        var de = De - q[2][1];
                        de *= de;
                        var me = Se - q[2][2];
                        return me *= me, Z + de + me;
                      }, Ne = ke(Te, we), X = ke(Re, we);
                      return Ne - X;
                    };
                    pe.sort(Ge);
                  }
                  var We = [];
                  for (let Te = 0, Re = se.length; Te < Re; Te++)
                    Ee = se[Te], We[Te] = {
                      x: Ee.x,
                      y: Ee.y,
                      z: Ee.z,
                      serial: Te,
                      elem: Ee.elem
                    };
                  var je = !!y.syncSurface;
                  if (je) {
                    var Fe = function(Re) {
                      return new Promise(function(ke) {
                        for (var Ne = t.generateMeshSyncHelper(T, pe[Re].extent, pe[Re].atoms, pe[Re].toshow, We, ae), X = (0, c.splitMesh)({ vertexArr: Ne.vertices, faceArr: Ne.faces }), K = 0, q = X.length; K < q; K++) {
                          Ne = {
                            vertices: X[K].vertexArr,
                            faces: X[K].faceArr
                          };
                          var fe = t.generateSurfaceMesh(se, Ne, R);
                          (0, A.mergeGeos)(xe.geo, fe);
                        }
                        z.render(), ke();
                      });
                    }, ze = [];
                    for (let Te = 0; Te < pe.length; Te++)
                      ze.push(Fe(Te));
                    return Promise.all(ze).then(function() {
                      return xe.done = !0, Promise.resolve(O);
                    });
                  } else {
                    var Be = [];
                    T < 0 && (T = 0);
                    for (let Te = 0, Re = t.numWorkers; Te < Re; Te++) {
                      var Ie = new Worker($3Dmol.SurfaceWorker);
                      Be.push(Ie), Ie.postMessage({
                        type: -1,
                        atoms: We,
                        volume: ae
                      });
                    }
                    return new Promise(function(Te, Re) {
                      var ke = 0, Ne = function() {
                        !Be || !Be.length || Be.forEach(function(fe) {
                          fe && fe.terminate && fe.terminate();
                        });
                      }, X = function(fe) {
                        for (var ue = (0, c.splitMesh)({
                          vertexArr: fe.data.vertices,
                          faceArr: fe.data.faces
                        }), De = 0, Se = ue.length; De < Se; De++) {
                          var Z = {
                            vertices: ue[De].vertexArr,
                            faces: ue[De].faceArr
                          }, de = t.generateSurfaceMesh(se, Z, R);
                          (0, A.mergeGeos)(xe.geo, de);
                        }
                        z.render(), ke++, ke == pe.length && (xe.done = !0, Ne(), Te(O));
                      }, K = function(fe) {
                        Ne(), console.log(fe.message + " (" + fe.filename + ":" + fe.lineno + ")"), Re(fe);
                      };
                      for (let fe = 0; fe < pe.length; fe++) {
                        var q = Be[fe % Be.length];
                        q.onmessage = X, q.onerror = K, q.postMessage({
                          type: T,
                          expandedExtent: pe[fe].extent,
                          extendedAtoms: pe[fe].atoms,
                          atomsToShow: pe[fe].toshow
                        });
                      }
                    });
                  }
                };
                n = n || {}, R = t.getMatWithStyle(n);
                var G = [];
                G.style = n, G.atomsel = a, G.allsel = p, G.focus = x;
                var Y = null;
                if (F) {
                  var J = {}, re = {};
                  for (U = 0; U < this.models.length; U++)
                    J[U] = [], re[U] = [];
                  for (U = 0; U < B.length; U++)
                    J[B[U].model].push(B[U]);
                  for (U = 0; U < k.length; U++)
                    re[k[U].model].push(k[U]);
                  var le = [];
                  for (U = 0; U < this.models.length; U++)
                    re[U].length > 0 && (G.push({
                      geo: new v.Geometry(!0),
                      mat: R,
                      done: !1,
                      finished: !1,
                      symmetries: this.models[U].getSymmetries()
                      // also webgl initialized
                    }), le.push(H(G[G.length - 1], J[U], re[U])));
                  Y = Promise.all(le);
                } else
                  G.push({
                    geo: new v.Geometry(!0),
                    mat: R,
                    done: !1,
                    finished: !1,
                    symmetries: [new M.Matrix4()]
                  }), Y = H(G[G.length - 1], B, k);
                return this.surfaces[O] = G, Y.surfid = O, D && typeof D == "function" ? (Y.then(function(ie) {
                  D(ie);
                }), O) : Y;
              }
              /**
               * Set the surface material to something else, must render change
               * @param {number} surf - Surface ID to apply changes to
               * @param {SurfaceStyleSpec} style - new material style specification
               @example
               $3Dmol.get("data/9002806.cif",function(data){
                  viewer.addModel(data);
                  viewer.setStyle({stick:{}});
                  let surf = viewer.addSurface("SAS");
                  surf.then(function() {
                      viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});
                      viewer.render();
                      });
                 });
               */
              setSurfaceMaterialStyle(e, n) {
                if ((0, A.adjustVolumeStyle)(n), this.surfaces[e]) {
                  var a = this.surfaces[e];
                  a.style = n;
                  for (var p = 0; p < a.length; p++) {
                    var x = a[p].mat = t.getMatWithStyle(n);
                    if (a[p].mat.side = v.FrontSide, n.color) {
                      a[p].mat.color = n.color, a[p].geo.colorsNeedUpdate = !0;
                      const D = E.CC.color(n.color);
                      a[p].geo.setColors(function() {
                        return D;
                      });
                    } else if (x.voldata && x.volscheme) {
                      const D = x.volscheme, O = x.voldata, R = E.CC, z = D.range() || [-1, 1];
                      a[p].geo.setColors(function(T, B, W) {
                        let k = O.getVal(T, B, W);
                        return R.color(D.valueToHex(k, z));
                      });
                    }
                    a[p].finished = !1;
                  }
                }
                return this;
              }
              /**
               * Return surface object
               * @param {number} surf - surface id
               */
              getSurface(e) {
                return this.surfaces[e];
              }
              /**
               * Remove surface with given ID
               * @param {number} surf - surface id
               */
              removeSurface(e) {
                for (var n = this.surfaces[e], a = 0; a < n.length; a++)
                  n[a] && n[a].lastGL && (n[a].geo !== void 0 && n[a].geo.dispose(), n[a].mat !== void 0 && n[a].mat.dispose(), this.modelGroup.remove(n[a].lastGL));
                return delete this.surfaces[e], this.show(), this;
              }
              /** Remove all surfaces.
               **/
              removeAllSurfaces() {
                for (var e in this.surfaces)
                  if (this.surfaces.hasOwnProperty(e)) {
                    for (var n = this.surfaces[e], a = 0; a < n.length; a++)
                      n[a] && n[a].lastGL && (n[a].geo !== void 0 && n[a].geo.dispose(), n[a].mat !== void 0 && n[a].mat.dispose(), this.modelGroup.remove(n[a].lastGL));
                    delete this.surfaces[e];
                  }
                return this.show(), this;
              }
              /** return Jmol moveto command to position this scene */
              jmolMoveTo() {
                var e = this.modelGroup.position, n = "center { " + -e.x + " " + -e.y + " " + -e.z + " }; ", a = this.rotationGroup.quaternion;
                return n += "moveto .5 quaternion { " + a.x + " " + a.y + " " + a.z + " " + a.w + " };", n;
              }
              /** Clear scene of all objects
               * */
              clear() {
                return this.removeAllSurfaces(), this.removeAllModels(), this.removeAllLabels(), this.removeAllShapes(), this.show(), this;
              }
              // props is a list of objects that select certain atoms and enumerate
              // properties for those atoms
              /**
               * Add specified properties to all atoms matching input argument
               * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties
               * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here
                   @example
                   $3Dmol.get('../test_structs/b.sdf', function(data){
                            viewer.addModel(data,'sdf');
                            let props = [];
                            //make the atom index a property x
                            for(let i = 0; i < 8; i++) {
                              props.push({index:i,props:{'x':i}});
                            }
                            viewer.mapAtomProperties(props);
                            viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});
                            viewer.zoomTo();
                            viewer.render();
                          });
               */
              mapAtomProperties(e, n) {
                n = n || {};
                var a = this.getAtomsFromSel(n);
                if (typeof e == "function")
                  for (let D = 0, O = a.length; D < O; D++) {
                    let R = a[D];
                    e(R);
                  }
                else
                  for (let D = 0, O = a.length; D < O; D++) {
                    var p = a[D];
                    for (let R = 0, z = e.length; R < z; R++) {
                      let T = e[R];
                      if (T.props)
                        for (var x in T.props)
                          T.props.hasOwnProperty(x) && this.atomIsSelected(p, T) && (p.properties || (p.properties = {}), p.properties[x] = T.props[x]);
                    }
                  }
                return this;
              }
              /**
               * Synchronize this view matrix of this viewer to the passed viewer.
               * When the viewpoint of this viewer changes, the other viewer will
               * be set to this viewer's view.
               * @param {$3Dmol.GLViewer} otherview
               */
              linkViewer(e) {
                return this.linkedViewers.push(e), this;
              }
              /**
               * Return the z distance between the model and the camera
               * @return {number} distance
               */
              getPerceivedDistance() {
                return this.CAMERA_Z - this.rotationGroup.position.z;
              }
              /**
               * Set the distance between the model and the camera
               * Essentially zooming. Useful while stereo rendering.
               */
              setPerceivedDistance(e) {
                this.rotationGroup.position.z = this.CAMERA_Z - e;
              }
              /**
               * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object
               * @return {number} camera x position
               */
              setAutoEyeSeparation(e, n) {
                var a = this.getPerceivedDistance();
                return n || (n = 5), e || this.camera.position.x > 0 ? this.camera.position.x = a * Math.tan(Math.PI / 180 * n) : this.camera.position.x = -a * Math.tan(Math.PI / 180 * n), this.camera.lookAt(new M.Vector3(0, 0, this.rotationGroup.position.z)), this.camera.position.x;
              }
              /**
               * Set the default cartoon quality for newly created models.  Default is 5.
               * Current models are not affected.
               * @number quality, higher results in higher resolution renders
               */
              setDefaultCartoonQuality(e) {
                this.config.cartoonQuality = e;
              }
            }
            t.numWorkers = 4, t.maxVolume = 64e3, t.surfaceTypeMap = {
              VDW: y.SurfaceType.VDW,
              MS: y.SurfaceType.MS,
              SAS: y.SurfaceType.SAS,
              SES: y.SurfaceType.SES
            };
            function r(l, e) {
              if (l = (0, A.getElement)(l), !!l) {
                e = e || {};
                try {
                  var n = new t(l, e);
                  return n;
                } catch (a) {
                  throw "error creating viewer: " + a;
                }
              }
            }
            function u(l, e = {}, n = {}) {
              if (l = (0, A.getElement)(l), !!l) {
                var a = [], p = document.createElement("canvas");
                n.rows = e.rows, n.cols = e.cols, n.control_all = e.control_all != null ? e.control_all : !1, l.appendChild(p);
                try {
                  for (var x = 0; x < e.rows; x++) {
                    for (var D = [], O = 0; O < e.cols; O++) {
                      n.row = x, n.col = O, n.canvas = p, n.viewers = a, n.control_all = e.control_all;
                      var R = r(l, (0, A.extend)({}, n));
                      D.push(R);
                    }
                    a.unshift(D);
                  }
                } catch (z) {
                  throw "error creating viewer grid: " + z;
                }
                return a;
              }
            }
            function o(l) {
              var e = this;
              if (l = (0, A.getElement)(l), !!l) {
                var n = u(l, { rows: 1, cols: 2, control_all: !0 });
                this.glviewer1 = n[0][0], this.glviewer2 = n[0][1], this.glviewer1.setAutoEyeSeparation(!1), this.glviewer2.setAutoEyeSeparation(!0), this.glviewer1.linkViewer(this.glviewer2), this.glviewer2.linkViewer(this.glviewer1);
                for (var a = Object.getOwnPropertyNames(this.glviewer1.__proto__).filter(function(x) {
                  return typeof e.glviewer1[x] == "function";
                }), p = 0; p < a.length; p++)
                  this[a[p]] = function(x) {
                    return function() {
                      var D = this.glviewer1[x].apply(this.glviewer1, arguments), O = this.glviewer2[x].apply(this.glviewer2, arguments);
                      return [D, O];
                    };
                  }(a[p]);
                this.setCoordinates = function(x, D, O) {
                  for (var R = 0; R < x.length; R++)
                    x[R].setCoordinates(D, O);
                }, this.surfacesFinished = function() {
                  return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();
                }, this.isAnimated = function() {
                  return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();
                }, this.render = function(x) {
                  this.glviewer1.render(), this.glviewer2.render(), x && x(this);
                }, this.getCanvas = function() {
                  return this.glviewer1.getCanvas();
                };
              }
            }
          }
        ),
        /***/
        "./src/Gradient.ts": (
          /*!*************************!*\
            !*** ./src/Gradient.ts ***!
            \*************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CustomLinear: () => (
                /* binding */
                c
              ),
              /* harmony export */
              Gradient: () => (
                /* binding */
                y
              ),
              /* harmony export */
              GradientType: () => (
                /* binding */
                M
              ),
              /* harmony export */
              ROYGB: () => (
                /* binding */
                g
              ),
              /* harmony export */
              RWB: () => (
                /* binding */
                h
              ),
              /* harmony export */
              Sinebow: () => (
                /* binding */
                C
              ),
              /* harmony export */
              builtinGradients: () => (
                /* binding */
                S
              ),
              /* harmony export */
              getGradient: () => (
                /* binding */
                A
              ),
              /* harmony export */
              normalizeValue: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./colors */
              "./src/colors.ts"
            );
            class M {
            }
            function E(b, w, t) {
              return w >= b ? (t < b && (t = b), t > w && (t = w), { lo: b, hi: w, val: t }) : (t > b && (t = b), t < w && (t = w), t = b - t + w, { lo: w, hi: b, val: t });
            }
            function A(b) {
              if (b instanceof M)
                return b;
              if (b.gradient !== void 0 && S[b.gradient]) {
                let w = b.min === void 0 ? -1 : b.min, t = b.max === void 0 ? 1 : b.max;
                return b.mid === void 0 ? b.colors === void 0 ? new S[b.gradient](w, t) : new S[b.gradient](w, t, b.colors) : new S[b.gradient](w, t, b.mid);
              }
              return b;
            }
            class h extends M {
              constructor(w, t, r) {
                super(), this.gradient = "RWB", this.mult = 1, this.mid = r, this.min = w, this.max = t, typeof t > "u" && Array.isArray(w) && w.length >= 2 ? (this.max = w[1], this.min = w[0]) : w && t && !Array.isArray(w) && (this.min = w, this.max = t);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(w, t) {
                var r, u;
                if (w = this.mult * w, t ? (r = t[0], u = t[1]) : (r = this.min, u = this.max), w === void 0)
                  return 16777215;
                var o = E(r, u, w);
                r = o.lo, u = o.hi, w = o.val;
                var l = (u + r) / 2;
                t && typeof t[2] < "u" ? l = t[2] : typeof this.mid < "u" ? l = this.mid : l = (r + u) / 2;
                var e, n;
                return w < l ? (e = Math.floor(255 * Math.sqrt((w - r) / (l - r))), n = 16711680 + 256 * e + e, n) : w > l ? (e = Math.floor(255 * Math.sqrt(1 - (w - l) / (u - l))), n = 65536 * e + 256 * e + 255, n) : 16777215;
              }
            }
            class g extends M {
              constructor(w, t) {
                super(), this.gradient = "ROYGB", this.mult = 1, this.min = w, this.max = t, typeof t > "u" && Array.isArray(w) && w.length >= 2 ? (this.max = w[1], this.min = w[0]) : w && t && !Array.isArray(w) && (this.min = w, this.max = t);
              }
              //map value to hex color, range is provided
              valueToHex(w, t) {
                var r, u;
                if (w = this.mult * w, t ? (r = t[0], u = t[1]) : (r = this.min, u = this.max), typeof w > "u")
                  return 16777215;
                var o = E(r, u, w);
                r = o.lo, u = o.hi, w = o.val;
                var l = (r + u) / 2, e = (r + l) / 2, n = (l + u) / 2, a, p;
                return w < e ? (a = Math.floor(255 * Math.sqrt((w - r) / (e - r))), p = 16711680 + 256 * a + 0, p) : w < l ? (a = Math.floor(255 * Math.sqrt(1 - (w - e) / (l - e))), p = 65536 * a + 65280 + 0, p) : w < n ? (a = Math.floor(255 * Math.sqrt((w - l) / (n - l))), p = 65280 + 1 * a, p) : (a = Math.floor(255 * Math.sqrt(1 - (w - n) / (u - n))), p = 0 + 256 * a + 255, p);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class C extends M {
              constructor(w, t) {
                super(), this.gradient = "Sinebow", this.mult = 1, this.min = w, this.max = t, typeof t > "u" && Array.isArray(w) && w.length >= 2 && (this.max = w[1], this.min = w[0]), t < w && (this.mult = -1, this.min *= -1, this.max *= -1);
              }
              //map value to hex color, range is provided
              valueToHex(w, t) {
                var r, u;
                if (w = this.mult * w, t ? (r = t[0], u = t[1]) : (r = this.min, u = this.max), typeof w > "u")
                  return 16777215;
                var o = y.normalizeValue(r, u, w);
                r = o.lo, u = o.hi, w = o.val;
                var l = (w - r) / (u - r), e = 5 * l / 6 + 0.5, n = Math.sin(Math.PI * e);
                n *= n * 255;
                var a = Math.sin(Math.PI * (e + 1 / 3));
                a *= a * 255;
                var p = Math.sin(Math.PI * (e + 2 / 3));
                return p *= p * 255, 65536 * Math.floor(n) + 256 * Math.floor(p) + 1 * Math.floor(a);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class c extends M {
              constructor(w, t, r) {
                super(), this.gradient = "linear", this.colors = new Array();
                var u;
                if (Array.isArray(w) && w.length >= 2 ? (this.max = w[1], this.min = w[0], u = t) : (this.min = w, this.max = t, u = r), u)
                  for (let o of u)
                    this.colors.push(v.CC.color(o));
                else
                  this.colors.push(v.CC.color(0));
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(w, t) {
                var r, u;
                if (t ? (r = t[0], u = t[1]) : (r = this.min, u = this.max), w === void 0)
                  return 16777215;
                var o = E(r, u, w);
                r = o.lo, u = o.hi, w = o.val;
                let l = this.colors.length, e = (u - r) / l, n = Math.min(Math.floor((w - r) / e), l - 1), a = Math.min(n + 1, l - 1), p = (w - r - n * e) / e, x = this.colors[n], D = this.colors[a];
                return new v.Color(x.r + p * (D.r - x.r), x.g + p * (D.g - x.g), x.b + p * (D.b - x.b)).getHex();
              }
            }
            const S = {
              rwb: h,
              RWB: h,
              roygb: g,
              ROYGB: g,
              sinebow: C,
              linear: c
            };
            class y extends M {
              valueToHex(w, t) {
                return 0;
              }
              range() {
                return null;
              }
            }
            y.RWB = h, y.ROYGB = g, y.Sinebow = C, y.CustomLinear = c, y.builtinGradients = S, y.normalizeValue = E, y.getGradient = A;
          }
        ),
        /***/
        "./src/Label.ts": (
          /*!**********************!*\
            !*** ./src/Label.ts ***!
            \**********************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Label: () => (
                /* binding */
                C
              ),
              /* harmony export */
              LabelCount: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), E = s(
              /*! ./colors */
              "./src/colors.ts"
            );
            let A = 0;
            function h(c, S, y, b, w, t, r) {
              c.beginPath(), c.moveTo(S + t, y), c.lineTo(S + b - t, y), c.quadraticCurveTo(S + b, y, S + b, y + t), c.lineTo(S + b, y + w - t), c.quadraticCurveTo(S + b, y + w, S + b - t, y + w), c.lineTo(S + t, y + w), c.quadraticCurveTo(S, y + w, S, y + w - t), c.lineTo(S, y + t), c.quadraticCurveTo(S, y, S + t, y), c.closePath(), c.fill(), r && c.stroke();
            }
            function g(c, S, y) {
              var b = y;
              return typeof c < "u" && (c instanceof E.Color ? b = c.scaled() : (b = E.CC.color(c), typeof b.scaled < "u" && (b = b.scaled()))), typeof S < "u" && (b.a = parseFloat(S)), b;
            }
            class C {
              constructor(S, y) {
                this.id = A++, this.stylespec = y || {}, this.canvas = document.createElement("canvas"), this.canvas.width = 134, this.canvas.height = 35, this.context = this.canvas.getContext("2d"), this.sprite = new v.Sprite(), this.text = S, this.frame = this.stylespec.frame;
              }
              getStyle() {
                return this.stylespec;
              }
              setContext() {
                var S = this.stylespec, y = typeof S.useScreen > "u" ? !1 : S.useScreen, b = S.showBackground;
                (b === "0" || b === "false") && (b = !1), typeof b > "u" && (b = !0);
                var w = S.font ? S.font : "sans-serif", t = parseInt(S.fontSize) ? parseInt(S.fontSize) : 18, r = g(S.fontColor, S.fontOpacity, {
                  r: 255,
                  g: 255,
                  b: 255,
                  a: 1
                }), u = S.padding ? S.padding : 4, o = S.borderThickness ? S.borderThickness : 0, l = g(S.backgroundColor, S.backgroundOpacity, {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 1
                }), e = g(S.borderColor, S.borderOpacity, l), n = S.position ? S.position : {
                  x: -10,
                  y: 1,
                  z: 1
                }, a = S.inFront !== void 0 ? S.inFront : !0;
                (a === "false" || a === "0") && (a = !1);
                var p = S.alignment || v.SpriteAlignment.topLeft;
                typeof p == "string" && p in v.SpriteAlignment && (p = v.SpriteAlignment[p]);
                var x = "";
                S.bold && (x = "bold "), this.context.font = x + t + "px  " + w;
                var D = this.context.measureText(this.text), O = D.width;
                b || (o = 0);
                var R = O + 2.5 * o + 2 * u, z = t * 1.25 + 2 * o + 2 * u;
                if (S.backgroundImage) {
                  var T = S.backgroundImage, B = S.backgroundWidth ? S.backgroundWidth : T.width, W = S.backgroundHeight ? S.backgroundHeight : T.height;
                  B > R && (R = B), W > z && (z = W);
                }
                if (this.canvas.width = R, this.canvas.height = z, this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), x = "", S.bold && (x = "bold "), this.context.font = x + t + "px  " + w, this.context.fillStyle = "rgba(" + l.r + "," + l.g + "," + l.b + "," + l.a + ")", this.context.strokeStyle = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", S.backgroundGradient) {
                  let F = this.context.createLinearGradient(0, z / 2, R, z / 2), U = M.Gradient.getGradient(S.backgroundGradient), V = U.range(), H = -1, G = 1;
                  V && (H = V[0], G = V[1]);
                  let Y = G - H;
                  for (let J = 0; J < 1.01; J += 0.1) {
                    let re = g(U.valueToHex(H + Y * J)), le = "rgba(" + re.r + "," + re.g + "," + re.b + "," + re.a + ")";
                    F.addColorStop(J, le);
                  }
                  this.context.fillStyle = F;
                }
                this.context.lineWidth = o, b && h(this.context, o, o, R - 2 * o, z - 2 * o, 6, o > 0), S.backgroundImage && this.context.drawImage(T, 0, 0, R, z), this.context.fillStyle = "rgba(" + r.r + "," + r.g + "," + r.b + "," + r.a + ")", this.context.fillText(this.text, o + u, t + o + u, O);
                var k = new v.Texture(this.canvas);
                k.needsUpdate = !0, this.sprite.material = new v.SpriteMaterial({
                  map: k,
                  useScreenCoordinates: y,
                  alignment: p,
                  depthTest: !a,
                  screenOffset: S.screenOffset || null
                }), this.sprite.scale.set(1, 1, 1), this.sprite.position.set(n.x, n.y, n.z);
              }
              // clean up material and texture
              dispose() {
                this.sprite.material.map !== void 0 && this.sprite.material.map.dispose(), this.sprite.material !== void 0 && this.sprite.material.dispose();
              }
            }
          }
        ),
        /***/
        "./src/ProteinSurface4.ts": (
          /*!********************************!*\
            !*** ./src/ProteinSurface4.ts ***!
            \********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MarchingCube: () => (
                /* binding */
                g
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* binding */
                h
              ),
              /* harmony export */
              PointGrid: () => (
                /* binding */
                C
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* binding */
                c
              ),
              /* harmony export */
              SurfaceType: () => (
                /* binding */
                M
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* binding */
                A
              ),
              /* harmony export */
              syncSurface: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), M;
            (function(S) {
              S[S.VDW = 1] = "VDW", S[S.MS = 2] = "MS", S[S.SAS = 3] = "SAS", S[S.SES = 4] = "SES";
            })(M || (M = {}));
            var E = !1;
            function A(S) {
              E = S;
            }
            (window.navigator.userAgent.indexOf("MSIE ") >= 0 || window.navigator.userAgent.indexOf("Trident/") >= 0) && (E = !0);
            class h {
              constructor() {
                this.ISDONE = 2, this.edgeTable = new Uint32Array([
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  2816,
                  0,
                  0,
                  0,
                  1792,
                  0,
                  3328,
                  3584,
                  3840,
                  0,
                  0,
                  0,
                  138,
                  0,
                  21,
                  0,
                  134,
                  0,
                  0,
                  0,
                  652,
                  0,
                  2067,
                  3865,
                  3600,
                  0,
                  0,
                  0,
                  42,
                  0,
                  0,
                  0,
                  294,
                  0,
                  0,
                  21,
                  28,
                  0,
                  3875,
                  1049,
                  3360,
                  0,
                  168,
                  162,
                  170,
                  0,
                  645,
                  2475,
                  2210,
                  0,
                  687,
                  293,
                  172,
                  4010,
                  3747,
                  3497,
                  3232,
                  0,
                  0,
                  0,
                  0,
                  0,
                  69,
                  0,
                  900,
                  0,
                  0,
                  0,
                  1792,
                  138,
                  131,
                  1608,
                  1920,
                  0,
                  81,
                  0,
                  2074,
                  84,
                  85,
                  84,
                  86,
                  0,
                  81,
                  0,
                  3676,
                  330,
                  1105,
                  1881,
                  1616,
                  0,
                  0,
                  0,
                  42,
                  0,
                  69,
                  0,
                  502,
                  0,
                  0,
                  21,
                  3580,
                  138,
                  2035,
                  1273,
                  1520,
                  2816,
                  104,
                  2337,
                  106,
                  840,
                  581,
                  367,
                  102,
                  2816,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  3910,
                  0,
                  0,
                  69,
                  588,
                  42,
                  2083,
                  41,
                  2880,
                  0,
                  0,
                  0,
                  1722,
                  0,
                  2293,
                  4095,
                  3830,
                  0,
                  255,
                  757,
                  764,
                  2538,
                  2291,
                  3065,
                  2800,
                  0,
                  0,
                  81,
                  338,
                  0,
                  3925,
                  1119,
                  3414,
                  84,
                  855,
                  85,
                  340,
                  2130,
                  2899,
                  89,
                  2384,
                  1792,
                  712,
                  194,
                  1162,
                  4036,
                  3781,
                  3535,
                  3270,
                  708,
                  719,
                  197,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  0,
                  0,
                  0,
                  0,
                  168,
                  420,
                  168,
                  1958,
                  162,
                  162,
                  676,
                  2988,
                  170,
                  163,
                  680,
                  928,
                  3328,
                  3096,
                  3328,
                  3642,
                  52,
                  53,
                  1855,
                  1590,
                  2340,
                  2111,
                  2869,
                  2620,
                  298,
                  51,
                  825,
                  560,
                  3584,
                  3584,
                  3090,
                  3482,
                  1668,
                  1941,
                  1183,
                  1430,
                  146,
                  2975,
                  2069,
                  2460,
                  154,
                  915,
                  153,
                  400,
                  3840,
                  3592,
                  3329,
                  3082,
                  1796,
                  1541,
                  1295,
                  1030,
                  2818,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ]), this.triTable = [
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [11, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [],
                  [10, 8, 11],
                  [9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [],
                  [],
                  [],
                  [1, 7, 3],
                  [],
                  [4, 2, 0],
                  [],
                  [2, 1, 7],
                  [],
                  [],
                  [],
                  [2, 7, 3, 2, 9, 7],
                  [],
                  [1, 4, 11, 1, 0, 4],
                  [3, 8, 0, 11, 9, 4, 11, 10, 9],
                  [4, 11, 9, 11, 10, 9],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [],
                  [],
                  [2, 5, 8, 2, 1, 5],
                  [],
                  [],
                  [2, 4, 0],
                  [3, 2, 4],
                  [],
                  [0, 9, 1, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4],
                  [5, 8, 10, 8, 11, 10],
                  [],
                  [3, 5, 7],
                  [7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [],
                  [9, 2, 0, 9, 7, 2],
                  [0, 3, 8, 1, 7, 11, 1, 5, 7],
                  [11, 1, 7, 1, 5, 7],
                  [],
                  [9, 1, 0, 5, 3, 2, 5, 7, 3],
                  [8, 2, 5, 8, 0, 2],
                  [2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 2, 9, 7, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [7, 1, 3],
                  [7, 1, 0],
                  [6, 9, 3, 6, 10, 9],
                  [7, 10, 8, 10, 9, 8],
                  [],
                  [6, 0, 4],
                  [],
                  [11, 1, 4, 11, 3, 1],
                  [2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [2, 4, 6],
                  [1, 4, 2, 4, 6, 2],
                  [],
                  [6, 0, 4],
                  [],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 6, 1, 8, 1, 3],
                  [10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [],
                  [],
                  [2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [9, 11, 8],
                  [3, 5, 6],
                  [0, 5, 11, 0, 11, 8],
                  [6, 3, 5, 3, 1, 5],
                  [3, 9, 6, 3, 8, 9],
                  [9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [1, 10, 2, 9, 11, 6, 9, 8, 11],
                  [],
                  [],
                  [6, 0, 2],
                  [3, 6, 9, 3, 2, 6],
                  [3, 5, 1],
                  [0, 5, 1, 0, 11, 5],
                  [0, 3, 5],
                  [6, 9, 11, 9, 8, 11],
                  [],
                  [],
                  [],
                  [4, 5, 9, 7, 1, 10, 7, 3, 1],
                  [],
                  [11, 6, 7, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [],
                  [],
                  [0, 6, 4],
                  [8, 6, 4, 8, 1, 6],
                  [],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [4, 2, 6],
                  [1, 0, 9, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [8, 2, 4, 2, 6, 4],
                  [11, 4, 1, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [10, 8, 9],
                  [6, 3, 9, 6, 7, 3],
                  [6, 7, 1],
                  [10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [],
                  [],
                  [],
                  [],
                  [5, 3, 7],
                  [8, 5, 2, 8, 7, 5],
                  [5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [1, 7, 5],
                  [1, 7, 5],
                  [9, 2, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [0, 7, 1, 7, 5, 1],
                  [9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [8, 10, 11],
                  [3, 4, 10, 3, 10, 11],
                  [8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [2, 4, 5],
                  [5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [2, 8, 5, 2, 11, 8],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [11, 9, 10],
                  [11, 9, 10],
                  [1, 11, 4, 1, 10, 11],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 7, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [1, 7, 4],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [3, 9, 11, 9, 10, 11],
                  [0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ], this.edgeTable2 = [
                  0,
                  265,
                  515,
                  778,
                  2060,
                  2309,
                  2575,
                  2822,
                  1030,
                  1295,
                  1541,
                  1804,
                  3082,
                  3331,
                  3593,
                  3840,
                  400,
                  153,
                  915,
                  666,
                  2460,
                  2197,
                  2975,
                  2710,
                  1430,
                  1183,
                  1941,
                  1692,
                  3482,
                  3219,
                  3993,
                  3728,
                  560,
                  825,
                  51,
                  314,
                  2620,
                  2869,
                  2111,
                  2358,
                  1590,
                  1855,
                  1077,
                  1340,
                  3642,
                  3891,
                  3129,
                  3376,
                  928,
                  681,
                  419,
                  170,
                  2988,
                  2725,
                  2479,
                  2214,
                  1958,
                  1711,
                  1445,
                  1196,
                  4010,
                  3747,
                  3497,
                  3232,
                  2240,
                  2505,
                  2755,
                  3018,
                  204,
                  453,
                  719,
                  966,
                  3270,
                  3535,
                  3781,
                  4044,
                  1226,
                  1475,
                  1737,
                  1984,
                  2384,
                  2137,
                  2899,
                  2650,
                  348,
                  85,
                  863,
                  598,
                  3414,
                  3167,
                  3925,
                  3676,
                  1370,
                  1107,
                  1881,
                  1616,
                  2800,
                  3065,
                  2291,
                  2554,
                  764,
                  1013,
                  255,
                  502,
                  3830,
                  4095,
                  3317,
                  3580,
                  1786,
                  2035,
                  1273,
                  1520,
                  2912,
                  2665,
                  2403,
                  2154,
                  876,
                  613,
                  367,
                  102,
                  3942,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  1120,
                  1385,
                  1635,
                  1898,
                  3180,
                  3429,
                  3695,
                  3942,
                  102,
                  367,
                  613,
                  876,
                  2154,
                  2403,
                  2665,
                  2912,
                  1520,
                  1273,
                  2035,
                  1786,
                  3580,
                  3317,
                  4095,
                  3830,
                  502,
                  255,
                  1013,
                  764,
                  2554,
                  2291,
                  3065,
                  2800,
                  1616,
                  1881,
                  1107,
                  1370,
                  3676,
                  3925,
                  3167,
                  3414,
                  598,
                  863,
                  85,
                  348,
                  2650,
                  2899,
                  2137,
                  2384,
                  1984,
                  1737,
                  1475,
                  1226,
                  4044,
                  3781,
                  3535,
                  3270,
                  966,
                  719,
                  453,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  3232,
                  3497,
                  3747,
                  4010,
                  1196,
                  1445,
                  1711,
                  1958,
                  2214,
                  2479,
                  2725,
                  2988,
                  170,
                  419,
                  681,
                  928,
                  3376,
                  3129,
                  3891,
                  3642,
                  1340,
                  1077,
                  1855,
                  1590,
                  2358,
                  2111,
                  2869,
                  2620,
                  314,
                  51,
                  825,
                  560,
                  3728,
                  3993,
                  3219,
                  3482,
                  1692,
                  1941,
                  1183,
                  1430,
                  2710,
                  2975,
                  2197,
                  2460,
                  666,
                  915,
                  153,
                  400,
                  3840,
                  3593,
                  3331,
                  3082,
                  1804,
                  1541,
                  1295,
                  1030,
                  2822,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ], this.triTable2 = [
                  [],
                  [8, 3, 0],
                  [9, 0, 1],
                  [8, 3, 1, 8, 1, 9],
                  [11, 2, 3],
                  [11, 2, 0, 11, 0, 8],
                  [11, 2, 3, 0, 1, 9],
                  [2, 1, 11, 1, 9, 11, 11, 9, 8],
                  [10, 1, 2],
                  [8, 3, 0, 1, 2, 10],
                  [9, 0, 2, 9, 2, 10],
                  [3, 2, 8, 2, 10, 8, 8, 10, 9],
                  [10, 1, 3, 10, 3, 11],
                  [1, 0, 10, 0, 8, 10, 10, 8, 11],
                  [0, 3, 9, 3, 11, 9, 9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [8, 4, 7],
                  [3, 0, 4, 3, 4, 7],
                  [1, 9, 0, 8, 4, 7],
                  [9, 4, 1, 4, 7, 1, 1, 7, 3],
                  [2, 3, 11, 7, 8, 4],
                  [7, 11, 4, 11, 2, 4, 4, 2, 0],
                  [3, 11, 2, 4, 7, 8, 9, 0, 1],
                  [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4],
                  [10, 1, 2, 8, 4, 7],
                  [2, 10, 1, 0, 4, 7, 0, 7, 3],
                  [4, 7, 8, 0, 2, 10, 0, 10, 9],
                  [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],
                  [8, 4, 7, 11, 10, 1, 11, 1, 3],
                  [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],
                  [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],
                  [7, 11, 4, 4, 11, 9, 11, 10, 9],
                  [9, 5, 4],
                  [3, 0, 8, 4, 9, 5],
                  [5, 4, 0, 5, 0, 1],
                  [4, 8, 5, 8, 3, 5, 5, 3, 1],
                  [11, 2, 3, 9, 5, 4],
                  [9, 5, 4, 8, 11, 2, 8, 2, 0],
                  [3, 11, 2, 1, 5, 4, 1, 4, 0],
                  [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5],
                  [2, 10, 1, 9, 5, 4],
                  [0, 8, 3, 5, 4, 9, 10, 1, 2],
                  [10, 5, 2, 5, 4, 2, 2, 4, 0],
                  [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],
                  [5, 4, 9, 1, 3, 11, 1, 11, 10],
                  [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],
                  [4, 8, 5, 5, 8, 10, 8, 11, 10],
                  [9, 5, 7, 9, 7, 8],
                  [0, 9, 3, 9, 5, 3, 3, 5, 7],
                  [8, 0, 7, 0, 1, 7, 7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [11, 2, 3, 8, 9, 5, 8, 5, 7],
                  [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],
                  [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],
                  [2, 1, 11, 11, 1, 7, 1, 5, 7],
                  [1, 2, 10, 5, 7, 8, 5, 8, 9],
                  [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],
                  [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],
                  [10, 5, 2, 2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [11, 7, 6],
                  [0, 8, 3, 11, 7, 6],
                  [9, 0, 1, 11, 7, 6],
                  [7, 6, 11, 3, 1, 9, 3, 9, 8],
                  [2, 3, 7, 2, 7, 6],
                  [8, 7, 0, 7, 6, 0, 0, 6, 2],
                  [1, 9, 0, 3, 7, 6, 3, 6, 2],
                  [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],
                  [1, 2, 10, 6, 11, 7],
                  [2, 10, 1, 7, 6, 11, 8, 3, 0],
                  [11, 7, 6, 10, 9, 0, 10, 0, 2],
                  [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],
                  [6, 10, 7, 10, 1, 7, 7, 1, 3],
                  [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],
                  [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],
                  [6, 10, 7, 7, 10, 8, 10, 9, 8],
                  [8, 4, 6, 8, 6, 11],
                  [11, 3, 6, 3, 0, 6, 6, 0, 4],
                  [0, 1, 9, 4, 6, 11, 4, 11, 8],
                  [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],
                  [3, 8, 2, 8, 4, 2, 2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6],
                  [9, 4, 1, 1, 4, 2, 4, 6, 2],
                  [10, 1, 2, 11, 8, 4, 11, 4, 6],
                  [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],
                  [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],
                  [1, 0, 10, 10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [9, 5, 4, 7, 6, 11],
                  [4, 9, 5, 3, 0, 8, 11, 7, 6],
                  [6, 11, 7, 4, 0, 1, 4, 1, 5],
                  [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1],
                  [4, 9, 5, 6, 2, 3, 6, 3, 7],
                  [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],
                  [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [6, 11, 7, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [5, 6, 9, 6, 11, 9, 9, 11, 8],
                  [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],
                  [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],
                  [11, 3, 6, 6, 3, 5, 3, 1, 5],
                  [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],
                  [5, 6, 9, 9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [10, 6, 5],
                  [8, 3, 0, 10, 6, 5],
                  [0, 1, 9, 5, 10, 6],
                  [10, 6, 5, 9, 8, 3, 9, 3, 1],
                  [3, 11, 2, 10, 6, 5],
                  [6, 5, 10, 2, 0, 8, 2, 8, 11],
                  [1, 9, 0, 6, 5, 10, 11, 2, 3],
                  [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11],
                  [1, 2, 6, 1, 6, 5],
                  [0, 8, 3, 2, 6, 5, 2, 5, 1],
                  [5, 9, 6, 9, 0, 6, 6, 0, 2],
                  [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6],
                  [11, 6, 3, 6, 5, 3, 3, 5, 1],
                  [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],
                  [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],
                  [5, 9, 6, 6, 9, 11, 9, 8, 11],
                  [10, 6, 5, 4, 7, 8],
                  [5, 10, 6, 7, 3, 0, 7, 0, 4],
                  [5, 10, 6, 0, 1, 9, 8, 4, 7],
                  [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],
                  [7, 8, 4, 2, 3, 11, 10, 6, 5],
                  [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [7, 8, 4, 5, 1, 2, 5, 2, 6],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [10, 6, 4, 10, 4, 9],
                  [8, 3, 0, 9, 10, 6, 9, 6, 4],
                  [1, 10, 0, 10, 6, 0, 0, 6, 4],
                  [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],
                  [2, 3, 11, 6, 4, 9, 6, 9, 10],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [9, 1, 4, 1, 2, 4, 4, 2, 6],
                  [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [3, 2, 8, 8, 2, 4, 2, 6, 4],
                  [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [11, 6, 3, 3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [6, 7, 10, 7, 8, 10, 10, 8, 9],
                  [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],
                  [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],
                  [6, 7, 10, 10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [8, 0, 7, 7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [11, 7, 5, 11, 5, 10],
                  [3, 0, 8, 7, 5, 10, 7, 10, 11],
                  [9, 0, 1, 10, 11, 7, 10, 7, 5],
                  [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],
                  [10, 2, 5, 2, 3, 5, 5, 3, 7],
                  [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],
                  [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [2, 11, 1, 11, 7, 1, 1, 7, 5],
                  [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],
                  [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [8, 7, 0, 0, 7, 1, 7, 5, 1],
                  [0, 3, 9, 9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [4, 5, 8, 5, 10, 8, 8, 10, 11],
                  [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],
                  [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],
                  [10, 2, 5, 5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [4, 5, 8, 8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [7, 4, 11, 4, 9, 11, 11, 9, 10],
                  [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],
                  [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [7, 4, 11, 11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [9, 1, 4, 4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [0, 9, 3, 3, 9, 11, 9, 10, 11],
                  [1, 10, 0, 0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [3, 8, 2, 2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [2, 11, 1, 1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ];
              }
              march(y, b, w, t) {
                let r = !!t.fulltable, u = t.hasOwnProperty("origin") && t.origin.hasOwnProperty("x") ? t.origin : { x: 0, y: 0, z: 0 }, o = !!t.voxel, l = t.matrix, e = t.nX || 0, n = t.nY || 0, a = t.nZ || 0, p = t.scale || 1, x = null;
                t.unitCube ? x = t.unitCube : x = { x: p, y: p, z: p };
                let D = new Int32Array(e * n * a), O, R;
                for (O = 0, R = D.length; O < R; ++O)
                  D[O] = -1;
                let z = function(k, F, U, V, H, G) {
                  let Y = { x: 0, y: 0, z: 0 }, J = !!(V & 1 << H), re = !!(V & 1 << G), le = H;
                  if (!J && re && (le = G), le & 1 && U++, le & 2 && F++, le & 4 && k++, l) {
                    let xe = new v.Vector3(k, F, U);
                    xe = xe.applyMatrix4(l), Y = { x: xe.x, y: xe.y, z: xe.z };
                  } else
                    Y.x = u.x + x.x * k, Y.y = u.y + x.y * F, Y.z = u.z + x.z * U;
                  let ie = (n * k + F) * a + U;
                  return o ? (b.push(Y), b.length - 1) : (D[ie] < 0 && (D[ie] = b.length, b.push(Y)), D[ie]);
                }, T = new Int32Array(12), B = r ? this.edgeTable2 : this.edgeTable, W = r ? this.triTable2 : this.triTable;
                for (O = 0; O < e - 1; ++O)
                  for (let k = 0; k < n - 1; ++k)
                    for (let F = 0; F < a - 1; ++F) {
                      let U = 0;
                      for (let G = 0; G < 8; ++G) {
                        let Y = (n * (O + ((G & 4) >> 2)) + k + ((G & 2) >> 1)) * a + F + (G & 1), J = !!(y[Y] & this.ISDONE);
                        U |= J << G;
                      }
                      if (U === 0 || U === 255)
                        continue;
                      let V = B[U];
                      if (V === 0)
                        continue;
                      let H = W[U];
                      V & 1 && (T[0] = z(O, k, F, U, 0, 1)), V & 2 && (T[1] = z(O, k, F, U, 1, 3)), V & 4 && (T[2] = z(O, k, F, U, 3, 2)), V & 8 && (T[3] = z(O, k, F, U, 2, 0)), V & 16 && (T[4] = z(O, k, F, U, 4, 5)), V & 32 && (T[5] = z(O, k, F, U, 5, 7)), V & 64 && (T[6] = z(O, k, F, U, 7, 6)), V & 128 && (T[7] = z(O, k, F, U, 6, 4)), V & 256 && (T[8] = z(O, k, F, U, 0, 4)), V & 512 && (T[9] = z(O, k, F, U, 1, 5)), V & 1024 && (T[10] = z(O, k, F, U, 3, 7)), V & 2048 && (T[11] = z(O, k, F, U, 2, 6));
                      for (let G = 0; G < H.length; G += 3) {
                        let Y = T[H[G]], J = T[H[G + 1]], re = T[H[G + 2]];
                        o && G >= 3 && (b.push(b[Y]), Y = b.length - 1, b.push(b[J]), J = b.length - 1, b.push(b[re]), re = b.length - 1), w.push(Y), w.push(J), w.push(re);
                      }
                    }
              }
              laplacianSmooth(y, b, w) {
                let t = new Array(b.length), r, u, o, l, e;
                for (r = 0, u = b.length; r < u; r++)
                  t[r] = {
                    x: 0,
                    y: 0,
                    z: 0
                  };
                let n = new Array(20), a;
                for (r = 0; r < 20; r++)
                  n[r] = new Array(b.length);
                for (r = 0, u = b.length; r < u; r++)
                  n[0][r] = 0;
                for (r = 0, u = w.length / 3; r < u; r++) {
                  let D = r * 3, O = r * 3 + 1, R = r * 3 + 2;
                  for (a = !0, o = 0, l = n[0][w[D]]; o < l; o++)
                    if (w[O] == n[o + 1][w[D]]) {
                      a = !1;
                      break;
                    }
                  for (a && (n[0][w[D]]++, n[n[0][w[D]]][w[D]] = w[O]), a = !0, o = 0, l = n[0][w[D]]; o < l; o++)
                    if (w[R] == n[o + 1][w[D]]) {
                      a = !1;
                      break;
                    }
                  for (a && (n[0][w[D]]++, n[n[0][w[D]]][w[D]] = w[R]), a = !0, o = 0, l = n[0][w[O]]; o < l; o++)
                    if (w[D] == n[o + 1][w[O]]) {
                      a = !1;
                      break;
                    }
                  for (a && (n[0][w[O]]++, n[n[0][w[O]]][w[O]] = w[D]), a = !0, o = 0, l = n[0][w[O]]; o < l; o++)
                    if (w[R] == n[o + 1][w[O]]) {
                      a = !1;
                      break;
                    }
                  for (a && (n[0][w[O]]++, n[n[0][w[O]]][w[O]] = w[R]), a = !0, o = 0; o < n[0][w[R]]; o++)
                    if (w[D] == n[o + 1][w[R]]) {
                      a = !1;
                      break;
                    }
                  for (a && (n[0][w[R]]++, n[n[0][w[R]]][w[R]] = w[D]), a = !0, o = 0, l = n[0][w[R]]; o < l; o++)
                    if (w[O] == n[o + 1][w[R]]) {
                      a = !1;
                      break;
                    }
                  a && (n[0][w[R]]++, n[n[0][w[R]]][w[R]] = w[O]);
                }
                let p = 1, x = 0.5;
                for (e = 0; e < y; e++) {
                  for (r = 0, u = b.length; r < u; r++)
                    if (n[0][r] < 3)
                      t[r].x = b[r].x, t[r].y = b[r].y, t[r].z = b[r].z;
                    else if (n[0][r] == 3 || n[0][r] == 4) {
                      for (t[r].x = 0, t[r].y = 0, t[r].z = 0, o = 0, l = n[0][r]; o < l; o++)
                        t[r].x += b[n[o + 1][r]].x, t[r].y += b[n[o + 1][r]].y, t[r].z += b[n[o + 1][r]].z;
                      t[r].x += x * b[r].x, t[r].y += x * b[r].y, t[r].z += x * b[r].z, t[r].x /= x + n[0][r], t[r].y /= x + n[0][r], t[r].z /= x + n[0][r];
                    } else {
                      for (t[r].x = 0, t[r].y = 0, t[r].z = 0, o = 0, l = n[0][r]; o < l; o++)
                        t[r].x += b[n[o + 1][r]].x, t[r].y += b[n[o + 1][r]].y, t[r].z += b[n[o + 1][r]].z;
                      t[r].x += p * b[r].x, t[r].y += p * b[r].y, t[r].z += p * b[r].z, t[r].x /= p + n[0][r], t[r].y /= p + n[0][r], t[r].z /= p + n[0][r];
                    }
                  for (r = 0, u = b.length; r < u; r++)
                    b[r].x = t[r].x, b[r].y = t[r].y, b[r].z = t[r].z;
                }
              }
            }
            let g = new h();
            class C {
              constructor(y, b, w) {
                this.data = new Int32Array(y * b * w * 3), this.width = b, this.height = w;
              }
              // set position x,y,z to pt, which has ix,iy,and iz
              set(y, b, w, t) {
                let r = ((y * this.width + b) * this.height + w) * 3;
                this.data[r] = t.ix, this.data[r + 1] = t.iy, this.data[r + 2] = t.iz;
              }
              // return point at x,y,z
              get(y, b, w) {
                let t = ((y * this.width + b) * this.height + w) * 3;
                return {
                  ix: this.data[t],
                  iy: this.data[t + 1],
                  iz: this.data[t + 2]
                };
              }
            }
            class c {
              constructor() {
                this.INOUT = 1, this.ISDONE = 2, this.ISBOUND = 4, this.ptranx = 0, this.ptrany = 0, this.ptranz = 0, this.probeRadius = 1.4, this.defaultScaleFactor = 2, this.scaleFactor = this.defaultScaleFactor, this.pHeight = 0, this.pWidth = 0, this.pLength = 0, this.cutRadius = 0, this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, this.pminx = 0, this.pminy = 0, this.pminz = 0, this.pmaxx = 0, this.pmaxy = 0, this.pmaxz = 0, this.depty = {}, this.widxz = {}, this.faces = [], this.verts = [], this.vdwRadii = {
                  H: 1.2,
                  Li: 1.82,
                  Na: 2.27,
                  K: 2.75,
                  C: 1.7,
                  N: 1.55,
                  O: 1.52,
                  F: 1.47,
                  P: 1.8,
                  S: 1.8,
                  CL: 1.75,
                  BR: 1.85,
                  SE: 1.9,
                  ZN: 1.39,
                  CU: 1.4,
                  NI: 1.63,
                  X: 2
                }, this.nb = [
                  new Int32Array([1, 0, 0]),
                  new Int32Array([-1, 0, 0]),
                  new Int32Array([0, 1, 0]),
                  new Int32Array([0, -1, 0]),
                  new Int32Array([0, 0, 1]),
                  new Int32Array([0, 0, -1]),
                  new Int32Array([1, 1, 0]),
                  new Int32Array([1, -1, 0]),
                  new Int32Array([-1, 1, 0]),
                  new Int32Array([-1, -1, 0]),
                  new Int32Array([1, 0, 1]),
                  new Int32Array([1, 0, -1]),
                  new Int32Array([-1, 0, 1]),
                  new Int32Array([-1, 0, -1]),
                  new Int32Array([0, 1, 1]),
                  new Int32Array([0, 1, -1]),
                  new Int32Array([0, -1, 1]),
                  new Int32Array([0, -1, -1]),
                  new Int32Array([1, 1, 1]),
                  new Int32Array([1, 1, -1]),
                  new Int32Array([1, -1, 1]),
                  new Int32Array([-1, 1, 1]),
                  new Int32Array([1, -1, -1]),
                  new Int32Array([-1, -1, 1]),
                  new Int32Array([-1, 1, -1]),
                  new Int32Array([-1, -1, -1])
                ], c.MarchingCube || (c.MarchingCube = new h());
              }
              getVDWIndex(y) {
                return !y.elem || typeof this.vdwRadii[y.elem] > "u" ? "X" : y.elem;
              }
              getFacesAndVertices(y) {
                let b = {};
                for (let r = 0, u = y.length; r < u; r++)
                  b[y[r]] = !0;
                let w = this.verts;
                for (let r = 0, u = w.length; r < u; r++)
                  w[r].x = w[r].x / this.scaleFactor - this.ptranx, w[r].y = w[r].y / this.scaleFactor - this.ptrany, w[r].z = w[r].z / this.scaleFactor - this.ptranz;
                let t = [];
                for (let r = 0, u = this.faces.length; r < u; r += 3) {
                  let o = this.faces[r], l = this.faces[r + 1], e = this.faces[r + 2], n = w[o].atomid, a = w[l].atomid, p = w[e].atomid, x = n;
                  a < x && (x = a), p < x && (x = p), b[x] && o !== l && l !== e && o !== e && (t.push(o), t.push(l), t.push(e));
                }
                return this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, {
                  vertices: w,
                  faces: t
                };
              }
              initparm(y, b, w) {
                w > 1e6 && (this.scaleFactor = this.defaultScaleFactor / 2);
                let t = 1 / this.scaleFactor * 5.5;
                this.pminx = y[0][0], this.pmaxx = y[1][0], this.pminy = y[0][1], this.pmaxy = y[1][1], this.pminz = y[0][2], this.pmaxz = y[1][2], b ? (this.pminx -= this.probeRadius + t, this.pminy -= this.probeRadius + t, this.pminz -= this.probeRadius + t, this.pmaxx += this.probeRadius + t, this.pmaxy += this.probeRadius + t, this.pmaxz += this.probeRadius + t) : (this.pminx -= t, this.pminy -= t, this.pminz -= t, this.pmaxx += t, this.pmaxy += t, this.pmaxz += t), this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor, this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor, this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor, this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor, this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor, this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor, this.ptranx = -this.pminx, this.ptrany = -this.pminy, this.ptranz = -this.pminz, this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1, this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1, this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1, this.boundingatom(b), this.cutRadius = this.probeRadius * this.scaleFactor, this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight), this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight), this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);
              }
              boundingatom(y) {
                let b = {};
                for (const w in this.vdwRadii) {
                  let t = this.vdwRadii[w];
                  y ? b[w] = (t + this.probeRadius) * this.scaleFactor + 0.5 : b[w] = t * this.scaleFactor + 0.5;
                  let r = b[w] * b[w];
                  this.widxz[w] = Math.floor(b[w]) + 1, this.depty[w] = new Int32Array(this.widxz[w] * this.widxz[w]);
                  let u = 0;
                  for (let o = 0; o < this.widxz[w]; o++)
                    for (let l = 0; l < this.widxz[w]; l++) {
                      let e = o * o + l * l;
                      if (e > r)
                        this.depty[w][u] = -1;
                      else {
                        let n = Math.sqrt(r - e);
                        this.depty[w][u] = Math.floor(n);
                      }
                      u++;
                    }
                }
              }
              fillvoxels(y, b) {
                for (let w = 0, t = this.vpBits.length; w < t; w++)
                  this.vpBits[w] = 0, this.vpDistance[w] = -1, this.vpAtomID[w] = -1;
                for (let w in b) {
                  let t = y[b[w]];
                  t !== void 0 && this.fillAtom(t, y);
                }
                for (let w = 0, t = this.vpBits.length; w < t; w++)
                  this.vpBits[w] & this.INOUT && (this.vpBits[w] |= this.ISDONE);
              }
              fillAtom(y, b) {
                let w = Math.floor(0.5 + this.scaleFactor * (y.x + this.ptranx)), t = Math.floor(0.5 + this.scaleFactor * (y.y + this.ptrany)), r = Math.floor(0.5 + this.scaleFactor * (y.z + this.ptranz)), u = this.getVDWIndex(y), o = 0, l = this.pWidth * this.pHeight;
                for (let e = 0, n = this.widxz[u]; e < n; e++)
                  for (let a = 0; a < n; a++) {
                    if (this.depty[u][o] != -1) {
                      for (let p = -1; p < 2; p++)
                        for (let x = -1; x < 2; x++)
                          for (let D = -1; D < 2; D++)
                            if (p !== 0 && x !== 0 && D !== 0) {
                              let O = p * e, R = D * a;
                              for (let z = 0; z <= this.depty[u][o]; z++) {
                                let T = z * x, B = w + O, W = t + T, k = r + R;
                                if (B < 0 || W < 0 || k < 0 || B >= this.pLength || W >= this.pWidth || k >= this.pHeight)
                                  continue;
                                let F = B * l + W * this.pHeight + k;
                                if (!(this.vpBits[F] & this.INOUT))
                                  this.vpBits[F] |= this.INOUT, this.vpAtomID[F] = y.serial;
                                else {
                                  let U = b[this.vpAtomID[F]];
                                  if (U.serial != y.serial) {
                                    let V = w + O - Math.floor(0.5 + this.scaleFactor * (U.x + this.ptranx)), H = t + T - Math.floor(0.5 + this.scaleFactor * (U.y + this.ptrany)), G = r + R - Math.floor(0.5 + this.scaleFactor * (U.z + this.ptranz));
                                    O * O + T * T + R * R < V * V + H * H + G * G && (this.vpAtomID[F] = y.serial);
                                  }
                                }
                              }
                            }
                    }
                    o++;
                  }
              }
              fillvoxelswaals(y, b) {
                for (let w = 0, t = this.vpBits.length; w < t; w++)
                  this.vpBits[w] &= ~this.ISDONE;
                for (let w in b) {
                  let t = y[b[w]];
                  t !== void 0 && this.fillAtomWaals(t, y);
                }
              }
              fillAtomWaals(y, b) {
                let w = 0, t = Math.floor(0.5 + this.scaleFactor * (y.x + this.ptranx)), r = Math.floor(0.5 + this.scaleFactor * (y.y + this.ptrany)), u = Math.floor(0.5 + this.scaleFactor * (y.z + this.ptranz)), o = this.getVDWIndex(y), l = this.pWidth * this.pHeight;
                for (let e = 0, n = this.widxz[o]; e < n; e++)
                  for (let a = 0; a < n; a++) {
                    if (this.depty[o][w] != -1) {
                      for (let p = -1; p < 2; p++)
                        for (let x = -1; x < 2; x++)
                          for (let D = -1; D < 2; D++)
                            if (p !== 0 && x !== 0 && D !== 0) {
                              let O = p * e, R = D * a;
                              for (let z = 0; z <= this.depty[o][w]; z++) {
                                let T = z * x, B = t + O, W = r + T, k = u + R;
                                if (B < 0 || W < 0 || k < 0 || B >= this.pLength || W >= this.pWidth || k >= this.pHeight)
                                  continue;
                                let F = B * l + W * this.pHeight + k;
                                if (!(this.vpBits[F] & this.ISDONE))
                                  this.vpBits[F] |= this.ISDONE, this.vpAtomID[F] = y.serial;
                                else {
                                  let U = b[this.vpAtomID[F]];
                                  if (U.serial != y.serial) {
                                    let V = t + O - Math.floor(0.5 + this.scaleFactor * (U.x + this.ptranx)), H = r + T - Math.floor(0.5 + this.scaleFactor * (U.y + this.ptrany)), G = u + R - Math.floor(0.5 + this.scaleFactor * (U.z + this.ptranz));
                                    O * O + T * T + R * R < V * V + H * H + G * G && (this.vpAtomID[F] = y.serial);
                                  }
                                }
                              }
                            }
                    }
                    w++;
                  }
              }
              buildboundary() {
                let y = this.pWidth * this.pHeight;
                for (let b = 0; b < this.pLength; b++)
                  for (let w = 0; w < this.pHeight; w++)
                    for (let t = 0; t < this.pWidth; t++) {
                      let r = b * y + t * this.pHeight + w;
                      if (this.vpBits[r] & this.INOUT) {
                        let u = 0;
                        for (; u < 26; ) {
                          let o = b + this.nb[u][0], l = w + this.nb[u][2], e = t + this.nb[u][1];
                          if (o > -1 && o < this.pLength && e > -1 && e < this.pWidth && l > -1 && l < this.pHeight && !(this.vpBits[o * y + e * this.pHeight + l] & this.INOUT)) {
                            this.vpBits[r] |= this.ISBOUND;
                            break;
                          } else
                            u++;
                        }
                      }
                    }
              }
              fastdistancemap() {
                let y = new C(this.pLength, this.pWidth, this.pHeight), b = this.pWidth * this.pHeight, w = this.cutRadius * this.cutRadius, t = [], r = [], u;
                for (let e = 0; e < this.pLength; e++)
                  for (let n = 0; n < this.pWidth; n++)
                    for (let a = 0; a < this.pHeight; a++)
                      if (u = e * b + n * this.pHeight + a, this.vpBits[u] &= ~this.ISDONE, this.vpBits[u] & this.INOUT && this.vpBits[u] & this.ISBOUND) {
                        let p = {
                          ix: e,
                          iy: n,
                          iz: a
                        };
                        y.set(e, n, a, p), t.push(p), this.vpDistance[u] = 0, this.vpBits[u] |= this.ISDONE, this.vpBits[u] &= ~this.ISBOUND;
                      }
                do {
                  r = this.fastoneshell(t, y), t = [];
                  for (let e = 0, n = r.length; e < n; e++)
                    u = b * r[e].ix + this.pHeight * r[e].iy + r[e].iz, this.vpBits[u] &= ~this.ISBOUND, this.vpDistance[u] <= 1.0404 * w && t.push({
                      ix: r[e].ix,
                      iy: r[e].iy,
                      iz: r[e].iz
                    });
                } while (t.length !== 0);
                t = [], r = [], y = null;
                let o = this.scaleFactor - 0.5;
                o < 0 && (o = 0);
                let l = w - 0.5 / (0.1 + o);
                for (let e = 0; e < this.pLength; e++)
                  for (let n = 0; n < this.pWidth; n++)
                    for (let a = 0; a < this.pHeight; a++)
                      u = e * b + n * this.pHeight + a, this.vpBits[u] &= ~this.ISBOUND, this.vpBits[u] & this.INOUT && (!(this.vpBits[u] & this.ISDONE) || this.vpBits[u] & this.ISDONE && this.vpDistance[u] >= l) && (this.vpBits[u] |= this.ISBOUND);
              }
              fastoneshell(y, b) {
                let w, t, r, u, o, l, e, n, a, p = [];
                if (y.length === 0)
                  return p;
                let x = {
                  ix: -1,
                  iy: -1,
                  iz: -1
                }, D = this.pWidth * this.pHeight;
                for (let O = 0, R = y.length; O < R; O++) {
                  w = y[O].ix, t = y[O].iy, r = y[O].iz, n = b.get(w, t, r);
                  for (let z = 0; z < 6; z++)
                    x.ix = w + this.nb[z][0], x.iy = t + this.nb[z][1], x.iz = r + this.nb[z][2], x.ix < this.pLength && x.ix > -1 && x.iy < this.pWidth && x.iy > -1 && x.iz < this.pHeight && x.iz > -1 && (a = x.ix * D + this.pHeight * x.iy + x.iz, this.vpBits[a] & this.INOUT && !(this.vpBits[a] & this.ISDONE) ? (b.set(x.ix, x.iy, r + this.nb[z][2], n), u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, this.vpDistance[a] = e, this.vpBits[a] |= this.ISDONE, this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })) : this.vpBits[a] & this.INOUT && this.vpBits[a] & this.ISDONE && (u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, e < this.vpDistance[a] && (b.set(x.ix, x.iy, x.iz, n), this.vpDistance[a] = e, this.vpBits[a] & this.ISBOUND || (this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })))));
                }
                for (let O = 0, R = y.length; O < R; O++) {
                  w = y[O].ix, t = y[O].iy, r = y[O].iz, n = b.get(w, t, r);
                  for (let z = 6; z < 18; z++)
                    x.ix = w + this.nb[z][0], x.iy = t + this.nb[z][1], x.iz = r + this.nb[z][2], x.ix < this.pLength && x.ix > -1 && x.iy < this.pWidth && x.iy > -1 && x.iz < this.pHeight && x.iz > -1 && (a = x.ix * D + this.pHeight * x.iy + x.iz, this.vpBits[a] & this.INOUT && !(this.vpBits[a] & this.ISDONE) ? (b.set(x.ix, x.iy, r + this.nb[z][2], n), u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, this.vpDistance[a] = e, this.vpBits[a] |= this.ISDONE, this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })) : this.vpBits[a] & this.INOUT && this.vpBits[a] & this.ISDONE && (u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, e < this.vpDistance[a] && (b.set(x.ix, x.iy, x.iz, n), this.vpDistance[a] = e, this.vpBits[a] & this.ISBOUND || (this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })))));
                }
                for (let O = 0, R = y.length; O < R; O++) {
                  w = y[O].ix, t = y[O].iy, r = y[O].iz, n = b.get(w, t, r);
                  for (let z = 18; z < 26; z++)
                    x.ix = w + this.nb[z][0], x.iy = t + this.nb[z][1], x.iz = r + this.nb[z][2], x.ix < this.pLength && x.ix > -1 && x.iy < this.pWidth && x.iy > -1 && x.iz < this.pHeight && x.iz > -1 && (a = x.ix * D + this.pHeight * x.iy + x.iz, this.vpBits[a] & this.INOUT && !(this.vpBits[a] & this.ISDONE) ? (b.set(x.ix, x.iy, r + this.nb[z][2], n), u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, this.vpDistance[a] = e, this.vpBits[a] |= this.ISDONE, this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })) : this.vpBits[a] & this.INOUT && this.vpBits[a] & this.ISDONE && (u = x.ix - n.ix, o = x.iy - n.iy, l = x.iz - n.iz, e = u * u + o * o + l * l, e < this.vpDistance[a] && (b.set(x.ix, x.iy, x.iz, n), this.vpDistance[a] = e, this.vpBits[a] & this.ISBOUND || (this.vpBits[a] |= this.ISBOUND, p.push({
                      ix: x.ix,
                      iy: x.iy,
                      iz: x.iz
                    })))));
                }
                return p;
              }
              marchingcubeinit(y) {
                for (let b = 0, w = this.vpBits.length; b < w; b++)
                  y == 1 ? this.vpBits[b] &= ~this.ISBOUND : y == 4 ? (this.vpBits[b] &= ~this.ISDONE, this.vpBits[b] & this.ISBOUND && (this.vpBits[b] |= this.ISDONE), this.vpBits[b] &= ~this.ISBOUND) : y == 2 ? this.vpBits[b] & this.ISBOUND && this.vpBits[b] & this.ISDONE ? this.vpBits[b] &= ~this.ISBOUND : this.vpBits[b] & this.ISBOUND && !(this.vpBits[b] & this.ISDONE) && (this.vpBits[b] |= this.ISDONE) : y == 3 && (this.vpBits[b] &= ~this.ISBOUND);
              }
              marchingcube(y) {
                this.marchingcubeinit(y), this.verts = [], this.faces = [], c.MarchingCube.march(this.vpBits, this.verts, this.faces, {
                  smooth: 1,
                  nX: this.pLength,
                  nY: this.pWidth,
                  nZ: this.pHeight
                });
                let b = this.pWidth * this.pHeight;
                for (let w = 0, t = this.verts.length; w < t; w++)
                  this.verts[w].atomid = this.vpAtomID[this.verts[w].x * b + this.pHeight * this.verts[w].y + this.verts[w].z];
                c.MarchingCube.laplacianSmooth(1, this.verts, this.faces);
              }
            }
            c.MarchingCube = new h();
          }
        ),
        /***/
        "./src/VolumeData.ts": (
          /*!***************************!*\
            !*** ./src/VolumeData.ts ***!
            \***************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              VolumeData: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utilities */
              "./src/utilities.ts"
            ), M = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), E = s(
              /*! ./parsers/VASP */
              "./src/parsers/VASP.ts"
            ), A = s(
              /*! ./parsers/CUBE */
              "./src/parsers/CUBE.ts"
            ), h = s(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            );
            class g {
              constructor(c, S, y) {
                if (this.unit = {
                  x: 1,
                  y: 1,
                  z: 1
                }, this.origin = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.size = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.data = new Float32Array([]), this.matrix = null, this.inversematrix = null, this.isbinary = /* @__PURE__ */ new Set(["ccp4", "CCP4"]), this.getCoordinates = function(u) {
                  var o = u / (this.size.y * this.size.z), l = u % (this.size.y * this.size.z), e = u % this.size.z;
                  return o *= this.unit.x, l *= this.unit.y, e *= this.unit.z, o += this.origin.x, l += this.origin.y, e += this.origin.z, { x: o, y: l, z: e };
                }, this.vasp = function(u) {
                  var o = u.replace(/^\s+/, "").split(/[\n\r]/), l = (0, E.VASP)(u)[0], e = l.length;
                  if (e == 0) {
                    console.log("No good formating of CHG or CHGCAR file, not atomic information provided in the file."), this.data = [];
                    return;
                  }
                  var n = 1.889725992, a = 0.036749309, p = parseFloat(o[1]), x;
                  x = o[2].replace(/^\s+/, "").split(/\s+/);
                  var D = new M.Vector3(parseFloat(x[0]), parseFloat(x[1]), parseFloat(x[2])).multiplyScalar(p * n);
                  x = o[3].replace(/^\s+/, "").split(/\s+/);
                  var O = new M.Vector3(parseFloat(x[0]), parseFloat(x[1]), parseFloat(x[2])).multiplyScalar(p * n);
                  x = o[4].replace(/^\s+/, "").split(/\s+/);
                  var R = new M.Vector3(parseFloat(x[0]), parseFloat(x[1]), parseFloat(x[2])).multiplyScalar(p * n), z = D.x * (O.y * R.z - R.y * O.z) - O.x * (D.y * R.z - R.y * D.z) + R.x * (D.y * O.z - O.y * D.z);
                  z = Math.abs(z) / Math.pow(n, 3);
                  var T = 1 / z;
                  o.splice(0, 8 + e + 1);
                  var B = o[0].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), W = Math.abs(parseFloat(B[0])), k = Math.abs(parseFloat(B[1])), F = Math.abs(parseFloat(B[2])), U = this.origin = new M.Vector3(0, 0, 0);
                  this.size = { x: W, y: k, z: F }, this.unit = new M.Vector3(D.x, O.y, R.z), D = D.multiplyScalar(1 / (n * W)), O = O.multiplyScalar(1 / (n * k)), R = R.multiplyScalar(1 / (n * F)), (D.y != 0 || D.z != 0 || O.x != 0 || O.z != 0 || R.x != 0 || R.y != 0) && (this.matrix = new M.Matrix4(D.x, O.x, R.x, 0, D.y, O.y, R.y, 0, D.z, O.z, R.z, 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new M.Matrix4().makeTranslation(U.x, U.y, U.z)), this.origin = new M.Vector3(0, 0, 0), this.unit = new M.Vector3(1, 1, 1)), o.splice(0, 1);
                  var V = o.join(" ");
                  V = V.replace(/^\s+/, "");
                  var H = V.split(/[\s\r]+/);
                  H.splice(W * k * F + 1);
                  for (var G = Float32Array.from(H, parseFloat), Y = 0; Y < G.length; Y++)
                    G[Y] = G[Y] * T * a;
                  this.data = G;
                }, this.dx = function(u) {
                  var o = u.split(/[\n\r]+/), l, e = /gridpositions\s+counts\s+(\d+)\s+(\d+)\s+(\d+)/, n = /^origin\s+(\S+)\s+(\S+)\s+(\S+)/, a = /^delta\s+(\S+)\s+(\S+)\s+(\S+)/, p = /data follows/, x = 0;
                  for (x = 0; x < o.length; x++) {
                    var D = o[x];
                    if (l = e.exec(D)) {
                      var O = parseInt(l[1]), R = parseInt(l[2]), z = parseInt(l[3]);
                      this.size = { x: O, y: R, z };
                    } else if (l = a.exec(D)) {
                      var T = parseFloat(l[1]);
                      if ((parseFloat(l[2]) != 0 || parseFloat(l[3]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), x += 1, D = o[x], l = a.exec(D), l == null) {
                        console.log("Parse error in dx delta matrix");
                        return;
                      }
                      var B = parseFloat(l[2]);
                      if ((parseFloat(l[1]) != 0 || parseFloat(l[3]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), x += 1, D = o[x], l = a.exec(D), l == null) {
                        console.log("Parse error in dx delta matrix");
                        return;
                      }
                      var W = parseFloat(l[3]);
                      (parseFloat(l[1]) != 0 || parseFloat(l[2]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), this.unit = new M.Vector3(T, B, W);
                    } else if (l = n.exec(D)) {
                      var k = parseFloat(l[1]), F = parseFloat(l[2]), U = parseFloat(l[3]);
                      this.origin = new M.Vector3(k, F, U);
                    } else if (l = p.exec(D))
                      break;
                  }
                  if (x += 1, !this.size || !this.origin || !this.unit || !this.size) {
                    console.log("Error parsing dx format");
                    return;
                  }
                  var V = o.splice(x).join(" "), H = V.split(/[\s\r]+/);
                  this.data = Float32Array.from(H, parseFloat);
                }, S = S.toLowerCase(), /\.gz$/.test(S)) {
                  S = S.replace(/\.gz$/, "");
                  try {
                    this[S] && this.isbinary.has(S) ? (typeof c == "string" && (c = (0, v.base64ToArray)(c)), c = (0, h.inflate)(c)) : c = new TextDecoder("utf-8").decode((0, h.inflate)(c));
                  } catch (u) {
                    console.log(u);
                  }
                }
                if (this[S] && (this.isbinary.has(S) && typeof c == "string" && (c = (0, v.base64ToArray)(c)), this[S](c)), y) {
                  if (y.negate)
                    for (let u = 0, o = this.data.length; u < o; u++)
                      this.data[u] = -this.data[u];
                  if (y.normalize) {
                    var b = 0;
                    for (let u = 0, o = this.data.length; u < o; u++)
                      b += this.data[u];
                    var w = b / this.data.length;
                    b = 0;
                    for (let u = 0, o = this.data.length; u < o; u++) {
                      var t = this.data[u] - w;
                      b += t * t;
                    }
                    var r = b / this.data.length;
                    for (let u = 0, o = this.data.length; u < o; u++)
                      this.data[u] = (this.data[u] - w) / r;
                  }
                }
              }
              /**
               * @function $3Dmol.VolumeData.getIndex
               * @param {number} x,y,z - the coordinates
               * @returns - index into flat array closest to provided coordinate; -1 if invalid
               */
              getIndex(c, S, y) {
                if (this.matrix) {
                  this.inversematrix == null && (this.inversematrix = new M.Matrix4().getInverse(this.matrix));
                  var b = new M.Vector3(c, S, y);
                  b = b.applyMatrix4(this.inversematrix), c = b.x, S = b.y, y = b.z;
                } else
                  c -= this.origin.x, S -= this.origin.y, y -= this.origin.z, c /= this.unit.x, S /= this.unit.y, y /= this.unit.z;
                return c = Math.round(c), S = Math.round(S), y = Math.round(y), c < 0 || c >= this.size.x || S < 0 || S >= this.size.y || y < 0 || y >= this.size.z ? -1 : c * this.size.y * this.size.z + S * this.size.z + y;
              }
              /**
               * @function $3Dmol.VolumeData.getVal
               * @param {number} x,y,z - the coordinates
               * @returns - value closest to provided coordinate; zero if coordinate invalid
               */
              getVal(c, S, y) {
                let b = this.getIndex(c, S, y);
                return b < 0 ? 0 : this.data[b];
              }
              // parse cube data
              cube(c) {
                var S = c.split(/\r?\n/);
                if (!(S.length < 6)) {
                  var y = (0, A.CUBE)(c, {}).modelData[0].cryst, b = S[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), w = parseFloat(b[0]), t = Math.abs(w);
                  this.origin = y.origin, this.size = y.size, this.unit = y.unit, this.matrix = y.matrix4;
                  var r = 6;
                  w < 0 && r++;
                  var u = S.splice(t + r).join(" ");
                  u = u.replace(/^\s+/, "");
                  var o = u.split(/[\s\r]+/);
                  this.data = Float32Array.from(o, parseFloat);
                }
              }
              //parse cp4 files
              ccp4(c) {
                var S = {};
                c = new Int8Array(c);
                var y = new Int32Array(c.buffer, 0, 56), b = new Float32Array(c.buffer, 0, 56), w = new DataView(c.buffer);
                if (S.MAP = String.fromCharCode(w.getUint8(208), w.getUint8(209), w.getUint8(210), w.getUint8(211)), S.MACHST = [w.getUint8(212), w.getUint8(213)], S.MACHST[0] === 17 && S.MACHST[1] === 17)
                  for (var t = c.byteLength, r = 0; r < t; r += 4)
                    w.setFloat32(r, w.getFloat32(r), !0);
                S.NX = y[0], S.NY = y[1], S.NZ = y[2], S.MODE = y[3], S.NXSTART = y[4], S.NYSTART = y[5], S.NZSTART = y[6], S.MX = y[7], S.MY = y[8], S.MZ = y[9], S.xlen = b[10], S.ylen = b[11], S.zlen = b[12], S.alpha = b[13], S.beta = b[14], S.gamma = b[15], S.MAPC = y[16], S.MAPR = y[17], S.MAPS = y[18], S.DMIN = b[19], S.DMAX = b[20], S.DMEAN = b[21], S.ISPG = y[22], S.NSYMBT = y[23], S.LSKFLG = y[24], S.originX = b[49], S.originY = b[50], S.originZ = b[51], S.ARMS = b[54];
                var u = S, o = [
                  u.xlen,
                  0,
                  0
                ], l = [
                  u.ylen * Math.cos(Math.PI / 180 * u.gamma),
                  u.ylen * Math.sin(Math.PI / 180 * u.gamma),
                  0
                ], e = [
                  u.zlen * Math.cos(Math.PI / 180 * u.beta),
                  u.zlen * (Math.cos(Math.PI / 180 * u.alpha) - Math.cos(Math.PI / 180 * u.gamma) * Math.cos(Math.PI / 180 * u.beta)) / Math.sin(Math.PI / 180 * u.gamma),
                  0
                ];
                e[2] = Math.sqrt(u.zlen * u.zlen * Math.sin(Math.PI / 180 * u.beta) * Math.sin(Math.PI / 180 * u.beta) - e[1] * e[1]);
                var n = [0, o, l, e], a = [0, u.MX, u.MY, u.MZ], p = [0, u.MAPC, u.MAPR, u.MAPS];
                this.matrix = new M.Matrix4(), this.matrix.set(n[p[1]][0] / a[p[1]], n[p[2]][0] / a[p[2]], n[p[3]][0] / a[p[3]], 0, n[p[1]][1] / a[p[1]], n[p[2]][1] / a[p[2]], n[p[3]][1] / a[p[3]], 0, n[p[1]][2] / a[p[1]], n[p[2]][2] / a[p[2]], n[p[3]][2] / a[p[3]], 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new M.Matrix4().makeTranslation(u.NXSTART + u.originX, u.NYSTART + u.originY, u.NZSTART + u.originZ)), this.origin = new M.Vector3(0, 0, 0), this.unit = new M.Vector3(1, 1, 1), this.size = { x: S.NX, y: S.NY, z: S.NZ }, this.dimensionorder = [S.MAPC, S.MAPR, S.MAPS];
                var x = new Float32Array(c.buffer, 1024 + S.NSYMBT), D = S.NX, O = S.NY, R = S.NZ;
                this.data = new Float32Array(D * O * R);
                for (let z = 0; z < D; z++)
                  for (let T = 0; T < O; T++)
                    for (let B = 0; B < R; B++)
                      this.data[(z * O + T) * R + B] = x[(B * O + T) * D + z];
              }
            }
          }
        ),
        /***/
        "./src/VolumetricRender.ts": (
          /*!*********************************!*\
            !*** ./src/VolumetricRender.ts ***!
            \*********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              GLVolumetricRender: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), M = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), E = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), A = s(
              /*! ./colors */
              "./src/colors.ts"
            ), h = s(
              /*! ./GLShape */
              "./src/GLShape.ts"
            );
            class g {
              static interpolateArray(c, S) {
                function y(e, n, a) {
                  return e + (n - e) * a;
                }
                var b = [], w = (c.length - 1) / (S - 1);
                b[0] = c[0];
                for (var t = 1; t < S - 1; t++) {
                  var r = t * w, u = Math.floor(r), o = Math.ceil(r), l = r - u;
                  b[t] = y(c[u], c[o], l);
                }
                return b[S - 1] = c[c.length - 1], b;
              }
              constructor(c, S) {
                this.hidden = !1, this.boundingSphere = new v.Sphere(), this.renderedShapeObj = null, this.shapeObj = null, this.subsamples = 5, this.data = null, this.transferfunctionbuffer = [], this.min = 0, this.max = 0, S = S || {};
                var y = Object.assign([], S.transferfn);
                this.subsamples = S.subsamples || 5;
                let b = 256;
                y.forEach(function(D) {
                  D.value = parseFloat(D.value);
                }), y.sort(function(D, O) {
                  return D.value - O.value;
                }), this.min = y[0].value, y.length == 0 && y.push(y[0]), this.max = y[y.length - 1].value;
                var w, t, r, u, o, l, e, n, a, p;
                for (let D = 0; D < y.length - 1; D++)
                  if (r = A.CC.color(y[D].color), u = A.CC.color(y[D + 1].color), a = y[D].opacity, p = y[D + 1].opacity, w = Math.floor((y[D].value - this.min) * b / (this.max - this.min)), t = Math.floor((y[D + 1].value - this.min) * b / (this.max - this.min)), w != t) {
                    o = g.interpolateArray([r.r * 255, u.r * 255], t - w), l = g.interpolateArray([r.g * 255, u.g * 255], t - w), e = g.interpolateArray([r.b * 255, u.b * 255], t - w), n = g.interpolateArray([a * 255, p * 255], t - w);
                    for (let O = 0; O < o.length; O++)
                      this.transferfunctionbuffer.push(o[O]), this.transferfunctionbuffer.push(l[O]), this.transferfunctionbuffer.push(e[O]), this.transferfunctionbuffer.push(n[O]);
                  }
                if (this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer), c.matrix) {
                  let D = new M.Vector3(0, 0, 0), O = new M.Vector3(c.size.x, c.size.y, c.size.z), R = new M.Vector3(1, 1, 1);
                  D.applyMatrix4(c.matrix), O.applyMatrix4(c.matrix), R.applyMatrix4(c.matrix).sub(D), this.extent = [[D.x, D.y, D.z], [O.x, O.y, O.z]];
                  for (let W = 1; W < 7; W++)
                    O.x = W & 1 ? c.size.x : 0, O.y = W & 2 ? c.size.y : 0, O.z = W & 4 ? c.size.z : 0, O.applyMatrix4(c.matrix), this.extent[0][0] = Math.min(this.extent[0][0], O.x), this.extent[0][1] = Math.min(this.extent[0][1], O.y), this.extent[0][2] = Math.min(this.extent[0][2], O.z), this.extent[1][0] = Math.max(this.extent[1][0], O.x), this.extent[1][1] = Math.max(this.extent[1][1], O.y), this.extent[1][2] = Math.max(this.extent[1][2], O.z);
                  let z = O.x - D.x, T = O.y - D.y, B = O.z - D.z;
                  this.maxdepth = Math.sqrt(z * z + T * T + B * B), this.minunit = Math.min(Math.min(R.x, R.y), R.z), this.texmatrix = new M.Matrix4().identity().scale({ x: c.size.x, y: c.size.y, z: c.size.z }), this.texmatrix = this.texmatrix.multiplyMatrices(c.matrix, this.texmatrix), this.texmatrix = this.texmatrix.getInverse(this.texmatrix);
                } else {
                  this.texmatrix = new M.Matrix4().identity();
                  let D = c.unit.x * c.size.x, O = c.unit.y * c.size.y, R = c.unit.z * c.size.z;
                  this.texmatrix.makeTranslation(-c.origin.x / D, -c.origin.y / O, -c.origin.z / R), this.texmatrix.scale({ x: 1 / D, y: 1 / O, z: 1 / R }), this.minunit = Math.min(Math.min(c.unit.x, c.unit.y), c.unit.z), this.extent = [
                    [c.origin.x, c.origin.y, c.origin.z],
                    [c.origin.x + D, c.origin.y + O, c.origin.z + R]
                  ], this.maxdepth = Math.sqrt(D * D + O * O + R * R);
                }
                var x = new h.GLShape({});
                if (x.addBox({
                  corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },
                  dimensions: {
                    w: this.extent[1][0] - this.extent[0][0],
                    h: this.extent[1][1] - this.extent[0][1],
                    d: this.extent[1][2] - this.extent[0][2]
                  }
                }), this.geo = x.finalize(), this.boundingSphere.center = new M.Vector3((this.extent[0][0] + this.extent[1][0]) / 2, (this.extent[0][1] + this.extent[1][1]) / 2, (this.extent[0][2] + this.extent[1][2]) / 2), this.boundingSphere.radius = this.maxdepth / 2, S.coords !== void 0 && S.seldist !== void 0) {
                  let D = new Uint8Array(c.data.length), O = S.seldist, R = O * O;
                  for (let z = 0, T = S.coords.length; z < T; z++) {
                    let B = S.coords[z], W = B.x - O, k = B.y - O, F = B.z - O, U = B.x + O, V = B.y + O, H = B.z + O;
                    if (c.getIndex(W, k, F) >= 0 || c.getIndex(U, V, H) >= 0)
                      for (let G = W; G < U; G += this.minunit)
                        for (let Y = k; Y < V; Y += this.minunit)
                          for (let J = F; J < H; J += this.minunit) {
                            let re = c.getIndex(G, Y, J);
                            re >= 0 && !D[re] && (G - B.x) * (G - B.x) + (Y - B.y) * (Y - B.y) + (J - B.z) * (J - B.z) < R && (D[re] = 1);
                          }
                  }
                  for (let z = 0, T = c.data.length; z < T; z++)
                    D[z] == 0 && (c.data[z] = 1 / 0);
                }
                this.data = c;
              }
              /**
               * Initialize webgl objects for rendering
               * @param {Object3D} group
               *
               */
              globj(c) {
                if (this.renderedShapeObj && (c.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  this.shapeObj = new E.Object3D();
                  var S = null, y = new E.Texture(this.data, !0), b = new E.Texture(this.transferfunctionbuffer, !1);
                  y.needsUpdate = !0, b.needsUpdate = !0, b.flipY = !1, S = new E.VolumetricMaterial({
                    transferfn: b,
                    transfermin: this.min,
                    transfermax: this.max,
                    map: y,
                    extent: this.extent,
                    maxdepth: this.maxdepth,
                    texmatrix: this.texmatrix,
                    unit: this.minunit,
                    subsamples: this.subsamples
                  });
                  var w = new E.Mesh(this.geo, S);
                  this.shapeObj.add(w), this.renderedShapeObj = this.shapeObj.clone(), c.add(this.renderedShapeObj);
                }
              }
              removegl(c) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), c.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Camera.ts": (
          /*!*****************************!*\
            !*** ./src/WebGL/Camera.ts ***!
            \*****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Camera: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), M = s(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            );
            class E extends v.Object3D {
              constructor(h = 50, g = 1, C = 0.1, c = 2e3, S = !1) {
                super(), this.projectionMatrix = new M.Matrix4(), this.projectionMatrixInverse = new M.Matrix4(), this.matrixWorldInverse = new M.Matrix4(), this.fov = h, this.aspect = g, this.near = C, this.far = c;
                var y = this.position.z;
                this.right = y * Math.tan(Math.PI / 180 * h), this.left = -this.right, this.top = this.right / this.aspect, this.bottom = -this.top, this.ortho = !!S, this.updateProjectionMatrix();
              }
              lookAt(h) {
                this.matrix.lookAt(this.position, h, this.up), this.rotationAutoUpdate && (this.useQuaternion === !1 && this.rotation instanceof M.Vector3 ? this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : console.error("Unimplemented math operation."));
              }
              updateProjectionMatrix() {
                this.ortho ? this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far) : this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Fog.ts": (
          /*!**************************!*\
            !*** ./src/WebGL/Fog.ts ***!
            \**************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Fog: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../colors */
              "./src/colors.ts"
            );
            class M {
              constructor(A, h = 1, g = 1e3) {
                this.name = "", this.color = new v.Color(A), this.near = h, this.far = g;
              }
              clone() {
                return new M(this.color.getHex(), this.near, this.far);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Renderer.ts": (
          /*!*******************************!*\
            !*** ./src/WebGL/Renderer.ts ***!
            \*******************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Renderer: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), M = s(
              /*! ./constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), E = s(
              /*! ./constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), A = s(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), h = s(
              /*! ../colors */
              "./src/colors.ts"
            ), g = s(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), C = s(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), c = s(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), S = s(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), y = s(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            );
            class b {
              constructor(t) {
                this.context = null, this.devicePixelRatio = 1, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.autoUpdateObjects = !0, this.autoUpdateScene = !0, this.info = {
                  memory: {
                    programs: 0,
                    geometries: 0,
                    textures: 0
                  },
                  render: {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                  }
                }, this._programs = [], this._programs_counter = 0, this._webglversion = 1, this._currentProgram = null, this._currentMaterialId = -1, this._currentGeometryGroupHash = null, this._currentCamera = null, this._geometryGroupCounter = 0, this._oldDoubleSided = -1, this._oldFlipSided = -1, this._oldDepthTest = -1, this._oldDepthWrite = -1, this._oldPolygonOffset = null, this._oldLineWidth = null, this._viewportWidth = 0, this._viewportHeight = 0, this._currentWidth = 0, this._currentHeight = 0, this._enabledAttributes = {}, this._projScreenMatrix = new C.Matrix4(), this._vector3 = new C.Vector3(), this._worldInverse = new C.Matrix4(), this._projInverse = new C.Matrix4(), this._textureMatrix = new C.Matrix4(), this._direction = new C.Vector3(), this._lightsNeedUpdate = !0, this._lights = {
                  ambient: [0, 0, 0],
                  directional: {
                    length: 0,
                    colors: [],
                    positions: []
                  },
                  point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: []
                  },
                  spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: []
                  },
                  hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                  }
                }, this.sprites = new y.SpritePlugin(), this._screenshader = null, this._vertexattribpos = null, this._screenQuadVBO = null, this._fb = null, this._targetTexture = null, this._depthTexture = null, t = t || {}, this.row = t.row, this.col = t.col, this.rows = t.rows, this.cols = t.cols, this._canvas = t.canvas !== void 0 ? t.canvas : document.createElement("canvas"), this._precision = t.precision !== void 0 ? t.precision : "highp", this._alpha = t.alpha !== void 0 ? t.alpha : !0, this._premultipliedAlpha = t.premultipliedAlpha !== void 0 ? t.premultipliedAlpha : !0, this._antialias = t.antialias !== void 0 ? t.antialias : !1, this._stencil = t.stencil !== void 0 ? t.stencil : !0, this._preserveDrawingBuffer = t.preserveDrawingBuffer !== void 0 ? t.preserveDrawingBuffer : !1, this._clearColor = t.clearColor !== void 0 ? new h.Color(t.clearColor) : new h.Color(0), this._clearAlpha = t.clearAlpha !== void 0 ? t.clearAlpha : 0, this._outlineMaterial = new g.MeshOutlineMaterial(t.outline), this._outlineSphereImposterMaterial = new g.SphereImposterOutlineMaterial(t.outline), this._outlineStickImposterMaterial = new g.StickImposterOutlineMaterial(t.outline), this._outlineEnabled = !!t.outline, this.domElement = this._canvas, this._canvas.id = t.id, this.initGL(), this.setDefaultGLState(), this.context = this._gl, this.isWebGL1() ? this._extInstanced = this._gl.getExtension("ANGLE_instanced_arrays") : this._extInstanced = {
                  vertexAttribDivisorANGLE: this._gl.vertexAttribDivisor.bind(this._gl),
                  drawElementsInstancedANGLE: this._gl.drawElementsInstanced.bind(this._gl)
                }, this._extFragDepth = this._gl.getExtension("EXT_frag_depth"), this._extFloatLinear = this._gl.getExtension("OES_texture_float_linear"), this._extColorBufferFloat = this._gl.getExtension("EXT_color_buffer_float"), this.sprites.init(this);
              }
              // API
              supportedExtensions() {
                return {
                  supportsAIA: !!this._extInstanced,
                  supportsImposters: !!this._extFragDepth || !this.isWebGL1(),
                  regen: !1
                };
              }
              getContext() {
                return this._gl;
              }
              isLost() {
                return this._gl.isContextLost();
              }
              getPrecision() {
                return this._precision;
              }
              setClearColorHex(t, r) {
                this._clearColor.setHex(t), this._clearAlpha = r, this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              enableOutline(t) {
                this._outlineMaterial = new g.MeshOutlineMaterial(t), this._outlineSphereImposterMaterial = new g.SphereImposterOutlineMaterial(t), this._outlineStickImposterMaterial = new g.StickImposterOutlineMaterial(t), this._outlineEnabled = !0;
              }
              disableOutline() {
                this._outlineEnabled = !1;
              }
              setViewport() {
                if (this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var t = this._canvas.width / this.cols, r = this._canvas.height / this.rows;
                  this._viewportWidth = t, this._viewportHeight = r, this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(t * this.col, r * this.row, t, r), this._gl.viewport(t * this.col, r * this.row, t, r);
                }
              }
              setSize(t, r) {
                if (this.devicePixelRatio = window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1, this._antialias && this.devicePixelRatio < 2 && (this.devicePixelRatio *= 2), this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var u = t / this.cols, o = r / this.rows;
                  this._canvas.width = t * this.devicePixelRatio, this._canvas.height = r * this.devicePixelRatio, this._viewportWidth = u * this.devicePixelRatio, this._viewportHeight = o * this.devicePixelRatio, this._canvas.style.width = t + "px", this._canvas.style.height = r + "px", this.setViewport();
                } else
                  this._viewportWidth = this._canvas.width = t * this.devicePixelRatio, this._viewportHeight = this._canvas.height = r * this.devicePixelRatio, this._canvas.style.width = t + "px", this._canvas.style.height = r + "px", this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
                this.initFrameBuffer();
              }
              clear(t, r, u) {
                var o = 0;
                (t === void 0 || t) && (o |= this._gl.COLOR_BUFFER_BIT), (r === void 0 || r) && (o |= this._gl.DEPTH_BUFFER_BIT), (u === void 0 || u) && (o |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(o);
              }
              clearTarget(t, r, u) {
                this.clear(t, r, u);
              }
              setMaterialFaces(t, r) {
                var u = t.side === M.DoubleSide, o = t.side === M.BackSide;
                t.imposter || (o = r ? !o : o), this._oldDoubleSided !== u && (u ? this._gl.disable(this._gl.CULL_FACE) : this._gl.enable(this._gl.CULL_FACE), this._oldDoubleSided = u), this._oldFlipSided !== o && (o ? this._gl.frontFace(this._gl.CW) : this._gl.frontFace(this._gl.CCW), this._oldFlipSided = o), this._gl.cullFace(this._gl.BACK);
              }
              setDepthTest(t) {
                this._oldDepthTest !== t && (t ? this._gl.enable(this._gl.DEPTH_TEST) : this._gl.disable(this._gl.DEPTH_TEST), this._oldDepthTest = t);
              }
              setDepthWrite(t) {
                this._oldDepthWrite !== t && (this._gl.depthMask(t), this._oldDepthWrite = t);
              }
              setBlending(t) {
                t ? (this._gl.enable(this._gl.BLEND), this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD), this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)) : this._gl.disable(this._gl.BLEND);
              }
              // TODO: need to set up shader attributes and uniforms as attributes on
              // material object after attaching prgm
              // We need to attach appropriate uniform variables to material after shaders
              // have been chosen
              initMaterial(t, r, u, o) {
                t.addEventListener("dispose", this.onMaterialDispose.bind(this));
                var l, e;
                if (e = t.shaderID, e) {
                  var n = S.ShaderLib[e];
                  t.vertexShader = n.vertexShader, t.fragmentShader = n.fragmentShader, t.uniforms = S.ShaderUtils.clone(n.uniforms);
                }
                l = {
                  wireframe: t.wireframe,
                  fragdepth: t.imposter,
                  volumetric: t.volumetric
                }, t.program = this.buildProgram(t.fragmentShader, t.vertexShader, t.uniforms, l);
              }
              renderBuffer(t, r, u, o, l, e) {
                if (o.visible) {
                  var n, a;
                  if (n = this.setProgram(t, r, u, o, e, this), !!n) {
                    a = n.attributes;
                    var p = !1, x = o.wireframe ? 1 : 0, D = l.id * 16777215 + n.id * 2 + x;
                    D !== this._currentGeometryGroupHash && (this._currentGeometryGroupHash = D, p = !0), p && (this.disableAttributes(), a.position >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglVertexBuffer), this.enableAttribute(a.position), this._gl.vertexAttribPointer(a.position, 3, this._gl.FLOAT, !1, 0, 0)), a.color >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglColorBuffer), this.enableAttribute(a.color), this._gl.vertexAttribPointer(a.color, 3, this._gl.FLOAT, !1, 0, 0)), a.normal >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglNormalBuffer), this.enableAttribute(a.normal), this._gl.vertexAttribPointer(a.normal, 3, this._gl.FLOAT, !1, 0, 0)), a.offset >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglOffsetBuffer), this.enableAttribute(a.offset), this._gl.vertexAttribPointer(a.offset, 3, this._gl.FLOAT, !1, 0, 0)), a.radius >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglRadiusBuffer), this.enableAttribute(a.radius), this._gl.vertexAttribPointer(a.radius, 1, this._gl.FLOAT, !1, 0, 0)));
                    var O, R;
                    if (e instanceof c.Mesh) {
                      if (o.shaderID === "instanced") {
                        var z = o.sphere.geometryGroups[0];
                        p && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, z.vertexArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, l.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, z.normalArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, l.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, z.faceArray, this._gl.STATIC_DRAW)), O = z.faceidx, this._extInstanced.vertexAttribDivisorANGLE(a.offset, 1), this._extInstanced.vertexAttribDivisorANGLE(a.radius, 1), this._extInstanced.vertexAttribDivisorANGLE(a.color, 1), this._extInstanced.drawElementsInstancedANGLE(this._gl.TRIANGLES, O, this._gl.UNSIGNED_SHORT, 0, l.radiusArray.length), this._extInstanced.vertexAttribDivisorANGLE(a.offset, 0), this._extInstanced.vertexAttribDivisorANGLE(a.radius, 0), this._extInstanced.vertexAttribDivisorANGLE(a.color, 0);
                      } else
                        o.wireframe ? (R = l.lineidx, this.setLineWidth(o.wireframeLinewidth), p && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, l.__webglLineBuffer), this._gl.drawElements(this._gl.LINES, R, this._gl.UNSIGNED_SHORT, 0)) : (O = l.faceidx, p && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, l.__webglFaceBuffer), this._gl.drawElements(this._gl.TRIANGLES, O, this._gl.UNSIGNED_SHORT, 0));
                      this.info.render.calls++, this.info.render.vertices += O, this.info.render.faces += O / 3;
                    } else
                      e instanceof c.Line && (R = l.vertices, this.setLineWidth(o.linewidth), this._gl.drawArrays(this._gl.LINES, 0, R), this.info.render.calls++);
                  }
                }
              }
              render(t, r, u) {
                if (!(r instanceof v.Camera)) {
                  console.error("Renderer.render: camera is not an instance of Camera.");
                  return;
                }
                var o, l, e, n, a, p = t.__lights, x = t.fog;
                this._currentMaterialId = -1, this._lightsNeedUpdate = !0, this.autoUpdateScene && t.updateMatrixWorld(), r.parent === void 0 && r.updateMatrixWorld(), r.matrixWorldInverse.getInverse(r.matrixWorld), this._projScreenMatrix.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this.autoUpdateObjects && this.initWebGLObjects(t), this.info.render.calls = 0, this.info.render.vertices = 0, this.info.render.faces = 0, this.info.render.points = 0, this._currentWidth = this._viewportWidth, this._currentHeight = this._viewportHeight, this.setViewport(), this.setFrameBuffer(), (this.autoClear || u) && (this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha), this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil)), a = t.__webglObjects;
                var D = !1;
                for (o = 0, l = a.length; o < l; o++)
                  e = a[o], n = e.object, e.render = !1, n.visible && (this.setupMatrices(n, r), this.unrollBufferMaterial(e), e.render = !0, e.volumetric && (D = !0));
                var O = null;
                this.setBlending(!1), this.renderObjects(t.__webglObjects, !0, "opaque", r, p, x, !1, O), this.renderSprites(t, r, !1), this.renderObjects(t.__webglObjects, !0, "blank", r, p, x, !0, O), this.renderObjects(t.__webglObjects, !1, "transparent", r, p, x, !0, O), D && this._fb && (this.reinitFrameBuffer(), this.renderObjects(t.__webglObjects, !1, "volumetric", r, p, x, !0, O)), this.renderFrameBuffertoScreen(), this.setDepthTest(!0), this.setDepthWrite(!0), this.renderSprites(t, r, !0);
              }
              //reinitialize framebuffer without the depth texture attached so we can read to it
              //do not allocate new textures
              reinitFrameBuffer() {
                this.isWebGL1() || (this._fb = this._gl.createFramebuffer(), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0));
              }
              //setup framebuffer for drawing into, assumes buffers already allocated
              setFrameBuffer() {
                if (this.isWebGL1() || !this._fb)
                  return;
                let t = this._viewportWidth, r = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, t, r), this._gl.viewport(0, 0, t, r), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, t, r, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, t, r, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
              }
              //allocate buffers for framebuffer, needs to be called with every resize
              initFrameBuffer() {
                if (this.isWebGL1())
                  return;
                let t = this._viewportWidth, r = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, t, r), this._gl.viewport(0, 0, t, r), this._targetTexture = this._gl.createTexture(), this._depthTexture = this._gl.createTexture(), this._fb = this._gl.createFramebuffer();
                var u = S.ShaderLib.screen;
                this._screenshader = this.buildProgram(u.fragmentShader, u.vertexShader, u.uniforms, {}), this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, "vertexPosition");
                var o = [
                  // First triangle:
                  1,
                  1,
                  -1,
                  1,
                  -1,
                  -1,
                  // Second triangle:
                  -1,
                  -1,
                  1,
                  -1,
                  1,
                  1
                ];
                this._screenQuadVBO = this._gl.createBuffer(), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(o), this._gl.STATIC_DRAW);
              }
              renderFrameBuffertoScreen() {
                this.isWebGL1() || this._fb === null || (this.setViewport(), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null), this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.useProgram(this._screenshader), this._currentProgram = this._screenshader, this.setDepthTest(-1), this.setDepthWrite(-1), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.enableVertexAttribArray(this._vertexattribpos), this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, !1, 0, 0), this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.drawArrays(this._gl.TRIANGLES, 0, 6));
              }
              initWebGLObjects(t) {
                if (t.__webglObjects || (t.__webglObjects = [], t.__webglObjectsImmediate = [], t.__webglSprites = [], t.__webglFlares = []), t.__objectsAdded.length) {
                  for (; t.__objectsAdded.length; )
                    this.addObject(t.__objectsAdded[0], t), t.__objectsAdded.splice(0, 1);
                  this._currentGeometryGroupHash = -1;
                }
                for (; t.__objectsRemoved.length; )
                  this.removeObject(t.__objectsRemoved[0], t), t.__objectsRemoved.splice(0, 1);
                for (var r = 0, u = t.__webglObjects.length; r < u; r++)
                  this.updateObject(t.__webglObjects[r].object);
              }
              getYRatio() {
                return this.rows !== void 0 && this.row !== void 0 ? this.rows : 1;
              }
              getXRatio() {
                return this.cols !== void 0 && this.col !== void 0 ? this.cols : 1;
              }
              getAspect(t, r) {
                (t == null || r == null) && (t = this._canvas.width, r = this._canvas.height);
                var u = t / r;
                if (this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var o = t / this.cols, l = r / this.rows;
                  u = o / l;
                }
                return u;
              }
              setTexture(t, r, u) {
                if (t.needsUpdate) {
                  t.__webglInit || (t.__webglInit = !0, t.addEventListener("dispose", this.onTextureDispose.bind(this)), t.__webglTexture = this._gl.createTexture(), this.info.memory.textures++), this._gl.activeTexture(this._gl.TEXTURE0 + r);
                  var o = u ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D;
                  this._gl.bindTexture(o, t.__webglTexture), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, t.flipY), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, t.unpackAlignment), this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, t.unpackAlignment);
                  var l = this.paramToGL(t.format), e = this.paramToGL(t.type);
                  if (u)
                    this.setTextureParameters(this._gl.TEXTURE_3D, t), this._gl.texImage3D(this._gl.TEXTURE_3D, 0, this._gl.R32F, t.image.size.z, t.image.size.y, t.image.size.x, 0, this._gl.RED, this._gl.FLOAT, t.image.data);
                  else {
                    var n = t.image, a = n.width, p = n.height;
                    typeof a > "u" && (a = n.length, l == this._gl.RGBA && (a /= 4), p = 1), this.setTextureParameters(this._gl.TEXTURE_2D, t), this.isWebGL1() ? this._gl.texImage2D(this._gl.TEXTURE_2D, 0, l, l, e, t.image) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, l, a, p, 0, l, e, t.image);
                  }
                  t.needsUpdate = !1, t.onUpdate && t.onUpdate();
                } else
                  this._gl.activeTexture(this._gl.TEXTURE0 + r), u ? this._gl.bindTexture(this._gl.TEXTURE_3D, t.__webglTexture) : this._gl.bindTexture(this._gl.TEXTURE_2D, t.__webglTexture);
              }
              supportsVolumetric() {
                return !this.isWebGL1();
              }
              enableAttribute(t) {
                this._enabledAttributes[t] || (this._gl.enableVertexAttribArray(t), this._enabledAttributes[t] = !0);
              }
              disableAttributes() {
                for (let t in this._enabledAttributes)
                  this._enabledAttributes[t] && (this._gl.disableVertexAttribArray(t), this._enabledAttributes[t] = !1);
              }
              setPolygonOffset(t, r, u) {
                this._oldPolygonOffset !== t && (t ? this._gl.enable(this._gl.POLYGON_OFFSET_FILL) : this._gl.disable(this._gl.POLYGON_OFFSET_FILL));
              }
              setLineWidth(t) {
                t !== this._oldLineWidth && (this._gl.lineWidth(t), this._oldLineWidth = t);
              }
              deallocateGeometry(t) {
                if (t.__webglInit = void 0, t.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(t.__webglVertexBuffer), t.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(t.__webglColorBuffer), t.geometryGroups !== void 0)
                  for (var r = 0, u = t.groups; r < u; r++) {
                    var o = t.geometryGroups[r];
                    o.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(o.__webglVertexBuffer), o.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(o.__webglColorBuffer), o.__webglNormalBuffer !== void 0 && this._gl.deleteBuffer(o.__webglNormalBuffer), o.__webglFaceBuffer !== void 0 && this._gl.deleteBuffer(o.__webglFaceBuffer), o.__webglLineBuffer !== void 0 && this._gl.deleteBuffer(o.__webglLineBuffer);
                  }
              }
              deallocateMaterial(t) {
                var r = t.program;
                if (r !== void 0) {
                  t.program = void 0;
                  var u, o, l, e = !1;
                  for (u = 0, o = this._programs.length; u < o; u++)
                    if (l = this._programs[u], l.program === r) {
                      l.usedTimes--, l.usedTimes === 0 && (e = !0);
                      break;
                    }
                  if (e === !0) {
                    var n = [];
                    for (u = 0, o = this._programs.length; u < o; u++)
                      l = this._programs[u], l.program !== r && n.push(l);
                    this._programs = n, this._gl.deleteProgram(r), this.info.memory.programs--;
                  }
                }
              }
              deallocateTexture(t) {
                if (t.image && t.image.__webglTextureCube)
                  this._gl.deleteTexture(t.image.__webglTextureCube);
                else {
                  if (!t.__webglInit)
                    return;
                  t.__webglInit = !1, this._gl.deleteTexture(t.__webglTexture);
                }
              }
              onGeometryDispose(t) {
                var r = t.target;
                r.removeEventListener("dispose", this.onGeometryDispose), this.deallocateGeometry(r), this.info.memory.geometries--;
              }
              onTextureDispose(t) {
                var r = t.target;
                r.removeEventListener("dispose", this.onTextureDispose), this.deallocateTexture(r), this.info.memory.textures--;
              }
              onMaterialDispose(t) {
                var r = t.target;
                r.removeEventListener("dispose", this.onMaterialDispose), this.deallocateMaterial(r);
              }
              // Compile and return shader
              getShader(t, r) {
                var u;
                return !this.isWebGL1() && !r.startsWith("#version") && (r = r.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), t == "fragment" ? r = r.replace(/varying/g, "in") : r = r.replace(/varying/g, "out"), r = r.replace(/attribute/g, "in"), r = r.replace(/texture2D/g, "texture"), r = r.replace(/\/\/DEFINEFRAGCOLOR/g, "out vec4 glFragColor;"), r = r.replace(/gl_FragColor/g, "glFragColor"), r = `#version 300 es
` + r), t === "fragment" ? u = this._gl.createShader(this._gl.FRAGMENT_SHADER) : t === "vertex" && (u = this._gl.createShader(this._gl.VERTEX_SHADER)), u == null ? null : (this._gl.shaderSource(u, r), this._gl.compileShader(u), this._gl.getShaderParameter(u, this._gl.COMPILE_STATUS) ? u : (console.error(this._gl.getShaderInfoLog(u)), console.error("could not initialize shader"), null));
              }
              // Compile appropriate shaders (if necessary) from source code and attach to
              // gl program.
              buildProgram(t, r, u, o) {
                var l, e, n, a, p = [];
                p.push(t), p.push(r);
                for (l in o)
                  p.push(l), p.push(o[l]);
                for (a = p.join(), l = 0, e = this._programs.length; l < e; l++) {
                  var x = this._programs[l];
                  if (x.code === a)
                    return x.usedTimes++, x.program;
                }
                if (this.isWebGL1() && o.volumetric)
                  throw new Error("Volumetric rendering requires webgl2 which is not supported by your hardware.");
                if (n = this._gl.createProgram(), n == null)
                  return null;
                var D = this._precision, O = "precision " + D + " float;", R = [
                  o.volumetric ? "#version 300 es" : "",
                  O
                ].join(`
`), z = [
                  o.volumetric ? "#version 300 es" : "",
                  o.fragdepth && this.isWebGL1() ? "#extension GL_EXT_frag_depth: enable" : "",
                  o.wireframe ? "#define WIREFRAME 1" : "",
                  O
                ].join(`
`), T = this.getShader("fragment", z + t), B = this.getShader("vertex", R + r);
                B != null && this._gl.attachShader(n, B), T != null && this._gl.attachShader(n, T), this._gl.linkProgram(n), this._gl.getProgramParameter(n, this._gl.LINK_STATUS) || console.error("Could not initialize shader"), n.uniforms = {}, n.attributes = {};
                var W, k, F;
                W = [
                  "viewMatrix",
                  "modelViewMatrix",
                  "projectionMatrix",
                  "normalMatrix"
                ];
                for (k in u)
                  W.push(k);
                for (F = 0; F < W.length; F++) {
                  var U = W[F];
                  n.uniforms[U] = this._gl.getUniformLocation(n, U);
                }
                for (W = [
                  "position",
                  "normal",
                  "color",
                  "lineDistance",
                  "offset",
                  "radius"
                ], F = 0; F < W.length; F++) {
                  var V = W[F];
                  n.attributes[V] = this._gl.getAttribLocation(n, V);
                }
                return n.id = this._programs_counter++, this._programs.push({
                  program: n,
                  code: a,
                  usedTimes: 1
                }), this.info.memory.programs = this._programs.length, n;
              }
              setProgram(t, r, u, o, l, e) {
                if (o.needsUpdate && (o.program && this.deallocateMaterial(o), this.initMaterial(o, r, u, l), o.needsUpdate = !1), o.program == null)
                  return null;
                var n = !1, a = o.program, p = a.uniforms, x = o.uniforms;
                if (a != this._currentProgram && (this._gl.useProgram(a), this._currentProgram = a, n = !0), o.id != this._currentMaterialId && (this._currentMaterialId = o.id, n = !0), t != this._currentCamera && (this._currentCamera = t, n = !0), this._gl.uniformMatrix4fv(p.projectionMatrix, !1, t.projectionMatrix.elements), this._gl.uniformMatrix4fv(p.modelViewMatrix, !1, l._modelViewMatrix.elements), this._gl.uniformMatrix3fv(p.normalMatrix, !1, l._normalMatrix.elements), n) {
                  if (x.fogColor.value = u.color, x.fogNear.value = u.near, x.fogFar.value = u.far, o.shaderID.startsWith("lambert") || o.shaderID === "instanced" || o.shaderID.endsWith("imposter"))
                    this._gl.uniformMatrix4fv(p.viewMatrix, !1, t.matrixWorldInverse.elements), this._lightsNeedUpdate && (this.setupLights(a, r), this._lightsNeedUpdate = !1), x.directionalLightColor.value = this._lights.directional.colors, x.directionalLightDirection.value = this._lights.directional.positions;
                  else if (o.shaderID.endsWith("outline"))
                    x.outlineColor.value = o.outlineColor, x.outlineWidth.value = o.outlineWidth, x.outlinePushback.value = o.outlinePushback;
                  else if (o.shaderID === "volumetric") {
                    l._modelViewMatrix.getScale(this._direction), this._worldInverse.getInverse(l._modelViewMatrix), this._projInverse.getInverse(t.projectionMatrix), this._textureMatrix.multiplyMatrices(l.material.texmatrix, this._worldInverse), this._gl.uniformMatrix4fv(p.textmat, !1, this._textureMatrix.elements), this._gl.uniformMatrix4fv(p.projinv, !1, this._projInverse.elements);
                    let D = Math.min(Math.min(this._direction.x, this._direction.y), this._direction.z);
                    x.step.value = l.material.unit * D, x.maxdepth.value = l.material.maxdepth * D, x.transfermax.value = l.material.transfermax, x.transfermin.value = l.material.transfermin, x.subsamples.value = l.material.subsamples, e.setTexture(l.material.transferfn, 4, !1), e.setTexture(l.material.map, 3, !0), this._gl.activeTexture(this._gl.TEXTURE5), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);
                  }
                  x.opacity.value = o.opacity, this.loadMaterialUniforms(p, x);
                }
                return a;
              }
              loadMaterialUniforms(t, r) {
                var u, o, l, e;
                for (u in r)
                  t[u] && (o = r[u].type, l = r[u].value, e = t[u], o === "f" ? this._gl.uniform1f(e, l) : o === "i" ? this._gl.uniform1i(e, l) : o === "fv" ? this._gl.uniform3fv(e, l) : o === "c" ? this._gl.uniform3f(e, l.r, l.g, l.b) : o === "f4" && this._gl.uniform4f(e, l[0], l[1], l[2], l[3]));
              }
              // Objects adding
              addObject(t, r) {
                var u, o, l, e;
                if (!t.__webglInit && (t.__webglInit = !0, t._modelViewMatrix = new C.Matrix4(), t._normalMatrix = new C.Matrix3(), t.geometry !== void 0 && t.geometry.__webglInit === void 0 && (t.geometry.__webglInit = !0, t.geometry.addEventListener("dispose", this.onGeometryDispose.bind(this))), t instanceof c.Mesh || t instanceof c.Line))
                  for (l = t.geometry, u = 0, o = l.geometryGroups.length; u < o; u++)
                    e = l.geometryGroups[u], e.id = this._geometryGroupCounter++, e.__webglVertexBuffer || (t instanceof c.Mesh ? (this.createMeshBuffers(e), l.elementsNeedUpdate = !0, l.normalsNeedUpdate = !0) : t instanceof c.Line && this.createLineBuffers(e), l.verticesNeedUpdate = !0, l.colorsNeedUpdate = !0);
                if (!t.__webglActive) {
                  if (t instanceof c.Mesh || t instanceof c.Line)
                    for (l = t.geometry, u = 0, o = l.geometryGroups.length; u < o; u++)
                      e = l.geometryGroups[u], this.addBuffer(r.__webglObjects, e, t);
                  else
                    t instanceof c.Sprite && r.__webglSprites.push(t);
                  t.__webglActive = !0;
                }
              }
              updateObject(t) {
                var r = t.geometry, u;
                if (t instanceof c.Mesh || t instanceof c.Line) {
                  for (var o = 0, l = r.geometryGroups.length; o < l; o++)
                    u = r.geometryGroups[o], (r.verticesNeedUpdate || r.elementsNeedUpdate || r.colorsNeedUpdate || r.normalsNeedUpdate) && this.setBuffers(u, this._gl.STATIC_DRAW);
                  r.verticesNeedUpdate = !1, r.elementsNeedUpdate = !1, r.normalsNeedUpdate = !1, r.colorsNeedUpdate = !1, r.buffersNeedUpdate = !1;
                }
              }
              removeObject(t, r) {
                t instanceof c.Mesh || t instanceof c.Line ? this.removeInstances(r.__webglObjects, t) : t instanceof c.Sprite && this.removeInstancesDirect(r.__webglSprites, t), t.__webglActive = !1;
              }
              removeInstances(t, r) {
                for (var u = t.length - 1; u >= 0; --u)
                  t[u].object === r && t.splice(u, 1);
              }
              removeInstancesDirect(t, r) {
                for (var u = t.length - 1; u >= 0; --u)
                  t[u] === r && t.splice(u, 1);
              }
              unrollBufferMaterial(t) {
                var r = t.object, u = r.material;
                if (u.volumetric)
                  t.opaque = null, t.transparent = null, t.volumetric = u;
                else if (u.transparent) {
                  if (t.opaque = null, t.volumetric = null, t.transparent = u, !u.wireframe) {
                    var o = u.clone();
                    o.opacity = 0, t.blank = o;
                  }
                } else
                  t.opaque = u, t.transparent = null, t.volumetric = null;
              }
              setBuffers(t, r) {
                var u = t.vertexArray, o = t.colorArray;
                if (t.__webglOffsetBuffer !== void 0 ? (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, t.__webglOffsetBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, u, r)) : (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, t.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, u, r)), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, t.__webglColorBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, o, r), t.normalArray && t.__webglNormalBuffer !== void 0) {
                  var l = t.normalArray;
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, t.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, l, r);
                }
                if (t.radiusArray && t.__webglRadiusBuffer !== void 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, t.__webglRadiusBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, t.radiusArray, r)), t.faceArray && t.__webglFaceBuffer !== void 0) {
                  var e = t.faceArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, t.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, e, r);
                }
                if (t.lineArray && t.__webglLineBuffer !== void 0) {
                  var n = t.lineArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, t.__webglLineBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, n, r);
                }
              }
              // Creates appropriate gl buffers for geometry chunk
              // TODO: do we need line buffer for mesh objects?
              // Also, can we integrate this with createLineBuffers?
              createMeshBuffers(t) {
                t.radiusArray && (t.__webglRadiusBuffer = this._gl.createBuffer()), t.useOffset && (t.__webglOffsetBuffer = this._gl.createBuffer()), t.__webglVertexBuffer = this._gl.createBuffer(), t.__webglNormalBuffer = this._gl.createBuffer(), t.__webglColorBuffer = this._gl.createBuffer(), t.__webglFaceBuffer = this._gl.createBuffer(), t.__webglLineBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              createLineBuffers(t) {
                t.__webglVertexBuffer = this._gl.createBuffer(), t.__webglColorBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              addBuffer(t, r, u) {
                t.push({
                  buffer: r,
                  object: u,
                  opaque: null,
                  transparent: null
                });
              }
              setupMatrices(t, r) {
                t._modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, t.matrixWorld), t._normalMatrix.getInverse(t._modelViewMatrix), t._normalMatrix.transpose();
              }
              // Fallback filters for non-power-of-2 textures
              filterFallback(t) {
                return this._gl.LINEAR;
              }
              setTextureParameters(t, r) {
                t == this._gl.TEXTURE_2D ? (this._gl.texParameteri(t, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(t, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(t, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(r.magFilter)), this._gl.texParameteri(t, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(r.minFilter))) : (this._gl.texParameteri(t, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(t, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(t, this._gl.TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE), this._extColorBufferFloat && this._extFloatLinear ? (this._gl.texParameteri(t, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(t, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR)) : (this._gl.texParameteri(t, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(t, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST)));
              }
              // Map constants to WebGL constants
              paramToGL(t) {
                return t === E.UnsignedByteType ? this._gl.UNSIGNED_BYTE : t === E.RGBAFormat ? this._gl.RGBA : t === E.NearestFilter ? this._gl.NEAREST : 0;
              }
              setupLights(t, r) {
                var u, o, l, e = 0, n = 0, a = 0, p, x, D = this._lights, O = D.directional.colors, R = D.directional.positions, z = 0, T = 0;
                for (u = 0, o = r.length; u < o; u++)
                  if (l = r[u], p = l.color, x = l.intensity, l instanceof A.Light) {
                    if (this._direction.getPositionFromMatrix(l.matrixWorld), this._vector3.getPositionFromMatrix(l.target.matrixWorld), this._direction.sub(this._vector3), this._direction.normalize(), this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)
                      continue;
                    R[T] = this._direction.x, R[T + 1] = this._direction.y, R[T + 2] = this._direction.z, O[T] = p.r * x, O[T + 1] = p.g * x, O[T + 2] = p.b * x, T += 3, z++;
                  }
                D.ambient[0] = e, D.ambient[1] = n, D.ambient[2] = a, D.directional.length = z;
              }
              initGL() {
                try {
                  if (!(this._gl = this._canvas.getContext("webgl2", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("experimental-webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })))
                    throw "Error creating WebGL context.";
                  var t = this._gl.getParameter(this._gl.VERSION);
                  this._webglversion = parseInt(t[6]);
                } catch (r) {
                  console.error(r);
                }
              }
              isWebGL1() {
                return this._webglversion == 1;
              }
              setDefaultGLState() {
                this._gl.clearColor(0, 0, 0, 1), this._gl.clearDepth(1), this._gl.clearStencil(0), this._gl.enable(this._gl.DEPTH_TEST), this._gl.depthFunc(this._gl.LEQUAL), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.enable(this._gl.CULL_FACE), this._gl.enable(this._gl.BLEND), this._gl.blendEquation(this._gl.FUNC_ADD), this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              // rendering
              renderObjects(t, r, u, o, l, e, n, O) {
                var p, x, D, O, R, z, T;
                r ? (R = t.length - 1, z = -1, T = -1) : (R = 0, z = t.length, T = 1);
                for (var B = R; B !== z; B += T)
                  if (p = t[B], p.render) {
                    if (x = p.object, D = p.buffer, O = p[u], !O)
                      continue;
                    n && this.setBlending(!0), this.setDepthTest(O.depthTest), this.setDepthWrite(O.depthWrite), this.setPolygonOffset(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits);
                    var W = x._modelViewMatrix.isReflected();
                    this.setMaterialFaces(O, W), this.renderBuffer(o, l, e, O, D, x), (this._outlineEnabled || O.outline) && (O.shaderID == "sphereimposter" ? this.renderBuffer(o, l, e, this._outlineSphereImposterMaterial, D, x) : O.shaderID == "stickimposter" ? this.renderBuffer(o, l, e, this._outlineStickImposterMaterial, D, x) : !O.wireframe && O.shaderID !== "basic" && O.opacity !== 0 && this.renderBuffer(o, l, e, this._outlineMaterial, D, x));
                  }
              }
              renderSprites(t, r, u) {
                this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1, this._lightsNeedUpdate = !0, this.sprites.render(t, r, this._currentWidth, this._currentHeight, u), this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/SpritePlugin.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/SpritePlugin.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SpritePlugin: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./shaders/index */
              "./src/WebGL/shaders/index.ts"
            );
            class M {
              constructor() {
                this.sprite = {
                  vertices: null,
                  faces: null,
                  vertexBuffer: null,
                  elementBuffer: null,
                  program: null,
                  attributes: {},
                  uniforms: null
                };
              }
              init(h) {
                this.gl = h.context, this.renderer = h, this.precision = h.getPrecision(), this.sprite.vertices = new Float32Array(16), this.sprite.faces = new Uint16Array(6);
                var g = 0;
                this.sprite.vertices[g++] = -1, this.sprite.vertices[g++] = -1, this.sprite.vertices[g++] = 0, this.sprite.vertices[g++] = 0, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = -1, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = 0, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = -1, this.sprite.vertices[g++] = 1, this.sprite.vertices[g++] = 0, this.sprite.vertices[g++] = 1, g = 0, this.sprite.faces[g++] = 0, this.sprite.faces[g++] = 1, this.sprite.faces[g++] = 2, this.sprite.faces[g++] = 0, this.sprite.faces[g++] = 2, this.sprite.faces[g++] = 3, this.sprite.vertexBuffer = this.gl.createBuffer(), this.sprite.elementBuffer = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.sprite.vertices, this.gl.STATIC_DRAW), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.faces, this.gl.STATIC_DRAW), this.sprite.program = this.createProgram(
                  v.ShaderLib.sprite,
                  this.precision || 1
                  /** added default to single precision */
                ), this.sprite.attributes = {};
                const C = {};
                this.sprite.attributes.position = this.gl.getAttribLocation(this.sprite.program, "position"), this.sprite.attributes.uv = this.gl.getAttribLocation(this.sprite.program, "uv"), C.uvOffset = this.gl.getUniformLocation(this.sprite.program, "uvOffset"), C.uvScale = this.gl.getUniformLocation(this.sprite.program, "uvScale"), C.rotation = this.gl.getUniformLocation(this.sprite.program, "rotation"), C.scale = this.gl.getUniformLocation(this.sprite.program, "scale"), C.alignment = this.gl.getUniformLocation(this.sprite.program, "alignment"), C.color = this.gl.getUniformLocation(this.sprite.program, "color"), C.map = this.gl.getUniformLocation(this.sprite.program, "map"), C.opacity = this.gl.getUniformLocation(this.sprite.program, "opacity"), C.useScreenCoordinates = this.gl.getUniformLocation(this.sprite.program, "useScreenCoordinates"), C.screenPosition = this.gl.getUniformLocation(this.sprite.program, "screenPosition"), C.modelViewMatrix = this.gl.getUniformLocation(this.sprite.program, "modelViewMatrix"), C.projectionMatrix = this.gl.getUniformLocation(this.sprite.program, "projectionMatrix"), C.fogType = this.gl.getUniformLocation(this.sprite.program, "fogType"), C.fogDensity = this.gl.getUniformLocation(this.sprite.program, "fogDensity"), C.fogNear = this.gl.getUniformLocation(this.sprite.program, "fogNear"), C.fogFar = this.gl.getUniformLocation(this.sprite.program, "fogFar"), C.fogColor = this.gl.getUniformLocation(this.sprite.program, "fogColor"), C.alphaTest = this.gl.getUniformLocation(this.sprite.program, "alphaTest"), this.sprite.uniforms = C;
              }
              render(h, g, C, c, S) {
                var y, b, w, t, r, u, o, l, e, n;
                if (!this.gl)
                  throw new Error("WebGLRenderer not initialized");
                let a = [];
                (y = h == null ? void 0 : h.__webglSprites) === null || y === void 0 || y.forEach((J) => {
                  (S && J.material.depthTest == !1 || !S && J.material.depthTest) && a.push(J);
                });
                let p = a.length;
                if (!p)
                  return;
                const x = this.sprite.attributes, D = this.sprite.uniforms;
                if (!D)
                  throw new Error("Uniforms not defined");
                var O = C * 0.5, R = c * 0.5;
                this.gl.useProgram(this.sprite.program), this.gl.enableVertexAttribArray(x.position), this.gl.enableVertexAttribArray(x.uv), this.gl.disable(this.gl.CULL_FACE), this.gl.enable(this.gl.BLEND), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.vertexAttribPointer(x.position, 2, this.gl.FLOAT, !1, 16, 0), this.gl.vertexAttribPointer(x.uv, 2, this.gl.FLOAT, !1, 16, 8), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.uniformMatrix4fv(D.projectionMatrix, !1, g.projectionMatrix.elements), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.uniform1i(D.map, 0);
                var z = 0, T = 0, B = h.fog;
                B ? (this.gl.uniform3f(D.fogColor, B.color.r, B.color.g, B.color.b), this.gl.uniform1f(D.fogNear, B.near), this.gl.uniform1f(D.fogFar, B.far), this.gl.uniform1i(D.fogType, 1), z = 1, T = 1) : (this.gl.uniform1i(D.fogType, 0), z = 0, T = 0);
                var W;
                let k, F, U, V, H = [];
                for (W = 0; W < p; W++)
                  k = a[W], F = k.material, F && (F.depthTest == !1 && !S || !k.visible || F.opacity === 0 || (F.useScreenCoordinates ? k.z = -k.position.z : (k._modelViewMatrix.multiplyMatrices(g.matrixWorldInverse, k.matrixWorld), k.z = -k._modelViewMatrix.elements[14])));
                for (a.sort(E), W = 0; W < p; W++)
                  if (k = a[W], F = k.material, !!F && !(!k.visible || F.opacity === 0) && F.map && F.map.image && F.map.image.width) {
                    this.gl.uniform1f((D == null ? void 0 : D.alphaTest) || null, F.alphaTest);
                    var G = F.map.image.width, Y = F.map.image.height;
                    H[0] = G * this.renderer.devicePixelRatio / C, H[1] = Y * this.renderer.devicePixelRatio / c, F.useScreenCoordinates === !0 ? (this.gl.uniform1i(D.useScreenCoordinates, 1), this.gl.uniform3f(D.screenPosition, (k.position.x * this.renderer.devicePixelRatio - O) / O, (R - k.position.y * this.renderer.devicePixelRatio) / R, Math.max(0, Math.min(1, k.position.z)))) : (this.gl.uniform1i(D.useScreenCoordinates, 0), this.gl.uniformMatrix4fv(D.modelViewMatrix, !1, k._modelViewMatrix.elements)), h.fog && F.fog ? V = T : V = 0, z !== V && (this.gl.uniform1i(D.fogType, V), z = V), U = 1 / (F.scaleByViewport ? c : 1), H[0] *= U * k.scale.x, H[1] *= U * k.scale.y;
                    let J = (b = F == null ? void 0 : F.alignment) === null || b === void 0 ? void 0 : b.x, re = (w = F == null ? void 0 : F.alignment) === null || w === void 0 ? void 0 : w.y;
                    F.screenOffset && (J = (J || 0) + 2 * F.screenOffset.x / G, re = (re || 0) + 2 * F.screenOffset.y / Y), this.gl.uniform2f(D.uvScale, ((t = F == null ? void 0 : F.uvScale) === null || t === void 0 ? void 0 : t.x) || 1, ((r = F == null ? void 0 : F.uvScale) === null || r === void 0 ? void 0 : r.y) || 1), this.gl.uniform2f(D.uvOffset, ((u = F == null ? void 0 : F.uvOffset) === null || u === void 0 ? void 0 : u.x) || 0, ((o = F == null ? void 0 : F.uvOffset) === null || o === void 0 ? void 0 : o.y) || 0), this.gl.uniform2f(D.alignment, J || 0, re || 0), this.gl.uniform1f(D.opacity, F.opacity), this.gl.uniform3f(D.color, ((l = F == null ? void 0 : F.color) === null || l === void 0 ? void 0 : l.r) || 0, ((e = F == null ? void 0 : F.color) === null || e === void 0 ? void 0 : e.g) || 0, ((n = F == null ? void 0 : F.color) === null || n === void 0 ? void 0 : n.b) || 0), this.gl.uniform1f(D.rotation, k.rotation), this.gl.uniform2fv(D.scale, H), this.renderer.setDepthTest(F.depthTest), this.renderer.setDepthWrite(F.depthWrite), this.renderer.setTexture(F.map, 0), this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
                  }
                this.gl.enable(this.gl.CULL_FACE);
              }
              createProgram(h, g) {
                if (!this.gl)
                  throw new Error("WebGL Rendering context not found");
                var C = this.gl.createProgram();
                if (!C)
                  throw new Error("Error creating webgl program");
                var c = this.gl.createShader(this.gl.FRAGMENT_SHADER), S = this.gl.createShader(this.gl.VERTEX_SHADER);
                if (!c)
                  throw new Error("Unable to create fragment shader SpritePlugin.createProgram");
                if (!S)
                  throw new Error("Unable to create vertex shader SpritePlugin.createProgram");
                var y = "precision " + g + ` float;
`;
                if (this.gl.shaderSource(c, y + h.fragmentShader), this.gl.shaderSource(S, y + h.vertexShader), this.gl.compileShader(c), this.gl.compileShader(S), !this.gl.getShaderParameter(c, this.gl.COMPILE_STATUS) || !this.gl.getShaderParameter(S, this.gl.COMPILE_STATUS))
                  throw new Error(`Error compiling shader: 
      ${this.gl.getShaderInfoLog(c)} 
      ${this.gl.getShaderInfoLog(S)}`);
                return this.gl.attachShader(C, c), this.gl.attachShader(C, S), this.gl.linkProgram(C), this.gl.getProgramParameter(C, this.gl.LINK_STATUS) || console.error("Could not initialize shader"), C;
              }
            }
            function E(A, h) {
              return A.z !== h.z ? h.z - A.z : h.id - A.id;
            }
          }
        ),
        /***/
        "./src/WebGL/constants/Coloring.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/constants/Coloring.ts ***!
            \*****************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Coloring: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            var v;
            (function(M) {
              M[M.NoColors = 0] = "NoColors", M[M.FaceColors = 1] = "FaceColors", M[M.VertexColors = 2] = "VertexColors";
            })(v || (v = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Shading.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/constants/Shading.ts ***!
            \****************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Shading: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            var v;
            (function(M) {
              M[M.NoShading = 0] = "NoShading", M[M.FlatShading = 1] = "FlatShading", M[M.SmoothShading = 2] = "SmoothShading";
            })(v || (v = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Sides.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/Sides.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              BackSide: () => (
                /* binding */
                M
              ),
              /* harmony export */
              DoubleSide: () => (
                /* binding */
                E
              ),
              /* harmony export */
              FrontSide: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = 0, M = 1, E = 2;
          }
        ),
        /***/
        "./src/WebGL/constants/SpriteAlignment.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/constants/SpriteAlignment.ts ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SpriteAlignment: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const M = {
              topLeft: new v.Vector2(1, -1),
              topCenter: new v.Vector2(0, -1),
              topRight: new v.Vector2(-1, -1),
              centerLeft: new v.Vector2(1, 0),
              center: new v.Vector2(0, 0),
              centerRight: new v.Vector2(-1, 0),
              bottomLeft: new v.Vector2(1, 1),
              bottomCenter: new v.Vector2(0, 1),
              bottomRight: new v.Vector2(-1, 1)
            };
          }
        ),
        /***/
        "./src/WebGL/constants/TextureConstants.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/constants/TextureConstants.ts ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* binding */
                v
              ),
              /* harmony export */
              FloatType: () => (
                /* binding */
                g
              ),
              /* harmony export */
              LinearFilter: () => (
                /* binding */
                M
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* binding */
                A
              ),
              /* harmony export */
              NearestFilter: () => (
                /* binding */
                E
              ),
              /* harmony export */
              R32Format: () => (
                /* binding */
                S
              ),
              /* harmony export */
              RFormat: () => (
                /* binding */
                c
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* binding */
                C
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            const v = 1001, M = 1006, E = 1007, A = 1008, h = 1009, g = 1010, C = 1021, c = 1022, S = 1023;
          }
        ),
        /***/
        "./src/WebGL/constants/TextureOperations.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/constants/TextureOperations.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              TextureOperations: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            var v;
            (function(M) {
              M[M.MultiplyOperation = 0] = "MultiplyOperation", M[M.MixOperation = 1] = "MixOperation", M[M.AddOperation = 2] = "AddOperation";
            })(v || (v = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/index.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                M.BackSide
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                h.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                v.Coloring
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                M.DoubleSide
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                h.FloatType
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                M.FrontSide
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                h.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                h.LinearMipMapLinearFilter
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                h.NearestFilter
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                h.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                h.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                h.RGBAFormat
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                E.Shading
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                A.SpriteAlignment
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                g.TextureOperations
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                h.UnsignedByteType
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), M = s(
              /*! ./Sides */
              "./src/WebGL/constants/Sides.ts"
            ), E = s(
              /*! ./Shading */
              "./src/WebGL/constants/Shading.ts"
            ), A = s(
              /*! ./SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), h = s(
              /*! ./TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), g = s(
              /*! ./TextureOperations */
              "./src/WebGL/constants/TextureOperations.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/core/EventDispatcher.ts": (
          /*!*******************************************!*\
            !*** ./src/WebGL/core/EventDispatcher.ts ***!
            \*******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              EventDispatcher: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            class v {
              constructor() {
                this.listeners = {};
              }
              dispatchEvent(E) {
                var A = this.listeners[E.type];
                if (A !== void 0) {
                  E.target = this;
                  for (var h = 0, g = A.length; h < g; h++)
                    A[h].call(this, E);
                }
              }
              removeEventListener(E, A) {
                if (!A)
                  this.listeners[E] = [];
                else {
                  var h = this.listeners[E].indexOf(A);
                  h !== -1 && this.listeners[E].splice(h, 1);
                }
              }
              addEventListener(E, A) {
                this.listeners[E] === void 0 && (this.listeners[E] = []), this.listeners[E].indexOf(A) === -1 && this.listeners[E].push(A);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Geometry.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Geometry.ts ***!
            \************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Geometry: () => (
                /* binding */
                C
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* binding */
                g
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* binding */
                c
              )
              /* harmony export */
            });
            var v = s(
              /*! ../materials/LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), M = s(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), E = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), A = s(
              /*! ../../colors */
              "./src/colors.ts"
            );
            const h = 65535;
            class g {
              constructor(y = 0) {
                this.vertexArray = null, this.colorArray = null, this.normalArray = null, this.radiusArray = null, this.faceArray = null, this.lineArray = null, this.vertices = 0, this.faceidx = 0, this.lineidx = 0, this.__inittedArrays = !1, this.id = y;
              }
              setColors(y) {
                var b = this.vertexArray, w = this.colorArray;
                if (!b)
                  throw new Error("vertex array not initialized");
                if (!w)
                  throw new Error("color array not initialized");
                if (b.length != w.length) {
                  console.log("Cannot re-color geometry group due to mismatched lengths.");
                  return;
                }
                for (var t = 0; t < b.length; t += 3) {
                  var r = y(b[t], b[t + 1], b[t + 2]);
                  r instanceof A.Color || (r = A.CC.color(r)), w[t] = r.r, w[t + 1] = r.g, w[t + 2] = r.b;
                }
              }
              getNumVertices() {
                return this.vertices;
              }
              getVertices() {
                return this.vertexArray;
              }
              getCentroid() {
                if (!this.vertexArray)
                  throw new Error("vertex array not initialized");
                for (var y = new E.Vector3(), b, w, t, r, u = 0; u < this.vertices; ++u)
                  b = u * 3, w = this.vertexArray[b], t = this.vertexArray[b + 1], r = this.vertexArray[b + 2], y.x += w, y.y += t, y.z += r;
                return y.divideScalar(this.vertices), y;
              }
              //setup normals - vertex and face array must exist
              setNormals() {
                var y = this.faceArray, b = this.vertexArray, w = this.normalArray;
                if (!(!this.vertices || !this.faceidx)) {
                  if (!y)
                    throw new Error("face array not initialized");
                  if (!b)
                    throw new Error("vertex array not initialized");
                  if (!w)
                    throw new Error("normal array not initialized");
                  for (var t, r, u, o, l, e, n, a = 0; a < y.length / 3; ++a)
                    t = y[a * 3] * 3, r = y[a * 3 + 1] * 3, u = y[a * 3 + 2] * 3, o = new E.Vector3(b[t], b[t + 1], b[t + 2]), l = new E.Vector3(b[r], b[r + 1], b[r + 2]), e = new E.Vector3(b[u], b[u + 1], b[u + 2]), o.subVectors(o, l), e.subVectors(e, l), e.cross(o), n = e, n.normalize(), w[t] += n.x, w[r] += n.x, w[u] += n.x, w[t + 1] += n.y, w[r + 1] += n.y, w[u + 1] += n.y, w[t + 2] += n.z, w[r + 2] += n.z, w[u + 2] += n.z;
                }
              }
              /* sets line index array from face arr
              Note - assumes all faces are triangles (i.e. there will
              be an extra diagonal for four-sided faces - user should
              specify linearr for custom shape generation to show wireframe squares
              as rectangles rather than two triangles) */
              setLineIndices() {
                if (this.faceidx && !(this.lineArray && this.lineArray.length == this.faceidx * 2 && this.lineidx == this.faceidx * 2)) {
                  var y = this.faceArray, b = this.lineArray = new Uint16Array(this.faceidx * 2);
                  if (this.lineidx = this.faceidx * 2, !y)
                    throw new Error("face array not initialized");
                  for (var w = 0; w < this.faceidx / 3; ++w) {
                    var t = w * 3, r = t * 2, u = y[t], o = y[t + 1], l = y[t + 2];
                    b[r] = u, b[r + 1] = o, b[r + 2] = u, b[r + 3] = l, b[r + 4] = o, b[r + 5] = l;
                  }
                }
              }
              vrml(y, b) {
                var w, t, r, u, o, l, e, n, a, p, x, D, O, R, z, T = "";
                T += y + `Shape {
` + y + ` appearance Appearance {
` + y + `  material Material {
` + y + "   diffuseColor " + ((w = b == null ? void 0 : b.color) === null || w === void 0 ? void 0 : w.r) + " " + ((t = b == null ? void 0 : b.color) === null || t === void 0 ? void 0 : t.g) + " " + ((r = b == null ? void 0 : b.color) === null || r === void 0 ? void 0 : r.b) + `
`, b != null && b.transparent && (T += y + "   transparency " + (1 - b.opacity) + `
`), T += y + `  }
`, T += y + ` }
`;
                var B = y;
                if (y += " ", b instanceof v.LineBasicMaterial) {
                  T += y + `geometry IndexedLineSet {
` + y + ` colorPerVertex TRUE
` + y + ` coord Coordinate {
` + y + `  point [
`;
                  let k, F, U;
                  for (let V = 0; V < this.vertices; ++V) {
                    let H = V * 3;
                    k = (u = this.vertexArray) === null || u === void 0 ? void 0 : u[H], F = (o = this.vertexArray) === null || o === void 0 ? void 0 : o[H + 1], U = (l = this.vertexArray) === null || l === void 0 ? void 0 : l[H + 2], T += y + "   " + k + " " + F + " " + U + `,
`;
                  }
                  if (T += y + `  ]
`, T += y + ` }
`, this.colorArray) {
                    T += y + ` color Color {
` + y + `  color [
`;
                    for (let V = 0; V < this.vertices; ++V) {
                      let H = V * 3;
                      k = this.colorArray[H], F = this.colorArray[H + 1], U = this.colorArray[H + 2], T += y + "   " + k + " " + F + " " + U + `,
`;
                    }
                    T += y + `  ]
`, T += y + ` }
`;
                  }
                  T += y + ` coordIndex [
`;
                  for (let V = 0; V < this.vertices; V += 2)
                    T += y + "  " + V + ", " + (V + 1) + `, -1,
`;
                  T += y + ` ]
`, T += y + `}
`;
                } else {
                  T += y + `geometry IndexedFaceSet {
` + y + ` colorPerVertex TRUE
` + y + ` normalPerVertex TRUE
` + y + ` solid FALSE
`, T += y + ` coord Coordinate {
` + y + `  point [
`;
                  let k, F, U;
                  for (let V = 0; V < this.vertices; ++V) {
                    let H = V * 3;
                    k = (e = this.vertexArray) === null || e === void 0 ? void 0 : e[H], F = (n = this.vertexArray) === null || n === void 0 ? void 0 : n[H + 1], U = (a = this.vertexArray) === null || a === void 0 ? void 0 : a[H + 2], T += y + "   " + k + " " + F + " " + U + `,
`;
                  }
                  T += y + `  ]
`, T += y + ` }
`, T += y + ` normal Normal {
` + y + `  vector [
`;
                  for (let V = 0; V < this.vertices; ++V) {
                    let H = V * 3;
                    k = (p = this.normalArray) === null || p === void 0 ? void 0 : p[H], F = (x = this.normalArray) === null || x === void 0 ? void 0 : x[H + 1], U = (D = this.normalArray) === null || D === void 0 ? void 0 : D[H + 2], T += y + "   " + k + " " + F + " " + U + `,
`;
                  }
                  if (T += y + `  ]
`, T += y + ` }
`, this.colorArray) {
                    T += y + ` color Color {
` + y + `  color [
`;
                    for (let V = 0; V < this.vertices; ++V) {
                      let H = V * 3;
                      k = this.colorArray[H], F = this.colorArray[H + 1], U = this.colorArray[H + 2], T += y + "   " + k + " " + F + " " + U + `,
`;
                    }
                    T += y + `  ]
`, T += y + ` }
`;
                  }
                  T += y + ` coordIndex [
`;
                  for (var W = 0; W < this.faceidx; W += 3)
                    k = (O = this.faceArray) === null || O === void 0 ? void 0 : O[W], F = (R = this.faceArray) === null || R === void 0 ? void 0 : R[W + 1], U = (z = this.faceArray) === null || z === void 0 ? void 0 : z[W + 2], T += y + "  " + k + ", " + F + ", " + U + `, -1,
`;
                  T += y + ` ]
`, T += y + `}
`;
                }
                return T += B + "}", T;
              }
              truncateArrayBuffers(y = !0, b = !1) {
                var w = this.vertexArray, t = this.colorArray, r = this.normalArray, u = this.faceArray, o = this.lineArray, l = this.radiusArray;
                this.vertexArray = (w == null ? void 0 : w.subarray(0, this.vertices * 3)) || null, this.colorArray = (t == null ? void 0 : t.subarray(0, this.vertices * 3)) || null, y ? (this.normalArray = (r == null ? void 0 : r.subarray(0, this.vertices * 3)) || null, this.faceArray = (u == null ? void 0 : u.subarray(0, this.faceidx)) || null, this.lineidx > 0 ? this.lineArray = (o == null ? void 0 : o.subarray(0, this.lineidx)) || null : this.lineArray = new Uint16Array(0)) : (this.normalArray = new Float32Array(0), this.faceArray = new Uint16Array(0), this.lineArray = new Uint16Array(0)), l && (this.radiusArray = l.subarray(0, this.vertices)), b && (this.normalArray && (this.normalArray = new Float32Array(this.normalArray)), this.faceArray && (this.faceArray = new Uint16Array(this.faceArray)), this.lineArray && (this.lineArray = new Uint16Array(this.lineArray)), this.vertexArray && (this.vertexArray = new Float32Array(this.vertexArray)), this.colorArray && (this.colorArray = new Float32Array(this.colorArray)), this.radiusArray && (this.radiusArray = new Float32Array(this.radiusArray))), this.__inittedArrays = !0;
              }
            }
            class C extends M.EventDispatcher {
              constructor(y = !1, b = !1, w = !1) {
                super(), this.name = "", this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.buffersNeedUpdate = !1, this.imposter = !1, this.instanced = !1, this.geometryGroups = [], this.groups = 0, this.id = c++, this.mesh = y, this.radii = b, this.offset = w;
              }
              //Get geometry group to accomodate addVertices new vertices - create
              // new group if necessary
              updateGeoGroup(y = 0) {
                var b, w = this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;
                return (!w || w.vertices + y > (((b = w == null ? void 0 : w.vertexArray) === null || b === void 0 ? void 0 : b.length) || 0) / 3) && (w = this.addGeoGroup()), w;
              }
              //return comma separated list of IndexedFace (or Line) sets from geometry groups
              vrml(y, b) {
                for (var w = "", t = this.geometryGroups.length, r = 0; r < t; r++) {
                  var u = this.geometryGroups[r];
                  w += u.vrml(y, b) + `,
`;
                }
                return w;
              }
              addGeoGroup() {
                var y = new g(this.geometryGroups.length);
                return this.geometryGroups.push(y), this.groups = this.geometryGroups.length, y.vertexArray = new Float32Array(h * 3), y.colorArray = new Float32Array(h * 3), this.mesh && (y.normalArray = new Float32Array(h * 3), y.faceArray = new Uint16Array(h * 6), y.lineArray = new Uint16Array(h * 6)), this.radii && (y.radiusArray = new Float32Array(h)), y.useOffset = this.offset, y;
              }
              setUpNormals(...y) {
                for (var b = 0; b < this.groups; b++) {
                  var w = this.geometryGroups[b];
                  w.setNormals(...y);
                }
              }
              setColors(...y) {
                for (var b = this.geometryGroups.length, w = 0; w < b; w++) {
                  var t = this.geometryGroups[w];
                  t.setColors(...y);
                }
              }
              setUpWireframe(...y) {
                for (var b = 0; b < this.groups; b++) {
                  var w = this.geometryGroups[b];
                  w.setLineIndices(...y);
                }
              }
              //After vertices, colors, etc are collected in regular or typed arrays,
              //  create typed arrays from regular arrays if they don't already exist,
              initTypedArrays() {
                for (var y = 0; y < this.groups; y++) {
                  var b = this.geometryGroups[y];
                  b.__inittedArrays !== !0 && b.truncateArrayBuffers(this.mesh, !1);
                }
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
              get vertices() {
                for (var y = 0, b = 0; b < this.groups; b++)
                  y += this.geometryGroups[b].vertices;
                return y;
              }
            }
            let c = 0;
          }
        ),
        /***/
        "./src/WebGL/core/Object3D.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Object3D.ts ***!
            \************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Light: () => (
                /* binding */
                g
              ),
              /* harmony export */
              Object3D: () => (
                /* binding */
                A
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* binding */
                E
              ),
              /* harmony export */
              Scene: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), M = s(
              /*! ../../colors */
              "./src/colors.ts"
            );
            let E = 0;
            class A {
              constructor() {
                this.id = E++, this.name = "", this.children = [], this.position = new v.Vector3(), this.rotation = new v.Vector3(), this.matrix = new v.Matrix4(), this.matrixWorld = new v.Matrix4(), this.quaternion = new v.Quaternion(), this.eulerOrder = "XYZ", this.up = new v.Vector3(0, 1, 0), this.scale = new v.Vector3(1, 1, 1), this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !0, this.rotationAutoUpdate = !0, this.useQuaternion = !1, this.visible = !0;
              }
              lookAt(c) {
                this.matrix.lookAt(c, this.position, this.up), this.rotationAutoUpdate && (this.useQuaternion === !0 ? console.error("Unimplemented math operation.") : this.rotation instanceof v.Vector3 && this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder));
              }
              //add child object
              add(c) {
                if (c === this) {
                  console.error("Can't add $3Dmol.Object3D to itself");
                  return;
                }
                c.parent = this, this.children.push(c);
                for (var S = this; S.parent !== void 0; )
                  S = S.parent;
                S !== void 0 && S instanceof h && S.__addObject(c);
              }
              remove(c) {
                var S = this.children.indexOf(c);
                if (S !== -1) {
                  c.parent = void 0, this.children.splice(S, 1);
                  for (var y = this; y.parent !== void 0; )
                    y = y.parent;
                  y !== void 0 && y instanceof h && y.__removeObject(c);
                }
              }
              //convert to vrml
              vrml(c) {
                c || (c = " ");
                var S = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w), y = 0, b = 0, w = 0;
                if (S != 0) {
                  let u = Math.sin(S / 2);
                  y = this.quaternion.x / u, b = this.quaternion.y / u, w = this.quaternion.z / u;
                }
                var t = c + `Transform {
` + c + " center " + this.position.x + " " + this.position.y + " " + this.position.z + `
` + c + " rotation " + y + " " + b + " " + w + " " + S + `
` + c + ` children [
`;
                this.geometry && (t += this.geometry.vrml(c, this.material));
                for (var r = 0; r < this.children.length; r++)
                  t += this.children[r].vrml(c + " ") + `,
`;
                return t += ` ]
`, t += "}", t;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.useQuaternion === !1 && this.rotation instanceof v.Vector3 ? this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder) : this.matrix.setRotationFromQuaternion(this.quaternion), (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              updateMatrixWorld(c) {
                this.matrixAutoUpdate === !0 && this.updateMatrix(), (this.matrixWorldNeedsUpdate === !0 || c === !0) && (this.parent === void 0 ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1;
                for (var S = 0; S < this.children.length; S++)
                  this.children[S].updateMatrixWorld(!0);
              }
              clone(c) {
                c === void 0 && (c = new A()), c.name = this.name, c.up.copy(this.up), c.position.copy(this.position), c.rotation instanceof v.Vector3 && this.rotation instanceof v.Vector3 ? c.rotation.copy(this.rotation) : c.rotation = this.rotation, c.eulerOrder = this.eulerOrder, c.scale.copy(this.scale), c.rotationAutoUpdate = this.rotationAutoUpdate, c.matrix.copy(this.matrix), c.matrixWorld.copy(this.matrixWorld), c.quaternion.copy(this.quaternion), c.matrixAutoUpdate = this.matrixAutoUpdate, c.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, c.useQuaternion = this.useQuaternion, c.visible = this.visible;
                for (var S = 0; S < this.children.length; S++) {
                  var y = this.children[S];
                  c.add(y.clone());
                }
                return c;
              }
              setVisible(c) {
                this.visible = c;
                for (var S = 0; S < this.children.length; S++) {
                  var y = this.children[S];
                  y.setVisible(c);
                }
              }
            }
            class h extends A {
              constructor() {
                super(...arguments), this.fog = null, this.overrideMaterial = null, this.matrixAutoUpdate = !1, this.__objects = [], this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = [];
              }
              __addObject(c) {
                if (c instanceof g)
                  this.__lights.indexOf(c) === -1 && this.__lights.push(c), c.target && c.target.parent === void 0 && this.add(c.target);
                else if (this.__objects.indexOf(c) === -1) {
                  this.__objects.push(c), this.__objectsAdded.push(c);
                  var S = this.__objectsRemoved.indexOf(c);
                  S !== -1 && this.__objectsRemoved.splice(S, 1);
                }
                for (var y = 0; y < c.children.length; y++)
                  this.__addObject(c.children[y]);
              }
              __removeObject(c) {
                var S;
                if (c instanceof g)
                  S = this.__lights.indexOf(c), S !== -1 && this.__lights.splice(S, 1);
                else if (S = this.__objects.indexOf(c), S !== -1) {
                  this.__objects.splice(S, 1), this.__objectsRemoved.push(c);
                  var y = this.__objectsAdded.indexOf(c);
                  y !== -1 && this.__objectsAdded.splice(S, 1);
                }
                for (var b = 0; b < c.children.length; b++)
                  this.__removeObject(c.children[b]);
              }
            }
            class g extends A {
              constructor(c, S = 1) {
                super(), this.position = new v.Vector3(0, 1, 0), this.target = new A(), this.castShadow = !1, this.onlyShadow = !1, this.color = new M.Color(c), this.intensity = S;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Projector.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Projector.ts ***!
            \*************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Projector: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const M = new v.Matrix4();
            class E {
              static unprojectVector(h, g) {
                return g.projectionMatrixInverse.getInverse(g.projectionMatrix), M.multiplyMatrices(g.matrixWorld, g.projectionMatrixInverse), h.applyProjection(M);
              }
              static projectVector(h, g) {
                return g.matrixWorldInverse.getInverse(g.matrixWorld), M.multiplyMatrices(g.projectionMatrix, g.matrixWorldInverse), h.applyProjection(M);
              }
              projectVector(h, g) {
                return E.projectVector(h, g);
              }
              unprojectVector(h, g) {
                return E.unprojectVector(h, g);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Raycaster.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Raycaster.ts ***!
            \*************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Raycaster: () => (
                /* binding */
                h
              ),
              /* harmony export */
              intersectObject: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), M = s(
              /*! ../shapes */
              "./src/WebGL/shapes/index.ts"
            );
            const E = (o, l) => o.distance - l.distance, A = new v.Matrix4();
            class h {
              constructor(l, e, n, a) {
                this.precision = 1e-4, this.linePrecision = 0.2, this.ray = new v.Ray(l, e), this.ray.direction.lengthSq() > 0 && this.ray.direction.normalize(), this.near = a || 0, this.far = n || 1 / 0;
              }
              set(l, e) {
                this.ray.set(l, e);
              }
              setFromCamera(l, e) {
                e.ortho ? (this.ray.origin.set(l.x, l.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(l.x, l.y, l.z), e.projectionMatrixInverse.getInverse(e.projectionMatrix), A.multiplyMatrices(e.matrixWorld, e.projectionMatrixInverse), this.ray.direction.applyProjection(A), this.ray.direction.sub(this.ray.origin).normalize());
              }
              intersectObjects(l, e) {
                for (var n = [], a = 0, p = e.length; a < p; a++)
                  u(l, e[a], this, n);
                return n.sort(E), n;
              }
            }
            const g = (o) => Math.min(Math.max(o, -1), 1);
            var C = new M.Sphere(), c = new M.Cylinder(), S = new M.Triangle(), y = new v.Vector3(), b = new v.Vector3(), w = new v.Vector3(), t = new v.Vector3(), r = new v.Vector3();
            function u(o, l, e, n) {
              if (r.getPositionFromMatrix(o.matrixWorld), l.intersectionShape === void 0)
                return n;
              var a = l.intersectionShape, p = e.linePrecision;
              p *= o.matrixWorld.getMaxScaleOnAxis();
              var x = p * p;
              if (l.boundingSphere !== void 0 && l.boundingSphere instanceof M.Sphere && (C.copy(l.boundingSphere), C.applyMatrix4(o.matrixWorld), !e.ray.isIntersectionSphere(C)))
                return n;
              var D, O, R, z, T, B, W, k, F, U, V, H, G, Y;
              for (D = 0, O = a.triangle.length; D < O; D++)
                if (a.triangle[D] instanceof M.Triangle) {
                  if (S.copy(a.triangle[D]), S.applyMatrix4(o.matrixWorld), R = S.getNormal(), z = e.ray.direction.dot(R), z >= 0 || (y.subVectors(S.a, e.ray.origin), W = R.dot(y) / z, W < 0))
                    continue;
                  b.copy(e.ray.direction).multiplyScalar(W).add(e.ray.origin), b.sub(S.a), w.copy(S.b).sub(S.a), t.copy(S.c).sub(S.a);
                  var J = w.dot(t), re = w.lengthSq(), le = t.lengthSq();
                  if (H = (re * b.dot(t) - J * b.dot(w)) / (re * le - J * J), H < 0 || H > 1 || (V = (b.dot(w) - H * J) / re, V < 0 || V > 1 || V + H > 1))
                    continue;
                  n.push({ clickable: l, distance: W });
                }
              for (D = 0, O = a.cylinder.length; D < O; D++)
                if (a.cylinder[D] instanceof M.Cylinder) {
                  if (c.copy(a.cylinder[D]), c.applyMatrix4(o.matrixWorld), y.subVectors(c.c1, e.ray.origin), T = y.dot(c.direction), B = y.dot(e.ray.direction), z = g(e.ray.direction.dot(c.direction)), F = 1 - z * z, F === 0)
                    continue;
                  G = (z * B - T) / F, Y = (B - z * T) / F, b.copy(c.direction).multiplyScalar(G).add(c.c1), w.copy(e.ray.direction).multiplyScalar(Y).add(e.ray.origin), k = t.subVectors(b, w).lengthSq();
                  var ie = c.radius * c.radius;
                  if (k <= ie) {
                    if (U = (z * T - B) * (z * T - B) - F * (y.lengthSq() - T * T - ie), U <= 0 ? H = W = Math.sqrt(k) : H = W = (B - z * T - Math.sqrt(U)) / F, V = z * H - T, V < 0 || V * V > c.lengthSq() || H < 0)
                      continue;
                    n.push({ clickable: l, distance: W });
                  }
                }
              for (D = 0, O = a.line.length; D < O; D += 2) {
                b.copy(a.line[D]), b.applyMatrix4(o.matrixWorld), w.copy(a.line[D + 1]), w.applyMatrix4(o.matrixWorld), t.subVectors(w, b);
                var xe = t.lengthSq();
                t.normalize(), y.subVectors(b, e.ray.origin);
                var se = y.dot(t);
                B = y.dot(e.ray.direction), z = g(e.ray.direction.dot(t)), F = 1 - z * z, F !== 0 && (G = (z * B - se) / F, Y = (B - z * se) / F, b.add(t.multiplyScalar(G)), w.copy(e.ray.direction).multiplyScalar(Y).add(e.ray.origin), k = t.subVectors(w, b).lengthSq(), k < x && G * G < xe && n.push({ clickable: l, distance: Y }));
              }
              for (D = 0, O = a.sphere.length; D < O; D++)
                if (a.sphere[D] instanceof M.Sphere && (C.copy(a.sphere[D]), C.applyMatrix4(o.matrixWorld), e.ray.isIntersectionSphere(C))) {
                  b.subVectors(C.center, e.ray.origin);
                  var ce = b.dot(e.ray.direction);
                  if (U = ce * ce - (b.lengthSq() - C.radius * C.radius), ce < 0)
                    return n;
                  U <= 0 ? W = ce : W = ce - Math.sqrt(U), n.push({ clickable: l, distance: W });
                }
              return n;
            }
          }
        ),
        /***/
        "./src/WebGL/core/Texture.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/core/Texture.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Texture: () => (
                /* binding */
                h
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ../constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), M = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), E = s(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), A = s(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
            class h extends E.EventDispatcher {
              constructor(c, S) {
                super(), this.id = g++, this.name = "", this.image = c, this.mapping = new A.UVMapping(), this.wrapS = v.ClampToEdgeWrapping, this.wrapT = v.ClampToEdgeWrapping, this.anisotropy = 1, S ? (this.format = v.RFormat, this.type = v.FloatType, this.premultiplyAlpha = !1, this.flipY = !1, this.unpackAlignment = 1, this.magFilter = v.NearestFilter, this.minFilter = v.NearestFilter) : (this.format = v.RGBAFormat, this.type = v.UnsignedByteType, this.offset = new M.Vector2(0, 0), this.repeat = new M.Vector2(1, 1), this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.magFilter = v.LinearFilter, this.minFilter = v.LinearMipMapLinearFilter), this.needsUpdate = !1, this.onUpdate = null;
              }
              clone(c = new h()) {
                return c.image = this.image, c.mapping = this.mapping, c.wrapS = this.wrapS, c.wrapT = this.wrapT, c.magFilter = this.magFilter, c.minFilter = this.minFilter, c.anisotropy = this.anisotropy, c.format = this.format, c.type = this.type, c.offset.copy(this.offset), c.repeat.copy(this.repeat), c.premultiplyAlpha = this.premultiplyAlpha, c.flipY = this.flipY, c.unpackAlignment = this.unpackAlignment, c;
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let g = 0;
          }
        ),
        /***/
        "./src/WebGL/core/UVMapping.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/UVMapping.ts ***!
            \*************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              UVMapping: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            class v {
            }
          }
        ),
        /***/
        "./src/WebGL/core/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/core/index.ts ***!
            \*********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                v.EventDispatcher
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                M.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                M.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                M.GeometryIDCount
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                E.Light
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                E.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                E.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                A.Projector
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                h.Raycaster
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                E.Scene
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                g.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                g.TextureIdCount
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                C.UVMapping
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                h.intersectObject
              )
              /* harmony export */
            });
            var v = s(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), M = s(
              /*! ./Geometry */
              "./src/WebGL/core/Geometry.ts"
            ), E = s(
              /*! ./Object3D */
              "./src/WebGL/core/Object3D.ts"
            ), A = s(
              /*! ./Projector */
              "./src/WebGL/core/Projector.ts"
            ), h = s(
              /*! ./Raycaster */
              "./src/WebGL/core/Raycaster.ts"
            ), g = s(
              /*! ./Texture */
              "./src/WebGL/core/Texture.ts"
            ), C = s(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/index.ts": (
          /*!****************************!*\
            !*** ./src/WebGL/index.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                v.BackSide
              ),
              /* harmony export */
              Camera: () => (
                /* reexport safe */
                c.Camera
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                v.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                v.Coloring
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                C.Cylinder
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                v.DoubleSide
              ),
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                M.EventDispatcher
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                v.FloatType
              ),
              /* harmony export */
              Fog: () => (
                /* reexport safe */
                S.Fog
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                v.FrontSide
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                M.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                M.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                M.GeometryIDCount
              ),
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                E.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                E.InstancedMaterial
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                M.Light
              ),
              /* harmony export */
              Line: () => (
                /* reexport safe */
                h.Line
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                E.LineBasicMaterial
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                h.LineStyle
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                v.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                v.LinearMipMapLinearFilter
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                E.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                E.MaterialIdCount
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                A.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                A.Matrix4
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                h.Mesh
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                E.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                E.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                E.MeshOutlineMaterial
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                v.NearestFilter
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                M.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                M.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                M.Projector
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                A.Quaternion
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                v.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                v.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                v.RGBAFormat
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                A.Ray
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                M.Raycaster
              ),
              /* harmony export */
              Renderer: () => (
                /* reexport safe */
                y.Renderer
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                M.Scene
              ),
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                g.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                g.ShaderUtils
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                v.Shading
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                C.Sphere
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                E.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                E.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                h.Sprite
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                v.SpriteAlignment
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                E.SpriteMaterial
              ),
              /* harmony export */
              SpritePlugin: () => (
                /* reexport safe */
                b.SpritePlugin
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                E.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                E.StickImposterOutlineMaterial
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                M.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                M.TextureIdCount
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                v.TextureOperations
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                C.Triangle
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                M.UVMapping
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                v.UnsignedByteType
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                A.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                A.Vector3
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                E.VolumetricMaterial
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                g.basic
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                A.clamp
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                g.clone
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                A.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                A.degToRad
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                g.instanced
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                M.intersectObject
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                g.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                g.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                g.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                g.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                g.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                g.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                g.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                g.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                g.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                g.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                g.volumetric
              )
              /* harmony export */
            });
            var v = s(
              /*! ./constants */
              "./src/WebGL/constants/index.ts"
            ), M = s(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), E = s(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), A = s(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), h = s(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), g = s(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), C = s(
              /*! ./shapes */
              "./src/WebGL/shapes/index.ts"
            ), c = s(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), S = s(
              /*! ./Fog */
              "./src/WebGL/Fog.ts"
            ), y = s(
              /*! ./Renderer */
              "./src/WebGL/Renderer.ts"
            ), b = s(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/materials/ImposterMaterial.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/materials/ImposterMaterial.ts ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ImposterMaterial: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), M = s(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), E = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), A = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class g extends h.Material {
              constructor(c) {
                super(), this.color = new E.Color(16777215), this.ambient = new E.Color(1048575), this.emissive = new E.Color(0), this.imposter = !0, this.wrapAround = !1, this.wrapRGB = new A.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = M.Shading.SmoothShading, this.shaderID = null, this.vertexColors = v.Coloring.NoColors, this.skinning = !1, this.setValues(c);
              }
              clone(c = new g()) {
                return super.clone.call(this, c), c.color.copy(this.color), c.ambient.copy(this.ambient), c.emissive.copy(this.emissive), c.wrapAround = this.wrapAround, c.wrapRGB.copy(this.wrapRGB), c.map = this.map, c.lightMap = this.lightMap, c.specularMap = this.specularMap, c.envMap = this.envMap, c.combine = this.combine, c.reflectivity = this.reflectivity, c.refractionRatio = this.refractionRatio, c.fog = this.fog, c.shading = this.shading, c.shaderID = this.shaderID, c.vertexColors = this.vertexColors, c.skinning = this.skinning, c.morphTargets = this.morphTargets, c.morphNormals = this.morphNormals, c;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/InstancedMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/InstancedMaterial.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              InstancedMaterial: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), M = s(
              /*! ../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), E = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), A = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class g extends h.Material {
              constructor(c) {
                super(), this.color = new E.Color(16777215), this.ambient = new E.Color(1048575), this.emissive = new E.Color(0), this.wrapAround = !1, this.wrapRGB = new A.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = M.Shading.SmoothShading, this.shaderID = "instanced", this.vertexColors = v.Coloring.NoColors, this.skinning = !1, this.sphere = null, this.setValues(c);
              }
              clone(c = new g()) {
                return super.clone.call(this, c), c.color.copy(this.color), c.ambient.copy(this.ambient), c.emissive.copy(this.emissive), c.wrapAround = this.wrapAround, c.wrapRGB.copy(this.wrapRGB), c.map = this.map, c.lightMap = this.lightMap, c.specularMap = this.specularMap, c.envMap = this.envMap, c.combine = this.combine, c.reflectivity = this.reflectivity, c.refractionRatio = this.refractionRatio, c.fog = this.fog, c.shading = this.shading, c.shaderID = this.shaderID, c.vertexColors = this.vertexColors, c.skinning = this.skinning, c.morphTargets = this.morphTargets, c.morphNormals = this.morphNormals, c.sphere = this.sphere, c;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/LineBasicMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/LineBasicMaterial.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              LineBasicMaterial: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), M = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class E extends M.Material {
              constructor(h) {
                super(), this.color = new v.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = !1, this.fog = !0, this.shaderID = "basic", this.setValues(h);
              }
              clone(h = new E()) {
                return super.clone.call(this, h), h.color.copy(this.color), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/Material.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/materials/Material.ts ***!
            \*****************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Material: () => (
                /* binding */
                h
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), M = s(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), E = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), A = s(
              /*! ../../colors */
              "./src/colors.ts"
            );
            class h extends M.EventDispatcher {
              constructor() {
                super(...arguments), this.id = g++, this.name = "", this.side = v.FrontSide, this.opacity = 1, this.transparent = !1, this.depthTest = !0, this.depthWrite = !0, this.stencilTest = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.visible = !0, this.needsUpdate = !0, this.outline = !1;
              }
              setValues(c = {}) {
                if (c !== void 0)
                  for (var S in c) {
                    var y = c[S];
                    if (y === void 0) {
                      console.warn("$3Dmol.Material: '" + S + "' parameter is undefined.");
                      continue;
                    }
                    if (S in this) {
                      var b = this[S];
                      b instanceof A.Color && y instanceof A.Color ? b.copy(y) : b instanceof A.Color ? b.set(y) : b instanceof E.Vector3 && y instanceof E.Vector3 ? b.copy(y) : this[S] = y;
                    }
                  }
              }
              //TODO: might want to look into blending equations
              clone(c = new h()) {
                return c.name = this.name, c.side = this.side, c.opacity = this.opacity, c.transparent = this.transparent, c.depthTest = this.depthTest, c.depthWrite = this.depthWrite, c.stencilTest = this.stencilTest, c.polygonOffset = this.polygonOffset, c.polygonOffsetFactor = this.polygonOffsetFactor, c.polygonOffsetUnits = this.polygonOffsetUnits, c.alphaTest = this.alphaTest, c.overdraw = this.overdraw, c.visible = this.visible, c;
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let g = 0;
          }
        ),
        /***/
        "./src/WebGL/materials/MeshDoubleLambertMaterial.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/materials/MeshDoubleLambertMaterial.ts ***!
            \**********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), M = s(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            );
            class E extends M.MeshLambertMaterial {
              constructor(h) {
                super(h), this.shaderID = "lambertdouble", this.side = v.DoubleSide, this.outline = !1;
              }
              clone(h = new E()) {
                return super.clone.call(this, h), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshLambertMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshLambertMaterial.ts ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MeshLambertMaterial: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), M = s(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), E = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), A = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), h = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class g extends E.Material {
              constructor(c) {
                super(), this.color = new A.Color(16777215), this.ambient = new A.Color(1048575), this.emissive = new A.Color(0), this.wrapAround = !1, this.wrapRGB = new h.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = M.Shading.SmoothShading, this.shaderID = "lambert", this.vertexColors = v.Coloring.NoColors, this.skinning = !1, this.setValues(c);
              }
              clone(c = new g()) {
                return super.clone.call(this, c), c.color.copy(this.color), c.ambient.copy(this.ambient), c.emissive.copy(this.emissive), c.wrapAround = this.wrapAround, c.wrapRGB.copy(this.wrapRGB), c.map = this.map, c.lightMap = this.lightMap, c.specularMap = this.specularMap, c.envMap = this.envMap, c.combine = this.combine, c.reflectivity = this.reflectivity, c.refractionRatio = this.refractionRatio, c.fog = this.fog, c.shading = this.shading, c.shaderID = this.shaderID, c.vertexColors = this.vertexColors, c.skinning = this.skinning, c.morphTargets = this.morphTargets, c.morphNormals = this.morphNormals, c;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshOutlineMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshOutlineMaterial.ts ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), M = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class E extends M.Material {
              constructor(h) {
                super(), h = h || {}, this.fog = !0, this.shaderID = "outline", this.wireframe = !1, this.outlineColor = h.color || new v.Color(0, 0, 0), this.outlineWidth = h.width || 0.1, this.outlinePushback = h.pushback || 1;
              }
              clone(h = new E()) {
                return super.clone.call(this, h), h.fog = this.fog, h.shaderID = this.shaderID, h.wireframe = this.wireframe, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterMaterial.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterMaterial.ts ***!
            \*******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SphereImposterMaterial: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class M extends v.ImposterMaterial {
              constructor(A) {
                super(A), this.shaderID = "sphereimposter", this.setValues(A);
              }
              clone(A = new M()) {
                return super.clone.call(this, A), A;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterOutlineMaterial.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterOutlineMaterial.ts ***!
            \**************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), M = s(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class E extends M.ImposterMaterial {
              constructor(h) {
                super(h), h = h || {}, this.shaderID = "sphereimposteroutline", this.outlineColor = h.color || new v.Color(0, 0, 0), this.outlineWidth = h.width || 0.1, this.outlinePushback = h.pushback || 1, this.setValues(h);
              }
              clone(h = new E()) {
                return super.clone.call(this, h), h.outlineColor = this.outlineColor, h.outlineWidth = this.outlineWidth, h.outlinePushback = this.outlinePushback, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SpriteMaterial.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/materials/SpriteMaterial.ts ***!
            \***********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SpriteMaterial: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ../constants/SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), M = s(
              /*! ../core/Texture */
              "./src/WebGL/core/Texture.ts"
            ), E = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), A = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class g extends h.Material {
              constructor(c) {
                super(), this.color = new E.Color(16777215), this.map = new M.Texture(), this.useScreenCoordinates = !0, this.fog = !1, this.uvOffset = new A.Vector2(0, 0), this.uvScale = new A.Vector2(1, 1), this.depthTest = !this.useScreenCoordinates, this.sizeAttenuation = !this.useScreenCoordinates, this.screenOffset = this.screenOffset, this.scaleByViewPort = !this.sizeAttenuation, this.alignment = v.SpriteAlignment.center.clone(), this.setValues(c), c = c || {}, c.depthTest === void 0 && (this.depthTest = !this.useScreenCoordinates), c.sizeAttenuation === void 0 && (this.sizeAttenuation = !this.useScreenCoordinates), c.scaleByViewPort === void 0 && (this.scaleByViewPort = !this.sizeAttenuation);
              }
              clone(c = new g()) {
                return super.clone.call(this, c), c.color.copy(this.color), c.map = this.map, c.useScreenCoordinates = this.useScreenCoordinates, c.screenOffset = this.screenOffset, c.sizeAttenuation = this.sizeAttenuation, c.scaleByViewport = this.scaleByViewPort, c.alignment.copy(this.alignment), c.uvOffset.copy(this.uvOffset), c;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterMaterial.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/materials/StickImposterMaterial.ts ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              StickImposterMaterial: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class M extends v.ImposterMaterial {
              constructor(A) {
                super(A), this.shaderID = "stickimposter", this.setValues(A);
              }
              clone(A = new M()) {
                return super.clone.call(this, A), A;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterOutlineMaterial.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/materials/StickImposterOutlineMaterial.ts ***!
            \*************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), M = s(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class E extends M.ImposterMaterial {
              constructor(h = {}) {
                super(h), this.shaderID = "stickimposteroutline", this.outlineColor = new v.Color(0, 0, 0), this.outlineWidth = 0.1, this.outlinePushback = 1, h.color && (this.outlineColor = h.color), h.width && (this.outlineWidth = h.width), h.pushback && (this.outlinePushback = h.pushback), this.setValues(h);
              }
              clone(h = new E()) {
                return super.clone.call(this, h), h.outlineColor = this.outlineColor, h.outlineWidth = this.outlineWidth, h.outlinePushback = this.outlinePushback, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/VolumetricMaterial.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/materials/VolumetricMaterial.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              VolumetricMaterial: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), M = s(
              /*! ../../colors */
              "./src/colors.ts"
            ), E = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class A extends E.Material {
              constructor(g) {
                super(), this.transparent = !1, this.volumetric = !0, this.color = new M.Color(16777215), this.transferfn = null, this.map = void 0, this.extent = [], this.maxdepth = 100, this.unit = 0, this.texmatrix = null, this.transfermin = -1, this.transfermax = 1, this.subsamples = 5, this.shaderID = "volumetric", this.side = v.FrontSide, this.setValues(g);
              }
              clone(g = new A()) {
                return super.clone.call(this, g), g.transparent = this.transparent, g.volumetric = this.volumetric, g.color = this.color, g.transferfn = this.transferfn, g.map = this.map, g.extent = this.extent, g.maxdepth = this.maxdepth, g.unit = this.unit, g.texmatrix = this.texmatrix, g.transfermin = this.transfermin, g.transfermax = this.transfermax, g.subsamples = this.subsamples, g.shaderID = this.shaderID, g.side = this.side, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/materials/index.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                v.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                M.InstancedMaterial
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                E.LineBasicMaterial
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                A.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                A.MaterialIdCount
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                h.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                g.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                C.MeshOutlineMaterial
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                c.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                S.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                y.SpriteMaterial
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                b.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                w.StickImposterOutlineMaterial
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                t.VolumetricMaterial
              )
              /* harmony export */
            });
            var v = s(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            ), M = s(
              /*! ./InstancedMaterial */
              "./src/WebGL/materials/InstancedMaterial.ts"
            ), E = s(
              /*! ./LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), A = s(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), h = s(
              /*! ./MeshDoubleLambertMaterial */
              "./src/WebGL/materials/MeshDoubleLambertMaterial.ts"
            ), g = s(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            ), C = s(
              /*! ./MeshOutlineMaterial */
              "./src/WebGL/materials/MeshOutlineMaterial.ts"
            ), c = s(
              /*! ./SphereImposterMaterial */
              "./src/WebGL/materials/SphereImposterMaterial.ts"
            ), S = s(
              /*! ./SphereImposterOutlineMaterial */
              "./src/WebGL/materials/SphereImposterOutlineMaterial.ts"
            ), y = s(
              /*! ./SpriteMaterial */
              "./src/WebGL/materials/SpriteMaterial.ts"
            ), b = s(
              /*! ./StickImposterMaterial */
              "./src/WebGL/materials/StickImposterMaterial.ts"
            ), w = s(
              /*! ./StickImposterOutlineMaterial */
              "./src/WebGL/materials/StickImposterOutlineMaterial.ts"
            ), t = s(
              /*! ./VolumetricMaterial */
              "./src/WebGL/materials/VolumetricMaterial.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/Quaternion.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/math/Quaternion.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Quaternion: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            class v {
              constructor(E, A, h, g) {
                this.x = E || 0, this.y = A || 0, this.z = h || 0, this.w = g !== void 0 ? g : 1;
              }
              set(E, A, h, g) {
                return this.x = E, this.y = A, this.z = h, this.w = g, this;
              }
              copy(E) {
                return this.x = E.x, this.y = E.y, this.z = E.z, this.w = E.w, this;
              }
              conjugate() {
                return this.x *= -1, this.y *= -1, this.z *= -1, this;
              }
              inverse() {
                return this.conjugate().normalize();
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
              }
              lengthxyz() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              normalize() {
                let E = this.length();
                return E === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (E = 1 / E, this.x *= E, this.y *= E, this.z *= E, this.w *= E), this;
              }
              multiply(E) {
                return this.multiplyQuaternions(this, E);
              }
              multiplyScalar(E) {
                return this.x *= E, this.y *= E, this.z *= E, this.w *= E, this;
              }
              multiplyQuaternions(E, A) {
                const h = E.x, g = E.y, C = E.z, c = E.w, S = A.x, y = A.y, b = A.z, w = A.w;
                return this.x = h * w + c * S + g * b - C * y, this.y = g * w + c * y + C * S - h * b, this.z = C * w + c * b + h * y - g * S, this.w = c * w - h * S - g * y - C * b, this;
              }
              sub(E) {
                return this.x -= E.x, this.y -= E.y, this.z -= E.z, this.w -= E.w, this;
              }
              clone() {
                return new v(this.x, this.y, this.z, this.w);
              }
              setFromEuler(E) {
                const A = Math.cos(E.x / 2), h = Math.cos(E.y / 2), g = Math.cos(E.z / 2), C = Math.sin(E.x / 2), c = Math.sin(E.y / 2), S = Math.sin(E.z / 2);
                return this.x = C * h * g + A * c * S, this.y = A * c * g - C * h * S, this.z = A * h * S + C * c * g, this.w = A * h * g - C * c * S, this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/Vector2.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/math/Vector2.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Vector2: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            class v {
              constructor(E, A) {
                this.x = E || 0, this.y = A || 0;
              }
              set(E, A) {
                return this.x = E, this.y = A, this;
              }
              subVectors(E, A) {
                return this.x = E.x - A.x, this.y = E.y - A.y, this;
              }
              copy(E) {
                return this.x = E.x, this.y = E.y, this;
              }
              clone() {
                return new v(this.x, this.y);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/math/index.ts ***!
            \*********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                g.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                g.Matrix4
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                v.Quaternion
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                g.Ray
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                M.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                g.Vector3
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                E.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                A.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                h.degToRad
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Quaternion */
              "./src/WebGL/math/Quaternion.ts"
            ), M = s(
              /*! ./Vector2 */
              "./src/WebGL/math/Vector2.ts"
            ), E = s(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), A = s(
              /*! ./utils/conversionMatrix3 */
              "./src/WebGL/math/utils/conversionMatrix3.ts"
            ), h = s(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), g = s(
              /*! ./math */
              "./src/WebGL/math/math.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/math.ts": (
          /*!********************************!*\
            !*** ./src/WebGL/math/math.ts ***!
            \********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Matrix3: () => (
                /* binding */
                y
              ),
              /* harmony export */
              Matrix4: () => (
                /* binding */
                c
              ),
              /* harmony export */
              Ray: () => (
                /* binding */
                b
              ),
              /* harmony export */
              Vector3: () => (
                /* binding */
                S
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), M = s(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), E, A, h, g, C;
            class c {
              constructor(t = 1, r = 0, u = 0, o = 0, l = 0, e = 1, n = 0, a = 0, p = 0, x = 0, D = 1, O = 0, R = 0, z = 0, T = 0, B = 1) {
                typeof t < "u" && typeof t != "number" ? this.elements = new Float32Array(t) : (this.elements = new Float32Array(16), this.elements[0] = t, this.elements[4] = r, this.elements[8] = u, this.elements[12] = o, this.elements[1] = l, this.elements[5] = e, this.elements[9] = n, this.elements[13] = a, this.elements[2] = p, this.elements[6] = x, this.elements[10] = D, this.elements[14] = O, this.elements[3] = R, this.elements[7] = z, this.elements[11] = T, this.elements[15] = B);
              }
              // eslint-disable-next-line no-unused-vars, class-methods-use-this
              makeScale(t, r, u) {
                throw new Error("Method not implemented.");
              }
              set(t, r, u, o, l, e, n, a, p, x, D, O, R, z, T, B) {
                const W = this.elements;
                return W[0] = t, W[4] = r, W[8] = u, W[12] = o, W[1] = l, W[5] = e, W[9] = n, W[13] = a, W[2] = p, W[6] = x, W[10] = D, W[14] = O, W[3] = R, W[7] = z, W[11] = T, W[15] = B, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
              }
              copy(t) {
                const r = t.elements;
                return this.set(r[0], r[4], r[8], r[12], r[1], r[5], r[9], r[13], r[2], r[6], r[10], r[14], r[3], r[7], r[11], r[15]), this;
              }
              matrix3FromTopLeft() {
                const t = this.elements;
                return new y(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]);
              }
              setRotationFromEuler(t, r) {
                const u = this.elements, { x: o, y: l, z: e } = t, n = Math.cos(o), a = Math.sin(o), p = Math.cos(l), x = Math.sin(l), D = Math.cos(e), O = Math.sin(e);
                if (r === void 0 || r === "XYZ") {
                  const R = n * D, z = n * O, T = a * D, B = a * O;
                  u[0] = p * D, u[4] = -p * O, u[8] = x, u[1] = z + T * x, u[5] = R - B * x, u[9] = -a * p, u[2] = B - R * x, u[6] = T + z * x, u[10] = n * p;
                } else
                  console.error(`Error with matrix4 setRotationFromEuler. Order: ${r}`);
                return this;
              }
              setRotationFromQuaternion(t) {
                const r = this.elements, { x: u, y: o, z: l, w: e } = t, n = u + u, a = o + o, p = l + l, x = u * n, D = u * a, O = u * p, R = o * a, z = o * p, T = l * p, B = e * n, W = e * a, k = e * p;
                return r[0] = 1 - (R + T), r[4] = D - k, r[8] = O + W, r[1] = D + k, r[5] = 1 - (x + T), r[9] = z - B, r[2] = O - W, r[6] = z + B, r[10] = 1 - (x + R), this;
              }
              multiplyMatrices(t, r) {
                const u = t.elements, o = r.elements, l = this.elements, e = u[0], n = u[4], a = u[8], p = u[12], x = u[1], D = u[5], O = u[9], R = u[13], z = u[2], T = u[6], B = u[10], W = u[14], k = u[3], F = u[7], U = u[11], V = u[15], H = o[0], G = o[4], Y = o[8], J = o[12], re = o[1], le = o[5], ie = o[9], xe = o[13], se = o[2], ce = o[6], Ee = o[10], be = o[14], Le = o[3], ae = o[7], pe = o[11], we = o[15];
                return l[0] = e * H + n * re + a * se + p * Le, l[4] = e * G + n * le + a * ce + p * ae, l[8] = e * Y + n * ie + a * Ee + p * pe, l[12] = e * J + n * xe + a * be + p * we, l[1] = x * H + D * re + O * se + R * Le, l[5] = x * G + D * le + O * ce + R * ae, l[9] = x * Y + D * ie + O * Ee + R * pe, l[13] = x * J + D * xe + O * be + R * we, l[2] = z * H + T * re + B * se + W * Le, l[6] = z * G + T * le + B * ce + W * ae, l[10] = z * Y + T * ie + B * Ee + W * pe, l[14] = z * J + T * xe + B * be + W * we, l[3] = k * H + F * re + U * se + V * Le, l[7] = k * G + F * le + U * ce + V * ae, l[11] = k * Y + F * ie + U * Ee + V * pe, l[15] = k * J + F * xe + U * be + V * we, this;
              }
              multiplyScalar(t) {
                const r = this.elements;
                return r[0] *= t, r[4] *= t, r[8] *= t, r[12] *= t, r[1] *= t, r[5] *= t, r[9] *= t, r[13] *= t, r[2] *= t, r[6] *= t, r[10] *= t, r[14] *= t, r[3] *= t, r[7] *= t, r[11] *= t, r[15] *= t, this;
              }
              makeTranslation(t, r, u) {
                return this.set(1, 0, 0, t, 0, 1, 0, r, 0, 0, 1, u, 0, 0, 0, 1), this;
              }
              // snap values close to integers to their integer value
              // useful and identifying identity matrices
              snap(t) {
                const r = Math.pow(10, 4), u = this.elements;
                for (let o = 0; o < 16; o++) {
                  const l = Math.round(u[o]);
                  l === Math.round(u[o] * r) / r && (u[o] = l);
                }
                return this;
              }
              transpose() {
                const t = this.elements;
                let r;
                return r = t[1], t[1] = t[4], t[4] = r, r = t[2], t[2] = t[8], t[8] = r, r = t[6], t[6] = t[9], t[9] = r, r = t[3], t[3] = t[12], t[12] = r, r = t[7], t[7] = t[13], t[13] = r, r = t[11], t[11] = t[14], t[14] = r, this;
              }
              setPosition(t) {
                const r = this.elements;
                return r[12] = t.x, r[13] = t.y, r[14] = t.z, this;
              }
              translate(t) {
                const r = this.elements;
                return r[12] += t.x, r[13] += t.y, r[14] += t.z, this;
              }
              getInverse(t, r) {
                const u = this.elements, o = t.elements, l = o[0], e = o[4], n = o[8], a = o[12], p = o[1], x = o[5], D = o[9], O = o[13], R = o[2], z = o[6], T = o[10], B = o[14], W = o[3], k = o[7], F = o[11], U = o[15];
                u[0] = D * B * k - O * T * k + O * z * F - x * B * F - D * z * U + x * T * U, u[4] = a * T * k - n * B * k - a * z * F + e * B * F + n * z * U - e * T * U, u[8] = n * O * k - a * D * k + a * x * F - e * O * F - n * x * U + e * D * U, u[12] = a * D * z - n * O * z - a * x * T + e * O * T + n * x * B - e * D * B, u[1] = O * T * W - D * B * W - O * R * F + p * B * F + D * R * U - p * T * U, u[5] = n * B * W - a * T * W + a * R * F - l * B * F - n * R * U + l * T * U, u[9] = a * D * W - n * O * W - a * p * F + l * O * F + n * p * U - l * D * U, u[13] = n * O * R - a * D * R + a * p * T - l * O * T - n * p * B + l * D * B, u[2] = x * B * W - O * z * W + O * R * k - p * B * k - x * R * U + p * z * U, u[6] = a * z * W - e * B * W - a * R * k + l * B * k + e * R * U - l * z * U, u[10] = e * O * W - a * x * W + a * p * k - l * O * k - e * p * U + l * x * U, u[14] = a * x * R - e * O * R - a * p * z + l * O * z + e * p * B - l * x * B, u[3] = D * z * W - x * T * W - D * R * k + p * T * k + x * R * F - p * z * F, u[7] = e * T * W - n * z * W + n * R * k - l * T * k - e * R * F + l * z * F, u[11] = n * x * W - e * D * W - n * p * k + l * D * k + e * p * F - l * x * F, u[15] = e * D * R - n * x * R + n * p * z - l * D * z - e * p * T + l * x * T;
                const V = l * u[0] + p * u[4] + R * u[8] + W * u[12];
                if (V === 0) {
                  const H = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                  if (r)
                    throw new Error(H);
                  return console.warn(H), this.identity(), this;
                }
                return this.multiplyScalar(1 / V), this;
              }
              isReflected() {
                const t = this.elements, r = t[0], u = t[4], o = t[8], l = t[1], e = t[5], n = t[9], a = t[2], p = t[6], x = t[10];
                return r * e * x + // +aei
                l * p * o + // +bfg
                a * u * n - // +cdh
                a * e * o - // -ceg
                l * u * x - // -bdi
                r * p * n < 0;
              }
              scale(t) {
                const r = this.elements, { x: u } = t, { y: o } = t, { z: l } = t;
                return r[0] *= u, r[4] *= o, r[8] *= l, r[1] *= u, r[5] *= o, r[9] *= l, r[2] *= u, r[6] *= o, r[10] *= l, r[3] *= u, r[7] *= o, r[11] *= l, this;
              }
              getMaxScaleOnAxis() {
                const t = this.elements, r = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], u = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], o = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(r, Math.max(u, o)));
              }
              makeFrustum(t, r, u, o, l, e) {
                const n = this.elements, a = 2 * l / (r - t), p = 2 * l / (o - u), x = (r + t) / (r - t), D = (o + u) / (o - u), O = -(e + l) / (e - l), R = -2 * e * l / (e - l);
                return n[0] = a, n[4] = 0, n[8] = x, n[12] = 0, n[1] = 0, n[5] = p, n[9] = D, n[13] = 0, n[2] = 0, n[6] = 0, n[10] = O, n[14] = R, n[3] = 0, n[7] = 0, n[11] = -1, n[15] = 0, this;
              }
              makePerspective(t, r, u, o) {
                const l = u * Math.tan((0, v.degToRad)(t * 0.5)), e = -l, n = e * r, a = l * r;
                return this.makeFrustum(n, a, e, l, u, o);
              }
              makeOrthographic(t, r, u, o, l, e) {
                const n = this.elements, a = 1 / (r - t), p = 1 / (u - o), x = 1 / (e - l), D = (r + t) * a, O = (u + o) * p, R = (e + l) * x;
                return n[0] = 2 * a, n[4] = 0, n[8] = 0, n[12] = -D, n[1] = 0, n[5] = 2 * p, n[9] = 0, n[13] = -O, n[2] = 0, n[6] = 0, n[10] = -2 * x, n[14] = -R, n[3] = 0, n[7] = 0, n[11] = 0, n[15] = 1, this;
              }
              isEqual(t) {
                const r = t.elements, u = this.elements;
                return u[0] === r[0] && u[4] === r[4] && u[8] === r[8] && u[12] === r[12] && u[1] === r[1] && u[5] === r[5] && u[9] === r[9] && u[13] === r[13] && u[2] === r[2] && u[6] === r[6] && u[10] === r[10] && u[14] === r[14] && u[3] === r[3] && u[7] === r[7] && u[11] === r[11] && u[15] === r[15];
              }
              clone() {
                const t = this.elements;
                return new c(t[0], t[4], t[8], t[12], t[1], t[5], t[9], t[13], t[2], t[6], t[10], t[14], t[3], t[7], t[11], t[15]);
              }
              isIdentity() {
                const t = this.elements;
                return t[0] === 1 && t[4] === 0 && t[8] === 0 && t[12] === 0 && t[1] === 0 && t[5] === 1 && t[9] === 0 && t[13] === 0 && t[2] === 0 && t[6] === 0 && t[10] === 1 && t[14] === 0 && t[3] === 0 && t[7] === 0 && t[11] === 0 && t[15] === 1;
              }
              // return true if elements are with digits of identity
              isNearlyIdentity(t) {
                return this.clone().snap(t).isIdentity();
              }
              getScale(t) {
                const r = this.elements;
                return t = t || new S(), h.set(r[0], r[1], r[2]), g.set(r[4], r[5], r[6]), C.set(r[8], r[9], r[10]), t.x = h.length(), t.y = g.length(), t.z = C.length(), t;
              }
              lookAt(t, r, u) {
                const o = this.elements;
                return C.subVectors(t, r).normalize(), C.length() === 0 && (C.z = 1), h.crossVectors(u, C).normalize(), h.length() === 0 && (C.x += 1e-4, h.crossVectors(u, C).normalize()), g.crossVectors(C, h), o[0] = h.x, o[4] = g.x, o[8] = C.x, o[1] = h.y, o[5] = g.y, o[9] = C.y, o[2] = h.z, o[6] = g.z, o[10] = C.z, this;
              }
              compose(t, r, u) {
                const o = this.elements;
                return E.identity(), E.setRotationFromQuaternion(r), A.makeScale(u.x, u.y, u.z), this.multiplyMatrices(E, A), o[12] = t.x, o[13] = t.y, o[14] = t.z, this;
              }
            }
            E = new c(), A = new c();
            class S {
              constructor(t, r, u) {
                this.x = t || 0, this.y = r || 0, this.z = u || 0, this.atomid = void 0;
              }
              set(t, r, u) {
                return this.x = t, this.y = r, this.z = u, this;
              }
              copy(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this;
              }
              add(t) {
                return this.x += t.x, this.y += t.y, this.z += t.z, this;
              }
              addVectors(t, r) {
                return this.x = t.x + r.x, this.y = t.y + r.y, this.z = t.z + r.z, this;
              }
              multiplyVectors(t, r) {
                return this.x = t.x * r.x, this.y = t.y * r.y, this.z = t.z * r.z, this;
              }
              sub(t) {
                return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
              }
              subVectors(t, r) {
                return this.x = t.x - r.x, this.y = t.y - r.y, this.z = t.z - r.z, this;
              }
              multiplyScalar(t) {
                return this.x *= t, this.y *= t, this.z *= t, this;
              }
              divideScalar(t) {
                return t !== 0 ? (this.x /= t, this.y /= t, this.z /= t) : (this.x = 0, this.y = 0, this.z = 0), this;
              }
              // accumulate maximum
              max(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
              }
              // accumulate min
              min(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
              }
              distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t));
              }
              distanceToSquared(t) {
                const r = this.x - t.x, u = this.y - t.y, o = this.z - t.z;
                return r * r + u * u + o * o;
              }
              applyMatrix3(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this, l = t.elements;
                return this.x = l[0] * r + l[3] * u + l[6] * o, this.y = l[1] * r + l[4] * u + l[7] * o, this.z = l[2] * r + l[5] * u + l[8] * o, this;
              }
              applyMatrix4(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this, l = t.elements;
                return this.x = l[0] * r + l[4] * u + l[8] * o + l[12], this.y = l[1] * r + l[5] * u + l[9] * o + l[13], this.z = l[2] * r + l[6] * u + l[10] * o + l[14], this;
              }
              applyProjection(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this, l = t.elements, e = l[3] * r + l[7] * u + l[11] * o + l[15];
                return this.x = (l[0] * r + l[4] * u + l[8] * o + l[12]) / e, this.y = (l[1] * r + l[5] * u + l[9] * o + l[13]) / e, this.z = (l[2] * r + l[6] * u + l[10] * o + l[14]) / e, this;
              }
              applyQuaternion(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this, l = t.x, e = t.y, n = t.z, a = t.w, p = {};
                p.x = 2 * (u * n - o * e), p.y = 2 * (o * l - r * n), p.z = 2 * (r * e - u * l);
                const x = {};
                return x.x = p.y * n - p.z * e, x.y = p.z * l - p.x * n, x.z = p.x * e - p.y * l, this.x = r + a * p.x + x.x, this.y = u + a * p.y + x.y, this.z = o + a * p.z + x.z, this;
              }
              negate() {
                return this.multiplyScalar(-1);
              }
              dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z;
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
              }
              normalize() {
                return this.divideScalar(this.length());
              }
              cross(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this;
                return this.x = u * t.z - o * t.y, this.y = o * t.x - r * t.z, this.z = r * t.y - u * t.x, this;
              }
              crossVectors(t, r) {
                return this.x = t.y * r.z - t.z * r.y, this.y = t.z * r.x - t.x * r.z, this.z = t.x * r.y - t.y * r.x, this;
              }
              equals(t) {
                return this.x == t.x && this.y == t.y && this.z == t.z;
              }
              getPositionFromMatrix(t) {
                return this.x = t.elements[12], this.y = t.elements[13], this.z = t.elements[14], this;
              }
              setEulerFromRotationMatrix(t, r) {
                const u = t.elements, o = u[0], l = u[4], e = u[8], n = u[5], a = u[9], p = u[6], x = u[10];
                return r === void 0 || r === "XYZ" ? (this.y = Math.asin((0, M.clamp)(e, -1, 1)), Math.abs(e) < 0.99999 ? (this.x = Math.atan2(-a, x), this.z = Math.atan2(-l, o)) : (this.x = Math.atan2(p, n), this.z = 0)) : console.error(`Error with vector's setEulerFromRotationMatrix: Unknown order: ${r}`), this;
              }
              rotateAboutVector(t, r) {
                t.normalize();
                const u = Math.cos(r), o = Math.sin(r), l = this.clone().multiplyScalar(u), e = t.clone().cross(this).multiplyScalar(o), n = t.clone().multiplyScalar(t.clone().dot(this)).multiplyScalar(1 - u), a = l.add(e).add(n);
                return this.x = a.x, this.y = a.y, this.z = a.z, this;
              }
              setFromMatrixPosition(t) {
                const r = t.elements;
                return this.x = r[12], this.y = r[13], this.z = r[14], this;
              }
              // unproject is defined after Matrix4
              transformDirection(t) {
                const { x: r } = this, { y: u } = this, { z: o } = this, l = t.elements;
                return this.x = l[0] * r + l[4] * u + l[8] * o, this.y = l[1] * r + l[5] * u + l[9] * o, this.z = l[2] * r + l[6] * u + l[10] * o, this.normalize();
              }
              clone() {
                return new S(this.x, this.y, this.z);
              }
              unproject(t) {
                const r = E;
                return r.multiplyMatrices(t.matrixWorld, r.getInverse(t.projectionMatrix)), this.applyMatrix4(r);
              }
            }
            h = new S(), g = new S(), C = new S();
            class y {
              constructor(t = 1, r = 0, u = 0, o = 0, l = 1, e = 0, n = 0, a = 0, p = 1) {
                this.elements = new Float32Array(9), this.set(t, r, u, o, l, e, n, a, p);
              }
              set(t, r, u, o, l, e, n, a, p) {
                const x = this.elements;
                return x[0] = t, x[3] = r, x[6] = u, x[1] = o, x[4] = l, x[7] = e, x[2] = n, x[5] = a, x[8] = p, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
              }
              copy(t) {
                const r = t.elements;
                this.set(r[0], r[3], r[6], r[1], r[4], r[7], r[2], r[5], r[8]);
              }
              multiplyScalar(t) {
                const r = this.elements;
                return r[0] *= t, r[3] *= t, r[6] *= t, r[1] *= t, r[4] *= t, r[7] *= t, r[2] *= t, r[5] *= t, r[8] *= t, this;
              }
              getInverse3(t) {
                const r = t.elements, u = this.elements;
                u[0] = r[4] * r[8] - r[5] * r[7], u[3] = r[6] * r[5] - r[3] * r[8], u[6] = r[3] * r[7] - r[6] * r[4], u[1] = r[7] * r[2] - r[1] * r[8], u[4] = r[0] * r[8] - r[6] * r[2], u[7] = r[1] * r[6] - r[0] * r[7], u[2] = r[1] * r[5] - r[2] * r[4], u[5] = r[2] * r[3] - r[0] * r[5], u[8] = r[0] * r[4] - r[1] * r[3];
                const o = r[0] * u[0] + r[3] * u[1] + r[6] * u[2];
                return this.multiplyScalar(1 / o), this;
              }
              getInverse(t, r) {
                const u = t.elements, o = this.elements;
                o[0] = u[10] * u[5] - u[6] * u[9], o[1] = -u[10] * u[1] + u[2] * u[9], o[2] = u[6] * u[1] - u[2] * u[5], o[3] = -u[10] * u[4] + u[6] * u[8], o[4] = u[10] * u[0] - u[2] * u[8], o[5] = -u[6] * u[0] + u[2] * u[4], o[6] = u[9] * u[4] - u[5] * u[8], o[7] = -u[9] * u[0] + u[1] * u[8], o[8] = u[5] * u[0] - u[1] * u[4];
                const l = u[0] * o[0] + u[1] * o[3] + u[2] * o[6];
                if (l === 0) {
                  const e = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                  if (r)
                    throw new Error(e);
                  return console.warn(e), this.identity(), this;
                }
                return this.multiplyScalar(1 / l), this;
              }
              // https://en.wikipedia.org/wiki/Determinant
              getDeterminant() {
                const t = this.elements;
                return t[0] * t[4] * t[8] + // +aei
                t[1] * t[5] * t[6] + // +bfg
                t[2] * t[3] * t[7] - // +cdh
                t[2] * t[4] * t[6] - // -ceg
                t[1] * t[3] * t[8] - // -bdi
                t[0] * t[5] * t[7];
              }
              transpose() {
                let t;
                const r = this.elements;
                return t = r[1], r[1] = r[3], r[3] = t, t = r[2], r[2] = r[6], r[6] = t, t = r[5], r[5] = r[7], r[7] = t, this;
              }
              clone() {
                const t = this.elements;
                return new y(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]);
              }
              getMatrix4() {
                const t = this.elements;
                return new c(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0);
              }
            }
            class b {
              constructor(t, r) {
                this.origin = t !== void 0 ? t : new S(), this.direction = r !== void 0 ? r : new S();
              }
              set(t, r) {
                return this.origin.copy(t), this.direction.copy(r), this;
              }
              copy(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
              }
              at(t, r) {
                return (r || new S()).copy(this.direction).multiplyScalar(t).add(this.origin);
              }
              recast(t) {
                const r = h;
                return this.origin.copy(this.at(t, r)), this;
              }
              closestPointToPoint(t, r) {
                const u = r || new S();
                u.subVectors(t, this.origin);
                const o = u.dot(this.direction);
                return u.copy(this.direction).multiplyScalar(o).add(this.origin);
              }
              distanceToPoint(t) {
                const r = h, u = r.subVectors(t, this.origin).dot(this.direction);
                return r.copy(this.direction).multiplyScalar(u).add(this.origin), r.distanceTo(t);
              }
              // eslint-disable-next-line class-methods-use-this
              isIntersectionCylinder() {
              }
              isIntersectionSphere(t) {
                return this.distanceToPoint(t.center) <= t.radius;
              }
              isIntersectionPlane(t) {
                return t.normal.dot(this.direction) !== 0 || t.distanceToPoint(this.origin) === 0;
              }
              distanceToPlane(t) {
                const r = t.normal.dot(this.direction);
                return r === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : void 0 : -(this.origin.dot(t.normal) + t.constant) / r;
              }
              intersectPlane(t, r) {
                const u = this.distanceToPlane(t);
                if (u !== void 0)
                  return this.at(u, r);
              }
              applyMatrix4(t) {
                return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this;
              }
              clone() {
                return new b().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/clamp.ts": (
          /*!***************************************!*\
            !*** ./src/WebGL/math/utils/clamp.ts ***!
            \***************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              clamp: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M, E, A) {
              return Math.min(Math.max(M, E), A);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/conversionMatrix3.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/math/utils/conversionMatrix3.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              conversionMatrix3: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/math.ts"
            );
            function M(E, A, h, g, C, c) {
              g = g * Math.PI / 180, C = C * Math.PI / 180, c = c * Math.PI / 180;
              const S = (u) => u * u, y = Math.cos(g), b = Math.cos(C), w = Math.cos(c), t = Math.sin(c);
              return new v.Matrix3(E, A * w, h * b, 0, A * t, h * (y - b * w) / t, 0, 0, h * Math.sqrt(1 - S(y) - S(b) - S(w) + 2 * y * b * w) / t);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/degToRad.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/math/utils/degToRad.ts ***!
            \******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              degToRad: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            const v = Math.PI / 180;
            function M(E) {
              return E * v;
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Line.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Line.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Line: () => (
                /* binding */
                A
              ),
              /* harmony export */
              LineStyle: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), M = s(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), E;
            (function(h) {
              h[h.LineStrip = 0] = "LineStrip", h[h.LinePieces = 1] = "LinePieces";
            })(E || (E = {}));
            class A extends M.Object3D {
              constructor(g, C = new v.LineBasicMaterial({
                color: Math.random() * 16777215
              }), c = E.LineStrip) {
                super(), this.geometry = g, this.material = C, this.type = c;
              }
              clone(g = new A(this.geometry, this.material, this.type)) {
                return super.clone.call(this, g), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Mesh.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Mesh.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Mesh: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class M extends v.Object3D {
              constructor(A, h) {
                super(), this.geometry = A, this.material = h;
              }
              clone(A) {
                return A === void 0 && (A = new M(this.geometry, this.material)), super.clone.call(this, A), A;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Sprite.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/objects/Sprite.ts ***!
            \*************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Sprite: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), M = s(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class E extends M.Object3D {
              constructor(h = new v.SpriteMaterial()) {
                super(), this.material = h, this.rotation3d = this.rotation, this.rotation = 0;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.rotation3d.set(0, 0, this.rotation), this.matrix.setRotationFromEuler(this.rotation3d), (this.scale.x !== 1 || this.scale.y !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              clone(h = new E(this.material)) {
                return M.Object3D.prototype.clone.call(this, h), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/objects/index.ts ***!
            \************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Line: () => (
                /* reexport safe */
                v.Line
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                v.LineStyle
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                M.Mesh
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                E.Sprite
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Line */
              "./src/WebGL/objects/Line.ts"
            ), M = s(
              /*! ./Mesh */
              "./src/WebGL/objects/Mesh.ts"
            ), E = s(
              /*! ./Sprite */
              "./src/WebGL/objects/Sprite.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/ShaderType.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/shaders/ShaderType.ts ***!
            \*****************************************/
          /***/
          (P, _, s) => {
            s.r(_);
          }
        ),
        /***/
        "./src/WebGL/shaders/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shaders/index.ts ***!
            \************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                v.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                M.ShaderUtils
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                v.basic
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                M.clone
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                v.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                v.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                v.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                v.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                v.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                v.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                v.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                v.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                v.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                v.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                v.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                v.volumetric
              )
              /* harmony export */
            });
            var v = s(
              /*! ./lib */
              "./src/WebGL/shaders/lib/index.ts"
            ), M = s(
              /*! ./utils */
              "./src/WebGL/shaders/utils/index.ts"
            );
            s(
              /*! ./ShaderType */
              "./src/WebGL/shaders/ShaderType.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/index.ts": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/index.ts ***!
            \**********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              basic: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/basic/uniforms.ts"
            ), M = s(
              /*! ./basic.frag */
              "./src/WebGL/shaders/lib/basic/basic.frag"
            ), E = s(
              /*! ./basic.vert */
              "./src/WebGL/shaders/lib/basic/basic.vert"
            );
            const A = {
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/uniforms.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/uniforms.ts ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/index.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/shaders/lib/index.ts ***!
            \****************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ShaderLib: () => (
                /* binding */
                r
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                v.basic
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                M.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                E.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                A.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                h.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                g.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                C.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                c.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                S.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                y.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                b.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                w.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                t.volumetric
              )
              /* harmony export */
            });
            var v = s(
              /*! ./basic */
              "./src/WebGL/shaders/lib/basic/index.ts"
            ), M = s(
              /*! ./instanced */
              "./src/WebGL/shaders/lib/instanced/index.ts"
            ), E = s(
              /*! ./lambert */
              "./src/WebGL/shaders/lib/lambert/index.ts"
            ), A = s(
              /*! ./lambertdouble */
              "./src/WebGL/shaders/lib/lambertdouble/index.ts"
            ), h = s(
              /*! ./outline */
              "./src/WebGL/shaders/lib/outline/index.ts"
            ), g = s(
              /*! ./screen */
              "./src/WebGL/shaders/lib/screen/index.ts"
            ), C = s(
              /*! ./screenaa */
              "./src/WebGL/shaders/lib/screenaa/index.ts"
            ), c = s(
              /*! ./sphereimposter */
              "./src/WebGL/shaders/lib/sphereimposter/index.ts"
            ), S = s(
              /*! ./sphereimposteroutline */
              "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts"
            ), y = s(
              /*! ./sprite */
              "./src/WebGL/shaders/lib/sprite/index.ts"
            ), b = s(
              /*! ./stickimposter */
              "./src/WebGL/shaders/lib/stickimposter/index.ts"
            ), w = s(
              /*! ./stickimposteroutline */
              "./src/WebGL/shaders/lib/stickimposteroutline/index.ts"
            ), t = s(
              /*! ./volumetric */
              "./src/WebGL/shaders/lib/volumetric/index.ts"
            );
            const r = {
              basic: v.basic,
              instanced: M.instanced,
              lambert: E.lambert,
              lambertdouble: A.lambertdouble,
              outline: h.outline,
              screen: g.screen,
              screenaa: C.screenaa,
              sphereimposter: c.sphereimposter,
              sphereimposteroutline: S.sphereimposteroutline,
              sprite: y.sprite,
              stickimposter: b.stickimposter,
              stickimposteroutline: w.stickimposteroutline,
              volumetric: t.volumetric
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/index.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/index.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              instanced: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/instanced/uniforms.ts"
            ), M = s(
              /*! ./instanced.frag */
              "./src/WebGL/shaders/lib/instanced/instanced.frag"
            ), E = s(
              /*! ./instanced.vert */
              "./src/WebGL/shaders/lib/instanced/instanced.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/uniforms.ts": (
          /*!*****************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/uniforms.ts ***!
            \*****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/index.ts ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              lambert: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambert/uniforms.ts"
            ), M = s(
              /*! ./lambert.frag */
              "./src/WebGL/shaders/lib/lambert/lambert.frag"
            ), E = s(
              /*! ./lambert.vert */
              "./src/WebGL/shaders/lib/lambert/lambert.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/uniforms.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/index.ts ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              lambertdouble: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts"
            ), M = s(
              /*! ./lambertdouble.frag */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag"
            ), E = s(
              /*! ./lambertdouble.vert */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/uniforms.ts ***!
            \*********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/index.ts ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              outline: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/outline/uniforms.ts"
            ), M = s(
              /*! ./outline.frag */
              "./src/WebGL/shaders/lib/outline/outline.frag"
            ), E = s(
              /*! ./outline.vert */
              "./src/WebGL/shaders/lib/outline/outline.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/uniforms.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new v.Color(0, 0, 0) },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/index.ts ***!
            \***********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              screen: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screen/uniforms.ts"
            ), M = s(
              /*! ./screen.frag */
              "./src/WebGL/shaders/lib/screen/screen.frag"
            ), E = s(
              /*! ./screen.vert */
              "./src/WebGL/shaders/lib/screen/screen.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/uniforms.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/index.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/index.ts ***!
            \*************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              screenaa: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screenaa/uniforms.ts"
            ), M = s(
              /*! ./screenaa.frag */
              "./src/WebGL/shaders/lib/screenaa/screenaa.frag"
            ), E = s(
              /*! ./screenaa.vert */
              "./src/WebGL/shaders/lib/screenaa/screenaa.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/uniforms.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/uniforms.ts ***!
            \****************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/index.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/index.ts ***!
            \*******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              sphereimposter: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts"
            ), M = s(
              /*! ./sphereimposter.frag */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag"
            ), E = s(
              /*! ./sphereimposter.vert */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert"
            );
            const A = {
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/uniforms.ts ***!
            \**********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/index.ts ***!
            \**************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              sphereimposteroutline: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts"
            ), M = s(
              /*! ./sphereimposteroutline.frag */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag"
            ), E = s(
              /*! ./sphereimposteroutline.vert */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts": (
          /*!*****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts ***!
            \*****************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new v.Color(0, 0, 0) },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/index.ts ***!
            \***********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              sprite: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sprite/uniforms.ts"
            ), M = s(
              /*! ./sprite.frag */
              "./src/WebGL/shaders/lib/sprite/sprite.frag"
            ), E = s(
              /*! ./sprite.vert */
              "./src/WebGL/shaders/lib/sprite/sprite.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/uniforms.ts ***!
            \**************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/index.ts ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              stickimposter: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposter/uniforms.ts"
            ), M = s(
              /*! ../../utils/stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            ), E = s(
              /*! ./stickimposter.partial.frag */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag"
            ), A = s(
              /*! ./stickimposter.vert */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert"
            );
            const g = {
              fragmentShader: [M.default, E.default].join(`
`).replace("#define GLSLIFY 1", ""),
              vertexShader: A.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/uniforms.ts ***!
            \*********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/index.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/index.ts ***!
            \*************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              stickimposteroutline: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts"
            ), M = s(
              /*! ../../utils/stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            ), E = s(
              /*! ./stickimposteroutline.vert */
              "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert"
            );
            const h = {
              fragmentShader: (M.default + "gl_FragColor = vec4(color,1.0);}").replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts ***!
            \****************************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineColor: { type: "c", value: new v.Color(0, 0, 0) },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/index.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/index.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              volumetric: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/volumetric/uniforms.ts"
            ), M = s(
              /*! ./volumetric.frag */
              "./src/WebGL/shaders/lib/volumetric/volumetric.frag"
            ), E = s(
              /*! ./volumetric.vert */
              "./src/WebGL/shaders/lib/volumetric/volumetric.vert"
            );
            const A = {
              fragmentShader: M.default.replace("#define GLSLIFY 1", ""),
              vertexShader: E.default.replace("#define GLSLIFY 1", ""),
              uniforms: v.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/uniforms.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/uniforms.ts ***!
            \******************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const M = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new v.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              data: { type: "i", value: 3 },
              colormap: { type: "i", value: 4 },
              depthmap: { type: "i", value: 5 },
              step: { type: "f", value: 1 },
              maxdepth: { type: "f", value: 100 },
              subsamples: { type: "f", value: 5 },
              textmat: { type: "mat4", value: [] },
              projinv: { type: "mat4", value: [] },
              transfermin: { type: "f", value: -0.2 },
              transfermax: { type: "f", value: 0.2 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/clone.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/clone.ts ***!
            \******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              clone: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../../colors */
              "./src/colors.ts"
            );
            function M(E) {
              let A = {};
              for (const g in E) {
                A[g] = {}, A[g].type = E[g].type;
                var h = E[g].value;
                h instanceof v.Color ? A[g].value = h.clone() : typeof h == "number" ? A[g].value = h : h instanceof Array ? A[g].value = [] : console.error("Error copying shader uniforms from ShaderLib: unknown type for uniform");
              }
              return A;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/index.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/index.ts ***!
            \******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              ShaderUtils: () => (
                /* binding */
                E
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                v.clone
              )
              /* harmony export */
            });
            var v = s(
              /*! ./clone */
              "./src/WebGL/shaders/utils/clone.ts"
            ), M = s(
              /*! ./stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            );
            const E = {
              clone: v.clone,
              stickimposterFragmentShader: M.default
            };
          }
        ),
        /***/
        "./src/WebGL/shapes/Cylinder.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Cylinder.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Cylinder: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            let M = new v.Vector3();
            class E {
              constructor(h = new v.Vector3(), g = new v.Vector3(), C = 0) {
                this.c1 = h, this.c2 = g, this.radius = C, this.direction = new v.Vector3().subVectors(this.c2, this.c1).normalize();
              }
              copy(h) {
                return this.c1.copy(h.c1), this.c2.copy(h.c2), this.direction.copy(h.direction), this.radius = h.radius, this;
              }
              lengthSq() {
                return M.subVectors(this.c2, this.c1).lengthSq();
              }
              applyMatrix4(h) {
                return this.direction.add(this.c1).applyMatrix4(h), this.c1.applyMatrix4(h), this.c2.applyMatrix4(h), this.direction.sub(this.c1).normalize(), this.radius = this.radius * h.getMaxScaleOnAxis(), this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Sphere.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shapes/Sphere.ts ***!
            \************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Sphere: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class M {
              constructor(A = { x: 0, y: 0, z: 0 }, h = 0) {
                this.center = new v.Vector3(A.x, A.y, A.z), this.radius = h;
              }
              set(A, h) {
                return this.center.copy(A), this.radius = h, this;
              }
              copy(A) {
                return this.center.copy(A.center), this.radius = A.radius, this;
              }
              applyMatrix4(A) {
                return this.center.applyMatrix4(A), this.radius = this.radius * A.getMaxScaleOnAxis(), this;
              }
              translate(A) {
                return this.center.add(A), this;
              }
              equals(A) {
                return A.center.equals(this.center) && A.radius === this.radius;
              }
              clone() {
                return new M().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Triangle.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Triangle.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Triangle: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const M = new v.Vector3();
            class E {
              constructor(h = new v.Vector3(), g = new v.Vector3(), C = new v.Vector3()) {
                this.a = h, this.b = g, this.c = C;
              }
              copy(h) {
                return this.a.copy(h.a), this.b.copy(h.b), this.c.copy(h.c), this;
              }
              applyMatrix4(h) {
                return this.a.applyMatrix4(h), this.b.applyMatrix4(h), this.c.applyMatrix4(h), this;
              }
              getNormal() {
                var h = this.a.clone();
                return h.sub(this.b), M.subVectors(this.c, this.b), h.cross(M), h.normalize(), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/index.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/shapes/index.ts ***!
            \***********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                M.Cylinder
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                v.Sphere
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                E.Triangle
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Sphere */
              "./src/WebGL/shapes/Sphere.ts"
            ), M = s(
              /*! ./Cylinder */
              "./src/WebGL/shapes/Cylinder.ts"
            ), E = s(
              /*! ./Triangle */
              "./src/WebGL/shapes/Triangle.ts"
            );
          }
        ),
        /***/
        "./src/autoload.ts": (
          /*!*************************!*\
            !*** ./src/autoload.ts ***!
            \*************************/
          /***/
          (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              autoinit: () => (
                /* binding */
                autoinit
              ),
              /* harmony export */
              autoload: () => (
                /* binding */
                autoload
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* binding */
                processing_autoinit
              ),
              /* harmony export */
              viewers: () => (
                /* binding */
                viewers
              )
              /* harmony export */
            });
            var _GLViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), _ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
              /*! ./utilities */
              "./src/utilities.ts"
            ), _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
              /*! ./colors */
              "./src/colors.ts"
            ), autoinit = !1, processing_autoinit = !1, viewers = {};
            function autoload(viewer, callback) {
              var i, dataname, type;
              if (document.querySelector(".viewer_3Dmoljs") != null && (autoinit = !0), autoinit) {
                processing_autoinit = !0, viewer = viewer ?? null;
                var nviewers = 0;
                document.querySelectorAll(".viewer_3Dmoljs").forEach((viewerdiv) => {
                  var datauri = [], datatypes = [], uri = "";
                  viewerdiv.style.position == "static" && (viewerdiv.style.position = "relative");
                  var UI = null;
                  if (type = null, viewerdiv.dataset.pdb)
                    datauri.push("https://files.rcsb.org/view/" + viewerdiv.dataset.pdb + ".pdb"), datatypes.push("pdb");
                  else if (viewerdiv.dataset.cid)
                    datatypes.push("sdf"), datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + viewerdiv.dataset.cid + "/SDF?record_type=3d");
                  else if (viewerdiv.dataset.href || viewerdiv.dataset.url) {
                    viewerdiv.dataset.href ? uri = viewerdiv.dataset.href : uri = viewerdiv.dataset.url, datauri.push(uri), type = uri.substring(uri.lastIndexOf(".") + 1), datatypes.push(type);
                    var molName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("."));
                    molName == "/" && (molName = uri.substring(uri.lastIndexOf("/") + 1)), viewerdiv.dataset[datatypes[datatypes.length - 1]] = molName;
                  }
                  var divdata = viewerdiv.dataset;
                  for (i in divdata)
                    i.substring(0, 3) === "pdb" && i !== "pdb" ? (datauri.push("https://files.rcsb.org/view/" + divdata[i] + ".pdb"), datatypes.push("pdb")) : i.substring(0, 4) === "href" && i !== "href" ? (uri = divdata[i], datauri.push(uri), datatypes.push(uri.substring(uri.lastIndexOf(".") + 1))) : i.substring(0, 3) === "cid" && i !== "cid" && (datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + divdata[i] + "/SDF?record_type=3d"), datatypes.push("sdf"));
                  var options = {};
                  viewerdiv.dataset.options && (options = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.options));
                  var bgcolor = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(viewerdiv.dataset.backgroundcolor), bgalpha = viewerdiv.dataset.backgroundalpha;
                  bgalpha = bgalpha == null ? 1 : parseFloat(bgalpha);
                  var style = { line: {} };
                  viewerdiv.dataset.style && (style = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.style));
                  var select = {};
                  viewerdiv.dataset.select && (select = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.select));
                  var selectstylelist = [], surfaces = [], labels = [], zoomto = {}, spin = null, d = viewerdiv.dataset, stylere = /style(.+)/, surfre = /surface(.*)/, reslabre = /labelres(.*)/, keys = [];
                  for (dataname in d)
                    Object.prototype.hasOwnProperty.call(d, dataname) && keys.push(dataname);
                  for (keys.sort(), i = 0; i < keys.length; i++) {
                    dataname = keys[i];
                    var m = stylere.exec(dataname), selname, newsel, styleobj;
                    m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), selectstylelist.push([newsel, styleobj])), m = surfre.exec(dataname), m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), surfaces.push([newsel, styleobj])), m = reslabre.exec(dataname), m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), labels.push([newsel, styleobj])), dataname == "zoomto" && (zoomto = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname])), dataname == "spin" && (spin = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]));
                  }
                  var applyStyles = function(P) {
                    for (P.setStyle(select, style), UI && UI.createSelectionAndStyle(select, style), i = 0; i < selectstylelist.length; i++) {
                      let _ = selectstylelist[i][0] || {}, s = selectstylelist[i][1] || { line: {} };
                      P.setStyle(_, s), UI && UI.createSelectionAndStyle(select, style);
                    }
                    for (i = 0; i < surfaces.length; i++) {
                      let _ = surfaces[i][0] || {}, s = surfaces[i][1] || {};
                      UI ? P.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, s, _, _).then((M) => {
                        UI.loadSurface("VDW", _, s, M);
                      }) : P.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, s, _, _);
                    }
                    for (i = 0; i < labels.length; i++) {
                      let _ = labels[i][0] || {}, s = labels[i][1] || {};
                      P.addResLabels(_, s);
                    }
                    P.render(), P.zoomTo(zoomto), spin && P.spin(spin.axis, spin.speed);
                  }, glviewer = viewer;
                  try {
                    var config = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.config) || {};
                    config.backgroundColor === void 0 && (config.backgroundColor = bgcolor), config.backgroundAlpha === void 0 && (config.backgroundAlpha = bgalpha), glviewer == null ? glviewer = viewers[viewerdiv.id || nviewers++] = (0, _GLViewer__WEBPACK_IMPORTED_MODULE_0__.createViewer)(viewerdiv, config) : (glviewer.setBackgroundColor(bgcolor, bgalpha), glviewer.setConfig(config), UI && UI.initiateUI()), viewerdiv.dataset.ui && $3Dmol.StateManager && (UI = new $3Dmol.StateManager(glviewer));
                  } catch (P) {
                    console.log(P), viewerdiv.textContent = "WebGL appears to be disabled.";
                  }
                  if (datauri.length != 0) {
                    let i = 0;
                    var process = function(moldata) {
                      uri = datauri[i];
                      var type = viewerdiv.dataset.type || viewerdiv.dataset.datatype || datatypes[i];
                      if (glviewer.addModel(moldata, type, options), UI) {
                        var modelName = viewerdiv.dataset[datatypes[i]];
                        UI.setModelTitle(modelName);
                      }
                      if (i += 1, i < datauri.length)
                        (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[i]).then(process);
                      else {
                        if (applyStyles(glviewer), viewerdiv.dataset.callback) {
                          var runres = eval(viewerdiv.dataset.callback);
                          typeof runres == "function" && runres(glviewer);
                        }
                        processing_autoinit = !1, callback && callback(glviewer);
                      }
                    };
                    (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[0]).then(process);
                  } else {
                    if (viewerdiv.dataset.element) {
                      var moldataid = "#" + viewerdiv.dataset.element, molelem = document.querySelector(moldataid), moldata = molelem ? molelem.textContent : "";
                      type = viewerdiv.dataset.type || viewerdiv.dataset.datatype, glviewer.addModel(moldata, type, options);
                    }
                    if (applyStyles(glviewer), viewerdiv.dataset.callback) {
                      var runres = eval(viewerdiv.dataset.callback);
                      typeof runres == "function" && runres(glviewer);
                    }
                    processing_autoinit = !1, callback && callback(glviewer);
                  }
                });
              }
            }
            document.onreadystatechange = () => {
              document.readyState === "complete" && autoload();
            };
          }
        ),
        /***/
        "./src/colors.ts": (
          /*!***********************!*\
            !*** ./src/colors.ts ***!
            \***********************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CC: () => (
                /* binding */
                M
              ),
              /* harmony export */
              Color: () => (
                /* binding */
                v
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* binding */
                S
              ),
              /* harmony export */
              chains: () => (
                /* binding */
                c
              ),
              /* harmony export */
              elementColors: () => (
                /* binding */
                g
              ),
              /* harmony export */
              htmlColors: () => (
                /* binding */
                E
              ),
              /* harmony export */
              residues: () => (
                /* binding */
                C
              ),
              /* harmony export */
              ssColors: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            class v {
              constructor(b, w, t) {
                return this.r = 0, this.g = 0, this.b = 0, arguments.length > 1 && typeof b == "number" ? (this.r = b || 0, this.g = w || 0, this.b = t || 0, this) : this.set(b || 0);
              }
              set(b) {
                return b instanceof v ? b.clone() : (typeof b == "number" ? this.setHex(b) : typeof b == "object" && (this.r = (b == null ? void 0 : b.r) || 0, this.g = (b == null ? void 0 : b.g) || 0, this.b = (b == null ? void 0 : b.b) || 0), this);
              }
              setHex(b) {
                return b = Math.floor(b), this.r = (b >> 16 & 255) / 255, this.g = (b >> 8 & 255) / 255, this.b = (b & 255) / 255, this;
              }
              getHex() {
                var b = Math.round(this.r * 255), w = Math.round(this.g * 255), t = Math.round(this.b * 255);
                return b << 16 | w << 8 | t;
              }
              clone() {
                return new v(this.r, this.g, this.b);
              }
              copy(b) {
                return this.r = b.r, this.g = b.g, this.b = b.b, this;
              }
              //return object that represents color components from 0 to 255
              scaled() {
                var b = {};
                return b.r = Math.round(this.r * 255), b.g = Math.round(this.g * 255), b.b = Math.round(this.b * 255), b.a = 1, b;
              }
            }
            class M {
              static color(b) {
                if (!b)
                  return M.cache[0];
                if (b instanceof v)
                  return b;
                if (typeof b == "number" && typeof M.cache[b] < "u")
                  return M.cache[b];
                if (b && Array.isArray(b))
                  return b.map(M.color);
                let w = M.getHex(b), t = new v(w);
                return M.cache[w] = t, t;
              }
              static getHex(b) {
                var w;
                if (Array.isArray(b))
                  return b.map(M.getHex);
                if (typeof b == "string") {
                  let t = b;
                  if (!isNaN(parseInt(t)))
                    return parseInt(t);
                  if (t = t.trim(), t.length == 4 && t[0] == "#" && (t = "#" + t[1] + t[1] + t[2] + t[2] + t[3] + t[3]), t.length == 7 && t[0] == "#")
                    return parseInt(t.substring(1), 16);
                  let r = M.rgbRegEx.exec(t);
                  if (r) {
                    r[1] != "" && console.log("WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.");
                    let u = 0;
                    for (let o = 2; o < 5; o++) {
                      u *= 256;
                      let l = r[o].endsWith("%") ? 255 * parseFloat(r[o]) / 100 : parseFloat(r[o]);
                      u += Math.round(l);
                    }
                    return u;
                  }
                  return ((w = window == null ? void 0 : window.$3Dmol) === null || w === void 0 ? void 0 : w.htmlColors[b.toLowerCase()]) || 0;
                }
                return b;
              }
            }
            M.rgbRegEx = /rgb(a?)\(\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)/i, M.cache = { 0: new v(0) };
            const E = {
              aliceblue: 15792383,
              antiquewhite: 16444375,
              aqua: 65535,
              aquamarine: 8388564,
              azure: 15794175,
              beige: 16119260,
              bisque: 16770244,
              black: 0,
              blanchedalmond: 16772045,
              blue: 255,
              blueviolet: 9055202,
              brown: 10824234,
              burlywood: 14596231,
              cadetblue: 6266528,
              chartreuse: 8388352,
              chocolate: 13789470,
              coral: 16744272,
              cornflowerblue: 6591981,
              cornsilk: 16775388,
              crimson: 14423100,
              cyan: 65535,
              darkblue: 139,
              darkcyan: 35723,
              darkgoldenrod: 12092939,
              darkgray: 11119017,
              darkgrey: 11119017,
              darkgreen: 25600,
              darkkhaki: 12433259,
              darkmagenta: 9109643,
              darkolivegreen: 5597999,
              darkorange: 16747520,
              darkorchid: 10040012,
              darkred: 9109504,
              darksalmon: 15308410,
              darkseagreen: 9419919,
              darkslateblue: 4734347,
              darkslategray: 3100495,
              darkslategrey: 3100495,
              darkturquoise: 52945,
              darkviolet: 9699539,
              deeppink: 16716947,
              deepskyblue: 49151,
              dimgray: 6908265,
              dimgrey: 6908265,
              dodgerblue: 2003199,
              firebrick: 11674146,
              floralwhite: 16775920,
              forestgreen: 2263842,
              fuchsia: 16711935,
              gainsboro: 14474460,
              ghostwhite: 16316671,
              gold: 16766720,
              goldenrod: 14329120,
              gray: 8421504,
              grey: 8421504,
              green: 32768,
              greenyellow: 11403055,
              honeydew: 15794160,
              hotpink: 16738740,
              indianred: 13458524,
              indigo: 4915330,
              ivory: 16777200,
              khaki: 15787660,
              lavender: 15132410,
              lavenderblush: 16773365,
              lawngreen: 8190976,
              lemonchiffon: 16775885,
              lightblue: 11393254,
              lightcoral: 15761536,
              lightcyan: 14745599,
              lightgoldenrodyellow: 16448210,
              lightgray: 13882323,
              lightgrey: 13882323,
              lightgreen: 9498256,
              lightpink: 16758465,
              lightsalmon: 16752762,
              lightseagreen: 2142890,
              lightskyblue: 8900346,
              lightslategray: 7833753,
              lightslategrey: 7833753,
              lightsteelblue: 11584734,
              lightyellow: 16777184,
              lime: 65280,
              limegreen: 3329330,
              linen: 16445670,
              magenta: 16711935,
              maroon: 8388608,
              mediumaquamarine: 6737322,
              mediumblue: 205,
              mediumorchid: 12211667,
              mediumpurple: 9662683,
              mediumseagreen: 3978097,
              mediumslateblue: 8087790,
              mediumspringgreen: 64154,
              mediumturquoise: 4772300,
              mediumvioletred: 13047173,
              midnightblue: 1644912,
              mintcream: 16121850,
              mistyrose: 16770273,
              moccasin: 16770229,
              navajowhite: 16768685,
              navy: 128,
              oldlace: 16643558,
              olive: 8421376,
              olivedrab: 7048739,
              orange: 16753920,
              orangered: 16729344,
              orchid: 14315734,
              palegoldenrod: 15657130,
              palegreen: 10025880,
              paleturquoise: 11529966,
              palevioletred: 14381203,
              papayawhip: 16773077,
              peachpuff: 16767673,
              peru: 13468991,
              pink: 16761035,
              plum: 14524637,
              powderblue: 11591910,
              purple: 8388736,
              rebeccapurple: 6697881,
              red: 16711680,
              rosybrown: 12357519,
              royalblue: 4286945,
              saddlebrown: 9127187,
              salmon: 16416882,
              sandybrown: 16032864,
              seagreen: 3050327,
              seashell: 16774638,
              sienna: 10506797,
              silver: 12632256,
              skyblue: 8900331,
              slateblue: 6970061,
              slategray: 7372944,
              slategrey: 7372944,
              snow: 16775930,
              springgreen: 65407,
              steelblue: 4620980,
              tan: 13808780,
              teal: 32896,
              thistle: 14204888,
              tomato: 16737095,
              turquoise: 4251856,
              violet: 15631086,
              wheat: 16113331,
              white: 16777215,
              whitesmoke: 16119285,
              yellow: 16776960,
              yellowgreen: 10145074
            }, A = {
              //names are in helix-sheet-coil order
              pyMol: { h: 16711680, s: 16776960, c: 65280 },
              Jmol: { h: 16711808, s: 16762880, c: 16777215 }
            }, h = {
              H: 16777215,
              He: 16761035,
              HE: 16761035,
              Li: 11674146,
              LI: 11674146,
              B: 65280,
              C: 13158600,
              N: 9408511,
              O: 15728640,
              F: 14329120,
              Na: 255,
              NA: 255,
              Mg: 2263842,
              MG: 2263842,
              Al: 8421520,
              AL: 8421520,
              Si: 14329120,
              SI: 14329120,
              P: 16753920,
              S: 16762930,
              Cl: 65280,
              CL: 65280,
              Ca: 8421520,
              CA: 8421520,
              Ti: 8421520,
              TI: 8421520,
              Cr: 8421520,
              CR: 8421520,
              Mn: 8421520,
              MN: 8421520,
              Fe: 16753920,
              FE: 16753920,
              Ni: 10824234,
              NI: 10824234,
              Cu: 10824234,
              CU: 10824234,
              Zn: 10824234,
              ZN: 10824234,
              Br: 10824234,
              BR: 10824234,
              Ag: 8421520,
              AG: 8421520,
              I: 10494192,
              Ba: 16753920,
              BA: 16753920,
              Au: 14329120,
              AU: 14329120
            }, g = {
              defaultColor: 16716947,
              /** Jmol-like element colors*/
              Jmol: {
                H: 16777215,
                He: 14286847,
                HE: 14286847,
                Li: 13402367,
                LI: 13402367,
                Be: 12779264,
                BE: 12779264,
                B: 16758197,
                C: 9474192,
                N: 3166456,
                O: 16715021,
                F: 9494608,
                Ne: 11789301,
                NE: 11789301,
                Na: 11230450,
                NA: 11230450,
                Mg: 9109248,
                MG: 9109248,
                Al: 12560038,
                AL: 12560038,
                Si: 1578e4,
                SI: 1578e4,
                P: 16744448,
                S: 16777008,
                Cl: 2093087,
                CL: 2093087,
                Ar: 8442339,
                AR: 8442339,
                K: 9388244,
                Ca: 4062976,
                CA: 4062976,
                Sc: 15132390,
                SC: 15132390,
                Ti: 12567239,
                TI: 12567239,
                V: 10921643,
                Cr: 9083335,
                CR: 9083335,
                Mn: 10255047,
                MN: 10255047,
                Fe: 14706227,
                FE: 14706227,
                Co: 15765664,
                CO: 15765664,
                Ni: 5296208,
                NI: 5296208,
                Cu: 13140019,
                CU: 13140019,
                Zn: 8224944,
                ZN: 8224944,
                Ga: 12750735,
                GA: 12750735,
                Ge: 6721423,
                GE: 6721423,
                As: 12419299,
                AS: 12419299,
                Se: 16752896,
                SE: 16752896,
                Br: 10889513,
                BR: 10889513,
                Kr: 6076625,
                KR: 6076625,
                Rb: 7351984,
                RB: 7351984,
                Sr: 65280,
                SR: 65280,
                Y: 9764863,
                Zr: 9756896,
                ZR: 9756896,
                Nb: 7586505,
                NB: 7586505,
                Mo: 5551541,
                MO: 5551541,
                Tc: 3907230,
                TC: 3907230,
                Ru: 2396047,
                RU: 2396047,
                Rh: 687500,
                RH: 687500,
                Pd: 27013,
                PD: 27013,
                Ag: 12632256,
                AG: 12632256,
                Cd: 16767375,
                CD: 16767375,
                In: 10909043,
                IN: 10909043,
                Sn: 6717568,
                SN: 6717568,
                Sb: 10380213,
                SB: 10380213,
                Te: 13924864,
                TE: 13924864,
                I: 9699476,
                Xe: 4366e3,
                XE: 4366e3,
                Cs: 5707663,
                CS: 5707663,
                Ba: 51456,
                BA: 51456,
                La: 7394559,
                LA: 7394559,
                Ce: 16777159,
                CE: 16777159,
                Pr: 14286791,
                PR: 14286791,
                Nd: 13107143,
                ND: 13107143,
                Pm: 10747847,
                PM: 10747847,
                Sm: 9437127,
                SM: 9437127,
                Eu: 6422471,
                EU: 6422471,
                Gd: 4587463,
                GD: 4587463,
                Tb: 3211207,
                TB: 3211207,
                Dy: 2097095,
                DY: 2097095,
                Ho: 65436,
                HO: 65436,
                Er: 58997,
                ER: 58997,
                Tm: 54354,
                TM: 54354,
                Yb: 48952,
                YB: 48952,
                Lu: 43812,
                LU: 43812,
                Hf: 5096191,
                HF: 5096191,
                Ta: 5089023,
                TA: 5089023,
                W: 2200790,
                Re: 2522539,
                RE: 2522539,
                Os: 2516630,
                OS: 2516630,
                Ir: 1528967,
                IR: 1528967,
                Pt: 13684960,
                PT: 13684960,
                Au: 16765219,
                AU: 16765219,
                Hg: 12105936,
                HG: 12105936,
                Tl: 10900557,
                TL: 10900557,
                Pb: 5724513,
                PB: 5724513,
                Bi: 10375093,
                BI: 10375093,
                Po: 11230208,
                PO: 11230208,
                At: 7688005,
                AT: 7688005,
                Rn: 4358806,
                RN: 4358806,
                Fr: 4325478,
                FR: 4325478,
                Ra: 32e3,
                RA: 32e3,
                Ac: 7384058,
                AC: 7384058,
                Th: 47871,
                TH: 47871,
                Pa: 41471,
                PA: 41471,
                U: 36863,
                Np: 33023,
                NP: 33023,
                Pu: 27647,
                PU: 27647,
                Am: 5528818,
                AM: 5528818,
                Cm: 7888099,
                CM: 7888099,
                Bk: 9064419,
                BK: 9064419,
                Cf: 10565332,
                CF: 10565332,
                Es: 11739092,
                ES: 11739092,
                Fm: 11739066,
                FM: 11739066,
                Md: 11734438,
                MD: 11734438,
                No: 12389767,
                NO: 12389767,
                Lr: 13041766,
                LR: 13041766,
                Rf: 13369433,
                RF: 13369433,
                Db: 13697103,
                DB: 13697103,
                Sg: 14221381,
                SG: 14221381,
                Bh: 14680120,
                BH: 14680120,
                Hs: 15073326,
                HS: 15073326,
                Mt: 15400998,
                MT: 15400998
              },
              /** rasmol-like element colors */
              rasmol: h,
              defaultColors: Object.assign({}, h),
              greenCarbon: Object.assign(Object.assign({}, h), { C: 65280 }),
              cyanCarbon: Object.assign(Object.assign({}, h), { C: 65535 }),
              magentaCarbon: Object.assign(Object.assign({}, h), { C: 16711935 }),
              yellowCarbon: Object.assign(Object.assign({}, h), { C: 16776960 }),
              whiteCarbon: Object.assign(Object.assign({}, h), { C: 16777215 }),
              orangeCarbon: Object.assign(Object.assign({}, h), { C: 16753920 }),
              purpleCarbon: Object.assign(Object.assign({}, h), { C: 8388736 }),
              blueCarbon: Object.assign(Object.assign({}, h), { C: 255 })
            }, C = {
              /** @property standard amino acid color scheme*/
              amino: {
                ALA: 13158600,
                ARG: 1334015,
                ASN: 56540,
                ASP: 15075850,
                CYS: 15132160,
                GLN: 56540,
                GLU: 15075850,
                GLY: 15461355,
                HIS: 8553170,
                ILE: 1016335,
                LEU: 1016335,
                LYS: 1334015,
                MET: 15132160,
                PHE: 3289770,
                PRO: 14456450,
                SER: 16422400,
                THR: 16422400,
                TRP: 11819700,
                TYR: 3289770,
                VAL: 1016335,
                ASX: 16738740,
                GLX: 16738740
              },
              /** @property shapely amino acid color scheme*/
              shapely: {
                ALA: 9240460,
                ARG: 124,
                ASN: 16743536,
                ASP: 10485826,
                CYS: 16777072,
                GLN: 16731212,
                GLU: 6684672,
                GLY: 16777215,
                HIS: 7368959,
                ILE: 19456,
                LEU: 4546117,
                LYS: 4671416,
                MET: 12099650,
                PHE: 5459026,
                PRO: 5395026,
                SER: 16740418,
                THR: 12078080,
                TRP: 5195264,
                TYR: 9203788,
                VAL: 16747775,
                ASX: 16711935,
                GLX: 16711935
              },
              /** @property nucleic acid color scheme*/
              nucleic: {
                A: 10526975,
                G: 16740464,
                I: 8454143,
                C: 16747595,
                T: 10551200,
                U: 16744576
              }
            }, c = {
              /** @property chain based standard color scheme */
              atom: {
                A: 12636415,
                B: 11599792,
                C: 16761032,
                D: 16777088,
                E: 16761087,
                F: 11596016,
                G: 16765040,
                H: 15761536,
                I: 16113331,
                J: 49151,
                K: 13458524,
                L: 6737322,
                M: 10145074,
                N: 15631086,
                O: 52945,
                P: 65407,
                Q: 3978097,
                R: 139,
                S: 12433259,
                T: 25600,
                U: 8388608,
                V: 8421376,
                W: 8388736,
                X: 32896,
                Y: 12092939,
                Z: 11674146
              },
              /** @property hetatm color scheme */
              hetatm: {
                A: 9478351,
                B: 8441752,
                C: 13602992,
                D: 13619056,
                E: 13603023,
                F: 8437952,
                G: 13607008,
                H: 12603504,
                I: 12955267,
                J: 42959,
                K: 11881548,
                L: 5682578,
                M: 9090346,
                N: 12481214,
                O: 46753,
                P: 53103,
                Q: 3447649,
                R: 187,
                S: 10854235,
                T: 37888,
                U: 11534336,
                V: 11579392,
                W: 11534512,
                X: 45232,
                Y: 15250963,
                Z: 12726834
              }
            }, S = {
              /** secondary structure pymol */
              ssPyMol: { prop: "ss", map: A.pyMol },
              ssJmol: { prop: "ss", map: A.Jmol },
              Jmol: { prop: "elem", map: g.Jmol },
              amino: { prop: "resn", map: C.amino },
              shapely: { prop: "resn", map: C.shapely },
              nucleic: { prop: "resn", map: C.nucleic },
              chain: { prop: "chain", map: c.atom },
              rasmol: { prop: "elem", map: g.rasmol },
              default: { prop: "elem", map: g.defaultColors },
              greenCarbon: { prop: "elem", map: g.greenCarbon },
              chainHetatm: { prop: "chain", map: c.hetatm },
              cyanCarbon: { prop: "elem", map: g.cyanCarbon },
              magentaCarbon: { prop: "elem", map: g.magentaCarbon },
              purpleCarbon: { prop: "elem", map: g.purpleCarbon },
              whiteCarbon: { prop: "elem", map: g.whiteCarbon },
              orangeCarbon: { prop: "elem", map: g.orangeCarbon },
              yellowCarbon: { prop: "elem", map: g.yellowCarbon },
              blueCarbon: { prop: "elem", map: g.blueCarbon }
            };
          }
        ),
        /***/
        "./src/glcartoon.ts": (
          /*!**************************!*\
            !*** ./src/glcartoon.ts ***!
            \**************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              drawCartoon: () => (
                /* binding */
                z
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* binding */
                c
              )
              /* harmony export */
            });
            var v = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), M = s(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), E = s(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), A = s(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), h = s(
              /*! ./colors */
              "./src/colors.ts"
            ), g = s(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), C = s(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            function c(T, B) {
              var W = [], k = T;
              k = [], k.push(T[0]);
              var F, U, V, H, G, Y, J, re, le;
              for (F = 1, U = T.length - 1; F < U; F++)
                if (G = T[F], Y = T[F + 1], G.smoothen) {
                  var ie = new v.Vector3((G.x + Y.x) / 2, (G.y + Y.y) / 2, (G.z + Y.z) / 2);
                  ie.atom = G.atom, k.push(ie);
                } else
                  k.push(G);
              for (k.push(T[T.length - 1]), F = -1, V = k.length; F <= V - 3; F++)
                if (H = k[F === -1 ? 0 : F], G = k[F + 1], Y = k[F + 2], J = k[F === V - 3 ? V - 1 : F + 3], re = new v.Vector3().subVectors(Y, H).multiplyScalar(0.5), le = new v.Vector3().subVectors(J, G).multiplyScalar(0.5), !Y.skip)
                  for (var xe = 0; xe < B; xe++) {
                    var se = 1 / B * xe, ce = G.x + se * re.x + se * se * (-3 * G.x + 3 * Y.x - 2 * re.x - le.x) + se * se * se * (2 * G.x - 2 * Y.x + re.x + le.x), Ee = G.y + se * re.y + se * se * (-3 * G.y + 3 * Y.y - 2 * re.y - le.y) + se * se * se * (2 * G.y - 2 * Y.y + re.y + le.y), be = G.z + se * re.z + se * se * (-3 * G.z + 3 * Y.z - 2 * re.z - le.z) + se * se * se * (2 * G.z - 2 * Y.z + re.z + le.z), Le = new v.Vector3(ce, Ee, be);
                    xe < B / 2 ? Le.atom = G.atom : Le.atom = Y.atom, W.push(Le);
                  }
              return W.push(k[k.length - 1]), W;
            }
            const S = 0.5, y = 1.3, b = 0.8, w = 0.4, t = 0.4;
            function r(T, B, W, k) {
              for (var F, U, V, H, G = 0, Y = B.length; G < Y; G++) {
                H = Math.round(G * (k.length - 1) / Y), V = h.CC.color(k[H]);
                var J = T.updateGeoGroup(2), re = J.vertexArray, le = J.colorArray, ie = J.faceArray;
                F = J.vertices, U = F * 3, re[U] = B[G].x, re[U + 1] = B[G].y, re[U + 2] = B[G].z, re[U + 3] = W[G].x, re[U + 4] = W[G].y, re[U + 5] = W[G].z;
                for (var xe = 0; xe < 6; ++xe)
                  le[U + 3 * xe] = V.r, le[U + 1 + 3 * xe] = V.g, le[U + 2 + 3 * xe] = V.b;
                if (G > 0) {
                  var se = [F, F + 1, F - 1, F - 2], ce = J.faceidx;
                  ie[ce] = se[0], ie[ce + 1] = se[1], ie[ce + 2] = se[3], ie[ce + 3] = se[1], ie[ce + 4] = se[2], ie[ce + 5] = se[3], J.faceidx += 6;
                }
                J.vertices += 2;
              }
            }
            function u(T, B, W, k, F, U, V) {
              var H, G, Y, J;
              if (Y = B.length, Y < 2 || B[0].length < 2)
                return;
              for (H = 0; H < Y; H++)
                B[H] = c(B[H], k);
              if (J = B[0].length, !F)
                return r(T, B[0], B[Y - 1], W);
              var re, le, ie, xe, se, ce, Ee = [], be = [], Le = [];
              for (G = 0; G < Y; G++)
                Ee.push(0.25 + 1.5 * Math.sqrt((Y - 1) * G - Math.pow(G, 2)) / (Y - 1)), be.push(0.5), Le.push(2 * (Math.pow(G / Y, 2) - G / Y) + 0.6);
              var ae = [];
              for (G = 0; G < Y * 2 - 1; G++)
                ae[G] = [G, G + 1, G + 1 - 2 * Y, G - 2 * Y];
              ae[Y * 2 - 1] = [
                G,
                G + 1 - 2 * Y,
                G + 1 - 4 * Y,
                G - 2 * Y
              ];
              var pe, we, Ge, We, je, Fe, ze, Be, Ie, Te;
              let Re = T.updateGeoGroup();
              for (H = 0; H < J; H++) {
                let K = T.groups, q = !1;
                Re = T.updateGeoGroup(2 * Y), K != T.groups && H > 0 && (H = H - 1, q = !0), Fe = Math.round(H * (W.length - 1) / J), je = h.CC.color(W[Fe]), se = ie, ce = xe, ie = [], xe = [], re = [], B[0][H].atom !== void 0 && (We = B[0][H].atom, V === "oval" ? le = Ee : V === "rectangle" ? le = be : V === "parabola" && (le = Le)), le || (le = be);
                var ke, Ne;
                for (G = 0; G < Y; G++)
                  H < J - 1 ? ke = B[G][H + 1].clone().sub(B[G][H]) : ke = B[G][H - 1].clone().sub(B[G][H]).negate(), G < Y - 1 ? Ne = B[G + 1][H].clone().sub(B[G][H]) : Ne = B[G - 1][H].clone().sub(B[G][H]).negate(), re[G] = Ne.cross(ke).normalize().multiplyScalar(F * le[G]);
                for (G = 0; G < Y; G++)
                  ie[G] = B[G][H].clone().add(re[G].clone().negate());
                for (G = 0; G < Y; G++)
                  xe[G] = B[G][H].clone().add(re[G]);
                for (ze = Re.vertexArray, Be = Re.colorArray, Ie = Re.faceArray, pe = Re.vertices, we = pe * 3, G = 0; G < Y; G++)
                  ze[we + 3 * G + 0] = ie[G].x, ze[we + 3 * G + 1] = ie[G].y, ze[we + 3 * G + 2] = ie[G].z;
                for (G = 0; G < Y; G++)
                  ze[we + 3 * G + 0 + 3 * Y] = xe[Y - 1 - G].x, ze[we + 3 * G + 1 + 3 * Y] = xe[Y - 1 - G].y, ze[we + 3 * G + 2 + 3 * Y] = xe[Y - 1 - G].z;
                for (G = 0; G < 2 * Y; ++G)
                  Be[we + 3 * G + 0] = je.r, Be[we + 3 * G + 1] = je.g, Be[we + 3 * G + 2] = je.b;
                if (H > 0 && !q) {
                  for (G = 0; G < Y * 2; G++)
                    Te = [
                      pe + ae[G][0],
                      pe + ae[G][1],
                      pe + ae[G][2],
                      pe + ae[G][3]
                    ], Ge = Re.faceidx, Ie[Ge] = Te[0], Ie[Ge + 1] = Te[1], Ie[Ge + 2] = Te[3], Ie[Ge + 3] = Te[1], Ie[Ge + 4] = Te[2], Ie[Ge + 5] = Te[3], Re.faceidx += 6;
                  if (We.clickable || We.hoverable) {
                    var X = [];
                    X.push(new M.Triangle(se[0], ie[0], ie[Y - 1])), X.push(new M.Triangle(se[0], ie[Y - 1], se[Y - 1])), X.push(new M.Triangle(se[Y - 1], ie[Y - 1], xe[Y - 1])), X.push(new M.Triangle(se[Y - 1], xe[Y - 1], ce[Y - 1])), X.push(new M.Triangle(xe[0], ce[0], ce[Y - 1])), X.push(new M.Triangle(xe[Y - 1], xe[0], ce[Y - 1])), X.push(new M.Triangle(ie[0], se[0], ce[0])), X.push(new M.Triangle(xe[0], ie[0], ce[0]));
                    for (G in X)
                      We.intersectionShape.triangle.push(X[G]);
                  }
                }
                Re.vertices += 2 * Y;
              }
              for (ze = Re.vertexArray, Be = Re.colorArray, Ie = Re.faceArray, pe = Re.vertices, we = pe * 3, Ge = Re.faceidx, H = 0; H < Y - 1; H++)
                Te = [H, H + 1, 2 * Y - 2 - H, 2 * Y - 1 - H], Ge = Re.faceidx, Ie[Ge] = Te[0], Ie[Ge + 1] = Te[1], Ie[Ge + 2] = Te[3], Ie[Ge + 3] = Te[1], Ie[Ge + 4] = Te[2], Ie[Ge + 5] = Te[3], Re.faceidx += 6;
              for (H = 0; H < Y - 1; H++)
                Te = [
                  pe - 1 - H,
                  pe - 2 - H,
                  pe - 2 * Y + H + 1,
                  pe - 2 * Y + H
                ], Ge = Re.faceidx, Ie[Ge] = Te[0], Ie[Ge + 1] = Te[1], Ie[Ge + 2] = Te[3], Ie[Ge + 3] = Te[1], Ie[Ge + 4] = Te[2], Ie[Ge + 5] = Te[3], Re.faceidx += 6;
            }
            function o(T, B, W, k, F, U) {
              if (!(B.length < 2)) {
                var V, H;
                if (V = B[0], H = B[B.length - 1], V = c(V, k), H = c(H, k), !F)
                  return r(T, V, H, W);
                var G = [], Y, J, re, le, ie, xe = [
                  [0, 2, -6, -8],
                  [-4, -2, 6, 4],
                  [7, -1, -5, 3],
                  [-3, 5, 1, -7]
                ], se, ce, Ee, be, Le, ae, pe, we, Ge, We, je, Fe, ze, Be, Ie, Te, Re;
                for (we = 0, Ge = V.length; we < Ge; we++) {
                  if (Le = Math.round(we * (W.length - 1) / Ge), be = h.CC.color(W[Le]), G.push(J = V[we]), G.push(J), G.push(re = H[we]), G.push(re), we < Ge - 1) {
                    var ke = V[we + 1].clone().sub(V[we]), Ne = H[we].clone().sub(V[we]);
                    Y = Ne.cross(ke).normalize().multiplyScalar(F);
                  }
                  for (G.push(le = V[we].clone().add(Y)), G.push(le), G.push(ie = H[we].clone().add(Y)), G.push(ie), J.atom !== void 0 && (ae = J.atom), Be = T.updateGeoGroup(8), Ie = Be.vertexArray, Te = Be.colorArray, Re = Be.faceArray, se = Be.vertices, ce = se * 3, Ie[ce] = J.x, Ie[ce + 1] = J.y, Ie[ce + 2] = J.z, Ie[ce + 3] = J.x, Ie[ce + 4] = J.y, Ie[ce + 5] = J.z, Ie[ce + 6] = re.x, Ie[ce + 7] = re.y, Ie[ce + 8] = re.z, Ie[ce + 9] = re.x, Ie[ce + 10] = re.y, Ie[ce + 11] = re.z, Ie[ce + 12] = le.x, Ie[ce + 13] = le.y, Ie[ce + 14] = le.z, Ie[ce + 15] = le.x, Ie[ce + 16] = le.y, Ie[ce + 17] = le.z, Ie[ce + 18] = ie.x, Ie[ce + 19] = ie.y, Ie[ce + 20] = ie.z, Ie[ce + 21] = ie.x, Ie[ce + 22] = ie.y, Ie[ce + 23] = ie.z, We = 0; We < 8; ++We)
                    Te[ce + 3 * We] = be.r, Te[ce + 1 + 3 * We] = be.g, Te[ce + 2 + 3 * We] = be.b;
                  if (we > 0) {
                    var X = pe !== void 0 && ae !== void 0 && pe.serial !== ae.serial;
                    for (We = 0; We < 4; We++) {
                      var K = [
                        se + xe[We][0],
                        se + xe[We][1],
                        se + xe[We][2],
                        se + xe[We][3]
                      ];
                      if (Ee = Be.faceidx, Re[Ee] = K[0], Re[Ee + 1] = K[1], Re[Ee + 2] = K[3], Re[Ee + 3] = K[1], Re[Ee + 4] = K[2], Re[Ee + 5] = K[3], Be.faceidx += 6, ae.clickable || pe.clickable || ae.hoverable || pe.hoverable) {
                        var q = G[K[3]].clone(), fe = G[K[0]].clone(), ue = G[K[2]].clone(), De = G[K[1]].clone();
                        if (q.atom = G[K[3]].atom || null, ue.atom = G[K[2]].atom || null, fe.atom = G[K[0]].atom || null, De.atom = G[K[1]].atom || null, X) {
                          var Se = q.clone().add(fe).multiplyScalar(0.5), Z = ue.clone().add(De).multiplyScalar(0.5), de = q.clone().add(De).multiplyScalar(0.5);
                          We % 2 === 0 ? ((pe.clickable || pe.hoverable) && (je = new M.Triangle(Se, de, q), Fe = new M.Triangle(Z, ue, de), ze = new M.Triangle(de, ue, q), pe.intersectionShape.triangle.push(je), pe.intersectionShape.triangle.push(Fe), pe.intersectionShape.triangle.push(ze)), (ae.clickable || ae.hoverable) && (je = new M.Triangle(fe, De, de), Fe = new M.Triangle(De, Z, de), ze = new M.Triangle(fe, de, Se), ae.intersectionShape.triangle.push(je), ae.intersectionShape.triangle.push(Fe), ae.intersectionShape.triangle.push(ze))) : ((ae.clickable || ae.hoverable) && (je = new M.Triangle(Se, de, q), Fe = new M.Triangle(Z, ue, de), ze = new M.Triangle(de, ue, q), ae.intersectionShape.triangle.push(je), ae.intersectionShape.triangle.push(Fe), ae.intersectionShape.triangle.push(ze)), (pe.clickable || pe.hoverable) && (je = new M.Triangle(fe, De, de), Fe = new M.Triangle(De, Z, de), ze = new M.Triangle(fe, de, Se), pe.intersectionShape.triangle.push(je), pe.intersectionShape.triangle.push(Fe), pe.intersectionShape.triangle.push(ze)));
                        } else
                          (ae.clickable || ae.hoverable) && (je = new M.Triangle(fe, De, q), Fe = new M.Triangle(De, ue, q), ae.intersectionShape.triangle.push(je), ae.intersectionShape.triangle.push(Fe));
                      }
                    }
                  }
                  Be.vertices += 8, pe = ae;
                }
                var me = G.length - 8;
                for (Be = T.updateGeoGroup(8), Ie = Be.vertexArray, Te = Be.colorArray, Re = Be.faceArray, se = Be.vertices, ce = se * 3, Ee = Be.faceidx, we = 0; we < 4; we++) {
                  G.push(G[we * 2]), G.push(G[me + we * 2]);
                  var Pe = G[we * 2], oe = G[me + we * 2];
                  Ie[ce + 6 * we] = Pe.x, Ie[ce + 1 + 6 * we] = Pe.y, Ie[ce + 2 + 6 * we] = Pe.z, Ie[ce + 3 + 6 * we] = oe.x, Ie[ce + 4 + 6 * we] = oe.y, Ie[ce + 5 + 6 * we] = oe.z, Te[ce + 6 * we] = be.r, Te[ce + 1 + 6 * we] = be.g, Te[ce + 2 + 6 * we] = be.b, Te[ce + 3 + 6 * we] = be.r, Te[ce + 4 + 6 * we] = be.g, Te[ce + 5 + 6 * we] = be.b;
                }
                me += 8, je = [se, se + 2, se + 6, se + 4], Fe = [se + 1, se + 5, se + 7, se + 3], Re[Ee] = je[0], Re[Ee + 1] = je[1], Re[Ee + 2] = je[3], Re[Ee + 3] = je[1], Re[Ee + 4] = je[2], Re[Ee + 5] = je[3], Re[Ee + 6] = Fe[0], Re[Ee + 7] = Fe[1], Re[Ee + 8] = Fe[3], Re[Ee + 9] = Fe[1], Re[Ee + 10] = Fe[2], Re[Ee + 11] = Fe[3], Be.faceidx += 12, Be.vertices += 8;
              }
            }
            function l(T, B, W, k, F, U, V) {
              (!V || V === "default") && (V = "rectangle"), V === "edged" ? o(T, B, W, k, F) : (V === "rectangle" || V === "oval" || V === "parabola") && u(T, B, W, k, F, U, V);
            }
            function e(T) {
              return T && T.elem === "C" && T.atom === "CA";
            }
            function n(T, B) {
              if (T && B && T.chain === B.chain) {
                if (!T.hetflag && !B.hetflag && T.reschain === B.reschain && (T.resi === B.resi || T.resi === B.resi - 1))
                  return !0;
                if (T.resi < B.resi) {
                  var W = T.x - B.x, k = T.y - B.y, F = T.z - B.z, U = W * W + k * k + F * F;
                  if (T.atom == "CA" && B.atom == "CA" && U < 16)
                    return !0;
                  if ((T.atom == "P" || B.atom == "P") && U < 64)
                    return !0;
                }
              }
              return !1;
            }
            function a(T, B, W, k, F) {
              if (!(B == null || B.vertices == 0)) {
                F && (B.initTypedArrays(), B.setUpNormals());
                var U = new E.MeshDoubleLambertMaterial();
                U.vertexColors = E.Coloring.FaceColors, typeof W == "number" && W >= 0 && W < 1 && (U.transparent = !0, U.opacity = W), U.outline = k;
                var V = new E.Mesh(B, U);
                T.add(V);
              }
            }
            function p(T, B, W, k, F, U, V, H, G) {
              var Y, J, re, le, ie, xe;
              if (!(!k || !F || !V)) {
                var se = F.sub(k);
                se.normalize();
                var ce = H[G];
                for (J = G + 1; J < H.length && (ce = H[J], ce.atom != V.atom); J++)
                  ;
                if (ce = ce ? new v.Vector3(ce.x, ce.y, ce.z) : new v.Vector3(0, 0, 0), ce.sub(k), V.ss === "arrow start") {
                  var Ee = ce.clone().multiplyScalar(0.3).cross(F);
                  k.add(Ee);
                  var be = ce.clone().cross(se).normalize();
                  se.rotateAboutVector(be, 0.43);
                }
                for (V.style.cartoon.ribbon ? Y = V.style.cartoon.thickness || w : V.style.cartoon.width ? Y = V.style.cartoon.width : V.ss === "c" ? V.atom === "P" ? Y = b : Y = S : V.ss === "arrow start" ? (Y = y, ie = !0) : V.ss === "arrow end" || V.ss === "h" && V.style.cartoon.tubes || V.ss === "tube start" ? Y = S : Y = y, U != null && se.dot(U) < 0 && se.negate(), se.multiplyScalar(Y), J = 0; J < B; J++)
                  re = -1 + J * 2 / (B - 1), le = new v.Vector3(k.x + re * se.x, k.y + re * se.y, k.z + re * se.z), le.atom = V, W && V.ss === "s" && (le.smoothen = !0), T[J].push(le);
                if (ie)
                  for (se.multiplyScalar(2), J = 0; J < B; J++)
                    re = -1 + J * 2 / (B - 1), le = new v.Vector3(k.x + re * se.x, k.y + re * se.y, k.z + re * se.z), le.atom = V, le.smoothen = !1, le.skip = !0, T[J].push(le);
                return xe = V.style.cartoon.style || "default", T.style ? T.style != xe && (console.log("Warning: a cartoon chain's strand-style is ambiguous"), T.style = "default") : T.style = xe, (V.ss === "arrow start" || V.ss === "arrow end") && (V.ss = "s"), ie;
              }
            }
            const x = {
              C: !0,
              CA: !0,
              O: !0,
              P: !0,
              OP2: !0,
              O2P: !0,
              "O5'": !0,
              "O3'": !0,
              "C5'": !0,
              "C2'": !0,
              "O5*": !0,
              "O3*": !0,
              "C5*": !0,
              "C2*": !0,
              N1: !0,
              N3: !0
            }, D = { DA: !0, DG: !0, A: !0, G: !0 }, O = { DT: !0, DC: !0, U: !0, C: !0, T: !0 }, R = { DA: !0, DG: !0, A: !0, G: !0, DT: !0, DC: !0, U: !0, C: !0, T: !0 };
            function z(T, B, W, k = 10) {
              let F = k, U = k;
              var V, H, G, Y, J, re, le, ie, xe, se, ce, Ee, be, Le, ae, pe, we, Ge, We = new E.Geometry(!0), je = new E.Geometry(!0), Fe = [], ze = [], Be = 1, Ie = !1, Te = {};
              for (var Re in A.Gradient.builtinGradients)
                A.Gradient.builtinGradients.hasOwnProperty(Re) && (Te[Re] = new A.Gradient.builtinGradients[Re](W[1], W[0]));
              var ke = function(j, Oe) {
                return W && Oe.color === "spectrum" ? Oe.colorscheme in Te ? Te[Oe.colorscheme].valueToHex(j.resi) : Te.sinebow.valueToHex(j.resi) : (0, C.getColorFromStyle)(j, Oe).getHex();
              };
              for (ie = 0; ie < F; ie++)
                ze[ie] = [];
              var Ne = !1, X = !1, K = [];
              for (ie in B) {
                if (Y = B[ie], Y.elem === "C" && Y.atom === "CA") {
                  var q = n(G, Y);
                  q && Y.ss === "s" ? Ne = !0 : Ne && (G && H && G.style.cartoon.arrows && H.style.cartoon.arrows && (G.ss = "arrow end", H.ss = "arrow start"), Ne = !1), q && (G.ss === "h" || G.ss == "tube start") && G.style.cartoon.tubes ? !X && G.ss != "tube start" && Y.style.cartoon.tubes && (Y.ss = "tube start", X = !0) : X && (G.ss === "tube start" ? G.ss = "tube end" : H && H.style.cartoon.tubes && (H.ss = "tube end"), X = !1), H = G, G = Y;
                }
                Y && Y.atom in x && K.push(Y);
              }
              X && G.style.cartoon.tubes && (G.ss = "tube end", X = !1);
              var fe = function(j) {
                ze[0].length > 0 && l(je, ze, Fe, U, le, Be, ze.style);
                var Oe = [], He = null;
                if (j) {
                  for (ie = 0; ie < F; ie++)
                    Oe[ie] = ze[ie][ze[ie].length - 1];
                  He = Fe[Fe.length - 1];
                }
                for (ze = [], ie = 0; ie < F; ie++)
                  ze[ie] = [];
                if (Fe = [], j) {
                  for (ie = 0; ie < F; ie++)
                    ze[ie].push(Oe[ie]);
                  Fe.push(He);
                }
                a(T, je, Be, Ie, !0), a(T, We, Be, Ie, !1), je = new E.Geometry(!0), We = new E.Geometry(!0);
              };
              G = void 0;
              for (var ue = 0; ue < K.length; ue++) {
                Y = K[ue];
                var De = Y.resn.trim(), Se = De in R;
                if (Be = 1, V = Y.style.cartoon, G && G.style.cartoon && (Be = G.style.cartoon.opacity), G && G.style.cartoon && G.style.cartoon.outline && (Ie = G.style.cartoon.outline), G && G.style.cartoon && (!Y.style.cartoon || G.style.cartoon.opacity != Y.style.cartoon.opacity) && fe(G.chain == Y.chain), V.style === "trace") {
                  if (!Y.hetflag) {
                    if (Y.elem === "C" && Y.atom === "CA" || Se && Y.atom === "P" || Y.atom === "BB") {
                      if (re = ke(Y, V), (0, C.isNumeric)(V.thickness) ? le = V.thickness : le = w, n(G, Y))
                        if (re == J) {
                          var Z = h.CC.color(re);
                          g.GLDraw.drawCylinder(We, G, Y, le, Z, 2, 2);
                        } else {
                          var de = new v.Vector3().addVectors(G, Y).multiplyScalar(0.5), me = h.CC.color(J), Pe = h.CC.color(re);
                          g.GLDraw.drawCylinder(We, G, de, le, me, 2, 0), g.GLDraw.drawCylinder(We, de, Y, le, Pe, 0, 2);
                        }
                      if ((Y.clickable === !0 || Y.hoverable) && Y.intersectionShape !== void 0) {
                        var oe = new v.Vector3(Y.x, Y.y, Y.z);
                        Y.intersectionShape.sphere.push(new M.Sphere(oe, le));
                      }
                      G = Y, J = re;
                    }
                  }
                } else {
                  if (e(Y) || Se && (Y.atom === "P" || Y.atom.indexOf("O5") == 0)) {
                    if (Ge)
                      if (Y.ss === "tube end")
                        Ge = !1, we = new v.Vector3(Y.x, Y.y, Y.z), g.GLDraw.drawCylinder(We, pe, we, 2, h.CC.color(J), 1, 1), Y.ss = "h";
                      else if (G.chain != Y.chain || G.ss === "tube end")
                        Ge = !1, G.ss = "h", we = new v.Vector3(G.x, G.y, G.z), g.GLDraw.drawCylinder(We, pe, we, 2, h.CC.color(J), 1, 1);
                      else
                        continue;
                    if (G && (!n(G, Y) || G.ss === "tube start")) {
                      for (G.ss === "tube start" && (Ge = !0, pe = new v.Vector3(G.x, G.y, G.z), G.ss = "h"), ae && (Ee ? Le = new v.Vector3().addVectors(G, Ee).multiplyScalar(0.5) : Le = new v.Vector3(G.x, G.y, G.z), g.GLDraw.drawCylinder(We, Le, ae, t, h.CC.color(ae.color), 0, 2), p(ze, F, !0, Ee, be, ce, G, K, ue), Fe.push(re), Le = null, ae = null), ze[0].length > 0 && l(je, ze, Fe, U, le, Be, ze.style), ze = [], ie = 0; ie < F; ie++)
                        ze[ie] = [];
                      Fe = [];
                    }
                    if (G === void 0 || G.rescode != Y.rescode || G.resi != Y.resi) {
                      if (ae) {
                        Le = new v.Vector3().addVectors(G, Y).multiplyScalar(0.5);
                        var Ce = Le.clone().sub(ae).multiplyScalar(0.02);
                        Le.add(Ce), g.GLDraw.drawCylinder(We, Le, ae, t, h.CC.color(ae.color), 0, 2), Le = null, ae = null;
                      }
                      re = ke(Y, V), Fe.push(re), (0, C.isNumeric)(V.thickness) ? le = V.thickness : le = w, G = Y, xe = new v.Vector3(G.x, G.y, G.z), xe.resi = G.resi, J = re;
                    }
                    (Y.clickable === !0 || Y.hoverable === !0) && (Y.intersectionShape === void 0 || Y.intersectionShape.triangle === void 0) && (Y.intersectionShape = {
                      sphere: null,
                      cylinder: [],
                      line: [],
                      triangle: []
                    });
                  } else
                    e(G) && Y.atom === "O" || Se && G.atom === "P" && (Y.atom === "OP2" || Y.atom === "O2P") || Se && G.atom.indexOf("O5") == 0 && Y.atom.indexOf("C5") == 0 ? (se = new v.Vector3(Y.x, Y.y, Y.z), se.resi = Y.resi, (Y.atom === "OP2" || Y.atom === "O2P") && (be = new v.Vector3(Y.x, Y.y, Y.z))) : Se && Y.atom.indexOf("O3") == 0 ? Ee = new v.Vector3(Y.x, Y.y, Y.z) : (Y.atom === "N1" && De in D || Y.atom === "N3" && De in O) && (ae = new v.Vector3(Y.x, Y.y, Y.z), ae.color = (0, C.getColorFromStyle)(Y, V).getHex());
                  se && xe && se.resi === xe.resi && (p(ze, F, !0, xe, se, ce, G, K, ue), ce = se, xe = null, se = null, Fe.push(re));
                }
              }
              ae && (Ee ? Le = new v.Vector3().addVectors(G, Ee).multiplyScalar(0.5) : Le = new v.Vector3(G.x, G.y, G.z), g.GLDraw.drawCylinder(We, Le, ae, t, h.CC.color(ae.color), 0, 2), p(ze, F, !0, Ee, be, ce, G, K, ue), Fe.push(re)), fe(!1);
            }
          }
        ),
        /***/
        "./src/index.ts": (
          /*!**********************!*\
            !*** ./src/index.ts ***!
            \**********************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CAP: () => (
                /* reexport safe */
                t.CAP
              ),
              /* harmony export */
              CC: () => (
                /* reexport safe */
                M.CC
              ),
              /* harmony export */
              Color: () => (
                /* reexport safe */
                M.Color
              ),
              /* harmony export */
              CustomLinear: () => (
                /* reexport safe */
                v.CustomLinear
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                C.Cylinder
              ),
              /* harmony export */
              GLDraw: () => (
                /* reexport safe */
                t.GLDraw
              ),
              /* harmony export */
              GLModel: () => (
                /* reexport safe */
                u.GLModel
              ),
              /* harmony export */
              GLShape: () => (
                /* reexport safe */
                w.GLShape
              ),
              /* harmony export */
              GLViewer: () => (
                /* reexport safe */
                o.GLViewer
              ),
              /* harmony export */
              GLVolumetricRender: () => (
                /* reexport safe */
                b.GLVolumetricRender
              ),
              /* harmony export */
              Gradient: () => (
                /* reexport safe */
                v.Gradient
              ),
              /* harmony export */
              GradientType: () => (
                /* reexport safe */
                v.GradientType
              ),
              /* harmony export */
              Label: () => (
                /* reexport safe */
                E.Label
              ),
              /* harmony export */
              LabelCount: () => (
                /* reexport safe */
                E.LabelCount
              ),
              /* harmony export */
              MarchingCube: () => (
                /* reexport safe */
                S.MarchingCube
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* reexport safe */
                S.MarchingCubeInitializer
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                g.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                g.Matrix4
              ),
              /* harmony export */
              Parsers: () => (
                /* reexport safe */
                h.Parsers
              ),
              /* harmony export */
              PausableTimer: () => (
                /* reexport safe */
                c.PausableTimer
              ),
              /* harmony export */
              PointGrid: () => (
                /* reexport safe */
                S.PointGrid
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* reexport safe */
                S.ProteinSurface
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                g.Quaternion
              ),
              /* harmony export */
              ROYGB: () => (
                /* reexport safe */
                v.ROYGB
              ),
              /* harmony export */
              RWB: () => (
                /* reexport safe */
                v.RWB
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                g.Ray
              ),
              /* harmony export */
              Sinebow: () => (
                /* reexport safe */
                v.Sinebow
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                C.Sphere
              ),
              /* harmony export */
              SurfaceType: () => (
                /* reexport safe */
                S.SurfaceType
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                C.Triangle
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                g.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                g.Vector3
              ),
              /* harmony export */
              VolumeData: () => (
                /* reexport safe */
                y.VolumeData
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* reexport safe */
                c.adjustVolumeStyle
              ),
              /* harmony export */
              applyPartialCharges: () => (
                /* reexport safe */
                A.applyPartialCharges
              ),
              /* harmony export */
              autoinit: () => (
                /* reexport safe */
                l.autoinit
              ),
              /* harmony export */
              autoload: () => (
                /* reexport safe */
                l.autoload
              ),
              /* harmony export */
              base64ToArray: () => (
                /* reexport safe */
                c.base64ToArray
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                h.bondLength
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* reexport safe */
                M.builtinColorSchemes
              ),
              /* harmony export */
              builtinGradients: () => (
                /* reexport safe */
                v.builtinGradients
              ),
              /* harmony export */
              chains: () => (
                /* reexport safe */
                M.chains
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                g.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                g.conversionMatrix3
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* reexport safe */
                o.createStereoViewer
              ),
              /* harmony export */
              createViewer: () => (
                /* reexport safe */
                o.createViewer
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* reexport safe */
                o.createViewerGrid
              ),
              /* harmony export */
              deepCopy: () => (
                /* reexport safe */
                c.deepCopy
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                g.degToRad
              ),
              /* harmony export */
              download: () => (
                /* reexport safe */
                c.download
              ),
              /* harmony export */
              drawCartoon: () => (
                /* reexport safe */
                r.drawCartoon
              ),
              /* harmony export */
              elementColors: () => (
                /* reexport safe */
                M.elementColors
              ),
              /* harmony export */
              extend: () => (
                /* reexport safe */
                c.extend
              ),
              /* harmony export */
              get: () => (
                /* reexport safe */
                c.get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* reexport safe */
                c.getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* reexport safe */
                c.getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* reexport safe */
                c.getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* reexport safe */
                c.getExtent
              ),
              /* harmony export */
              getGradient: () => (
                /* reexport safe */
                v.getGradient
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* reexport safe */
                c.getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* reexport safe */
                c.getbin
              ),
              /* harmony export */
              htmlColors: () => (
                /* reexport safe */
                M.htmlColors
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* reexport safe */
                c.isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* reexport safe */
                c.isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* reexport safe */
                c.makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* reexport safe */
                c.mergeGeos
              ),
              /* harmony export */
              normalizeValue: () => (
                /* reexport safe */
                v.normalizeValue
              ),
              /* harmony export */
              partialCharges: () => (
                /* reexport safe */
                A.partialCharges
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* reexport safe */
                l.processing_autoinit
              ),
              /* harmony export */
              residues: () => (
                /* reexport safe */
                M.residues
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                h.setBondLength
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* reexport safe */
                S.setSyncSurface
              ),
              /* harmony export */
              specStringToObject: () => (
                /* reexport safe */
                c.specStringToObject
              ),
              /* harmony export */
              splitMesh: () => (
                /* reexport safe */
                w.splitMesh
              ),
              /* harmony export */
              ssColors: () => (
                /* reexport safe */
                M.ssColors
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* reexport safe */
                r.subdivide_spline
              ),
              /* harmony export */
              syncSurface: () => (
                /* reexport safe */
                S.syncSurface
              ),
              /* harmony export */
              viewers: () => (
                /* reexport safe */
                l.viewers
              )
              /* harmony export */
            });
            var v = s(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), M = s(
              /*! ./colors */
              "./src/colors.ts"
            ), E = s(
              /*! ./Label */
              "./src/Label.ts"
            ), A = s(
              /*! ./partialCharges */
              "./src/partialCharges.ts"
            ), h = s(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), g = s(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), C = s(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), c = s(
              /*! ./utilities */
              "./src/utilities.ts"
            ), S = s(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), y = s(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), b = s(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), w = s(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), t = s(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), r = s(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), u = s(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), o = s(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), l = s(
              /*! ./autoload */
              "./src/autoload.ts"
            );
            s(
              /*! ./specs */
              "./src/specs.ts"
            ), window && (window.$3Dmol = _);
          }
        ),
        /***/
        "./src/parsers/CDJSON.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/CDJSON.ts ***!
            \*******************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CDJSON: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M, E) {
              var A = [[]];
              typeof M == "string" && (M = JSON.parse(M));
              for (var h = M.m, g = h[0].a, C = h[0].b, c = h[0].s, S = E !== void 0 && E.parseStyle !== void 0 ? E.parseStyle : c !== void 0, y = A[A.length - 1].length, b = 0; b < g.length; b++) {
                var w = g[b], t = {};
                t.id = w.i, t.x = w.x, t.y = w.y, t.z = w.z || 0, t.bonds = [], t.bondOrder = [];
                var r = w.l || "C";
                t.elem = r[0].toUpperCase() + r.substring(1).toLowerCase(), t.serial = A[A.length - 1].length, S && (t.style = c[w.s || 0]), A[A.length - 1].push(t);
              }
              for (let u = 0; u < C.length; u++) {
                let o = C[u], l = o.b + y, e = o.e + y, n = o.o || 1, a = A[A.length - 1][l], p = A[A.length - 1][e];
                a.bonds.push(e), a.bondOrder.push(n), p.bonds.push(l), p.bondOrder.push(n);
              }
              return A;
            }
          }
        ),
        /***/
        "./src/parsers/CIF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/CIF.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CIF: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), M = s(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), E = s(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), A = s(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            );
            function h(g, C = {}) {
              var c = [], S = !C.doAssembly, y = c.modelData = [], b = C.assignBonds === void 0 ? !0 : C.assignBonds, w = function(K, q, fe, ue) {
                return new A.Vector3(q, fe, ue).applyMatrix3(K);
              };
              function t(K, q) {
                for (var fe = [], ue = 0, De = 0; De < K.length; ) {
                  for (; K.substring(De, De + q.length) !== q && De < K.length; ) {
                    if (K[De] === "'")
                      for (De++; De < K.length && K[De] !== "'"; )
                        De++;
                    else if (K[De] === '"')
                      for (De++; De < K.length && K[De] !== '"'; )
                        De++;
                    De++;
                  }
                  fe.push(K.substring(ue, De)), ue = De = De + q.length;
                }
                return fe;
              }
              var r = g.split(/\r?\n|\r/), u = [], o = !1;
              for (let K = 0; K < r.length; K++) {
                var l = r[K].split("#")[0];
                if (o ? l[0] === ";" && (o = !1) : l[0] === ";" && (o = !0), o || l !== "") {
                  if (!o && (l = l.trim(), l[0] === "_")) {
                    var e = l.split(/\s/)[0].indexOf(".");
                    if (e > -1) {
                      let q = l.split("");
                      q[e] = "_", l = q.join(""), l = l.substring(0, e) + "_" + l.substring(e + 1);
                    }
                  }
                  u.push(l);
                }
              }
              for (var n = 0; n < u.length; ) {
                for (; !u[n].startsWith("data_") || u[n] === "data_global"; )
                  n++;
                n++;
                for (var a = {}; n < u.length && !u[n].startsWith("data_"); )
                  if (u[n][0] === void 0)
                    n++;
                  else if (u[n][0] === "_") {
                    var p = u[n].split(/\s/)[0].toLowerCase(), x = a[p] = a[p] || [], D = u[n].substring(u[n].indexOf(p) + p.length);
                    if (D === "")
                      if (n++, u[n][0] === ";") {
                        var O = u[n].substring(1);
                        for (n++; u[n] !== ";"; )
                          O = O + `
` + u[n], n++;
                        x.push(O);
                      } else
                        x.push(u[n]);
                    else
                      x.push(D.trim());
                    n++;
                  } else if (u[n].substring(0, 5) === "loop_") {
                    n++;
                    for (var R = []; u[n] === "" || u[n][0] === "_"; ) {
                      if (u[n] !== "") {
                        let K = u[n].split(/\s/)[0].toLowerCase(), q = a[K] = a[K] || [];
                        R.push(q);
                      }
                      n++;
                    }
                    for (var z = 0; n < u.length && u[n][0] !== "_" && !u[n].startsWith("loop_") && !u[n].startsWith("data_"); ) {
                      let K = t(u[n], " ");
                      for (var T = 0; T < K.length; T++)
                        K[T] !== "" && (R[z].push(K[T]), z = (z + 1) % R.length);
                      n++;
                    }
                  } else
                    n++;
                y.push({ symmetries: [] }), c.push([]);
                var B = a._atom_site_id !== void 0 ? a._atom_site_id.length : a._atom_site_label.length, W;
                if (a._cell_length_a !== void 0) {
                  var k = parseFloat(a._cell_length_a), F = parseFloat(a._cell_length_b), U = parseFloat(a._cell_length_c), V = parseFloat(a._cell_angle_alpha) || 90, H = parseFloat(a._cell_angle_beta) || 90, G = parseFloat(a._cell_angle_gamma) || 90;
                  W = (0, A.conversionMatrix3)(k, F, U, V, H, G), y[y.length - 1].cryst = {
                    a: k,
                    b: F,
                    c: U,
                    alpha: V,
                    beta: H,
                    gamma: G
                  };
                }
                for (var Y = 0; Y < B; Y++)
                  if (!(a._atom_site_group_pdb !== void 0 && a._atom_site_group_pdb[Y] === "TER")) {
                    var J = {};
                    if (a._atom_site_cartn_x !== void 0)
                      J.x = parseFloat(a._atom_site_cartn_x[Y]), J.y = parseFloat(a._atom_site_cartn_y[Y]), J.z = parseFloat(a._atom_site_cartn_z[Y]);
                    else {
                      var re = w(W, parseFloat(a._atom_site_fract_x[Y]), parseFloat(a._atom_site_fract_y[Y]), parseFloat(a._atom_site_fract_z[Y]));
                      J.x = re.x, J.y = re.y, J.z = re.z;
                    }
                    J.chain = a._atom_site_auth_asym_id ? a._atom_site_auth_asym_id[Y] : void 0, J.resi = a._atom_site_auth_seq_id ? parseInt(a._atom_site_auth_seq_id[Y]) : void 0, J.resn = a._atom_site_auth_comp_id ? a._atom_site_auth_comp_id[Y].trim() : void 0, J.atom = a._atom_site_auth_atom_id ? a._atom_site_auth_atom_id[Y].replace(/"/gm, "") : void 0, J.hetflag = !a._atom_site_group_pdb || a._atom_site_group_pdb[Y] === "HETA" || a._atom_site_group_pdb[Y] === "HETATM";
                    var le = "X";
                    a._atom_site_type_symbol ? le = a._atom_site_type_symbol[Y].replace(/\(?\+?\d+.*/, "") : a._atom_site_label && (le = a._atom_site_label[Y].split("_")[0].replace(/\(?\d+.*/, "")), J.elem = le[0].toUpperCase() + le.substring(1, 2).toLowerCase(), J.bonds = [], J.ss = "c", J.serial = Y, J.bondOrder = [], J.properties = {}, c[c.length - 1].push(J);
                  }
                if (a._pdbx_struct_oper_list_id !== void 0 && !S)
                  for (let K = 0; K < a._pdbx_struct_oper_list_id.length; K++) {
                    var ie = parseFloat(a["_pdbx_struct_oper_list_matrix[1][1]"][K]), xe = parseFloat(a["_pdbx_struct_oper_list_matrix[1][2]"][K]), se = parseFloat(a["_pdbx_struct_oper_list_matrix[1][3]"][K]), ce = parseFloat(a["_pdbx_struct_oper_list_vector[1]"][K]), Ee = parseFloat(a["_pdbx_struct_oper_list_matrix[2][1]"][K]), be = parseFloat(a["_pdbx_struct_oper_list_matrix[2][2]"][K]), Le = parseFloat(a["_pdbx_struct_oper_list_matrix[2][3]"][K]), ae = parseFloat(a["_pdbx_struct_oper_list_vector[2]"][K]), pe = parseFloat(a["_pdbx_struct_oper_list_matrix[3][1]"][K]), we = parseFloat(a["_pdbx_struct_oper_list_matrix[3][2]"][K]), Ge = parseFloat(a["_pdbx_struct_oper_list_matrix[3][3]"][K]), We = parseFloat(a["_pdbx_struct_oper_list_vector[3]"][K]), je = new A.Matrix4(ie, xe, se, ce, Ee, be, Le, ae, pe, we, Ge, We);
                    y[y.length - 1].symmetries.push(je);
                  }
                var Fe = function(K) {
                  var q = K.match("-");
                  K = K.replace(/[-xyz]/g, "");
                  var fe = K.split("/"), ue, De;
                  return fe[1] === void 0 ? De = 1 : De = parseInt(fe[1]), fe[0] === "" ? ue = 1 : ue = parseInt(fe[0]), ue / De * (q ? -1 : 1);
                };
                if (a._symmetry_equiv_pos_as_xyz !== void 0 && !S)
                  for (var ze = 0; ze < a._symmetry_equiv_pos_as_xyz.length; ze++) {
                    var Be = a._symmetry_equiv_pos_as_xyz[ze].replace(/["' ]/g, ""), Ie = Be.split(",").map(function(q) {
                      return q.replace(/-/g, "+-");
                    });
                    let K = new A.Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
                    for (let q = 0; q < 3; q++) {
                      var Te = Ie[q].split("+");
                      for (let fe = 0; fe < Te.length; fe++) {
                        var Re = Te[fe];
                        if (Re !== "") {
                          var ke = Fe(Re);
                          Re.match("x") ? K.elements[q + 0] = ke : Re.match("y") ? K.elements[q + 4] = ke : Re.match("z") ? K.elements[q + 8] = ke : K.elements[q + 12] = ke;
                        }
                      }
                    }
                    var Ne = W.getMatrix4(), X = new A.Matrix4().getInverse(Ne, !0);
                    K = new A.Matrix4().multiplyMatrices(K, X), K = new A.Matrix4().multiplyMatrices(Ne, K), y[y.length - 1].symmetries.push(K);
                  }
              }
              for (let K = 0; K < c.length; K++)
                b && (0, v.assignBonds)(c[K]), (0, M.computeSecondaryStructure)(c[K], C.hbondCutoff), (0, E.processSymmetries)(y[K].symmetries, c[K], C, y[K].cryst), C.duplicateAssemblyAtoms && !C.dontConnectDuplicatedAtoms && b && (0, v.assignBonds)(c[K]);
              return c;
            }
          }
        ),
        /***/
        "./src/parsers/CUBE.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/CUBE.ts ***!
            \*****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              CUBE: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), E = s(
              /*! ./utils/anumToSymbol */
              "./src/parsers/utils/anumToSymbol.ts"
            );
            function A(h, g) {
              g = g || {};
              var C = [[]], c = h.split(/\r?\n/), S = g.assignBonds === void 0 ? !0 : g.assignBonds;
              if (c.length < 6)
                return C;
              var y = c[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), b = Math.abs(parseFloat(y[0]));
              let w = {};
              var t = w.origin = new v.Vector3(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3]));
              y = c[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), y = c[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var r = y[0] > 0 ? 0.529177 : 1;
              t.multiplyScalar(r);
              var u = Math.abs(y[0]), o = new v.Vector3(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3])).multiplyScalar(r);
              y = c[4].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var l = Math.abs(y[0]), e = new v.Vector3(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3])).multiplyScalar(r);
              y = c[5].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var n = Math.abs(y[0]), a = new v.Vector3(parseFloat(y[1]), parseFloat(y[2]), parseFloat(y[3])).multiplyScalar(r);
              if (w.size = { x: u, y: l, z: n }, w.unit = new v.Vector3(o.x, e.y, a.z), o.y != 0 || o.z != 0 || e.x != 0 || e.z != 0 || a.x != 0 || a.y != 0) {
                w.matrix4 = new v.Matrix4(o.x, e.x, a.x, 0, o.y, e.y, a.y, 0, o.z, e.z, a.z, 0, 0, 0, 0, 1);
                let T = new v.Matrix4().makeTranslation(t.x, t.y, t.z);
                w.matrix4 = w.matrix4.multiplyMatrices(T, w.matrix4), w.matrix = w.matrix4.matrix3FromTopLeft(), w.origin = new v.Vector3(0, 0, 0), w.unit = new v.Vector3(1, 1, 1);
              }
              C.modelData = [{ cryst: w }], c = c.splice(6, b);
              for (var p = C[C.length - 1].length, x = p + c.length, D = p; D < x; ++D) {
                var O = {};
                O.serial = D;
                var R = c[D - p], z = R.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                O.elem = E.anumToSymbol[z[0]], O.x = parseFloat(z[2]) * r, O.y = parseFloat(z[3]) * r, O.z = parseFloat(z[4]) * r, O.hetflag = !0, O.bonds = [], O.bondOrder = [], O.properties = {}, C[C.length - 1].push(O);
              }
              if (S)
                for (let T = 0; T < C.length; T++)
                  (0, M.assignBonds)(C[T]);
              return C;
            }
          }
        ),
        /***/
        "./src/parsers/GRO.ts": (
          /*!****************************!*\
            !*** ./src/parsers/GRO.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              GRO: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), M = s(
              /*! ./utils/atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            );
            function E(A) {
              for (var h = [], g = A.split(/\r?\n|\r/); g.length > 0 && !(g.length < 3); ) {
                var C = parseInt(g[1]);
                if (isNaN(C) || C <= 0 || g.length < C + 3)
                  break;
                var c = [];
                h.push(c);
                for (var S = 2, y = c.length, b = y + C, w = y; w < b; w++) {
                  var t = g[S++], r = {};
                  r.serial = w, r.atom = t.slice(10, 15).trim(), r.elem = (0, M.atomNameToElem)(r.atom, !0), r.x = 10 * parseFloat(t.slice(20, 28)), r.y = 10 * parseFloat(t.slice(28, 36)), r.z = 10 * parseFloat(t.slice(36, 44)), r.resi = parseInt(t.slice(0, 5)), r.resn = t.slice(5, 10).trim(), r.bonds = [], r.bondOrder = [], r.properties = {}, t.length > 44 && (r.dx = 10 * parseFloat(t.slice(44, 52)), r.dy = 10 * parseFloat(t.slice(52, 60)), r.dz = 10 * parseFloat(t.slice(60, 68))), c[w] = r;
                }
                if (g.length <= S + 3) {
                  var u = g[S++], o = u.trim().split(/\s+/);
                  if (o.length == 3) {
                    for (var l = 0; l < 3; l++)
                      o[l] = parseFloat(o[l]) * 10;
                    h.box = o;
                  }
                }
                g.splice(0, ++S);
              }
              for (let e = 0; e < h.length; e++)
                (0, v.assignPDBBonds)(h[e]);
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/LAMMPSTRJ.ts": (
          /*!**********************************!*\
            !*** ./src/parsers/LAMMPSTRJ.ts ***!
            \**********************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              LAMMPSTRJ: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function M(E, A) {
              for (var h = [], g = {
                id: "serial",
                type: "atom",
                element: "elem",
                q: "charge",
                radius: "radius",
                x: "x",
                xu: "x",
                xs: "x",
                xsu: "x",
                y: "y",
                yu: "y",
                ys: "y",
                ysu: "y",
                z: "z",
                zu: "z",
                zs: "z",
                zsu: "z"
              }, C = E.split(/\r?\n|\r/), c = 0, S = 0, y = 0; y < C.length - 9; ) {
                for (var b = y; b < C.length; b++)
                  if (C[b].match(/ITEM: NUMBER OF ATOMS/) && (S = parseInt(C[b + 1])), C[b].match(/ITEM: ATOMS/)) {
                    c = b + 1;
                    break;
                  }
                var w = C[c - 1].replace("ITEM: ATOMS ", "").split(" ");
                h.push([]);
                for (let n = c; n < c + S; n++) {
                  for (var t = {}, r = {}, u = C[n].split(" "), o = 0; o < u.length; o++) {
                    var l = g[w[o]];
                    l != null && (l == "serial" ? t[l] = parseInt(u[o]) : l == "x" || l == "y" || l === "z" ? t[l] = parseFloat(u[o]) : l == "charge" || l == "radius" ? r[l] = parseFloat(u[o]) : t[l] = u[o]), t.properties = r, t.bonds = [], t.bondOrder = [];
                  }
                  h[h.length - 1][n - c] = t;
                }
                y = c + S - 1;
              }
              if (A.assignBonds)
                for (var e = 0; e < h.length; e++)
                  (0, v.assignBonds)(h[e]);
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/MMTF.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MMTF.ts ***!
            \*****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MMTFparser: () => (
                /* binding */
                S
              )
              /* harmony export */
            });
            var v = s(
              /*! ../utilities */
              "./src/utilities.ts"
            ), M = s(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), E = s(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), A = s(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), h = s(
              /*! ./src/vendor/mmtf.js */
              "./src/vendor/mmtf.js"
            ), g = function(y) {
              return String.fromCharCode.apply(null, y).replace(/\0/g, "");
            }, C = function(y) {
              return y == 0 || y == 2 || y == 4 ? "h" : y == 3 ? "s" : "c";
            };
            let c = /* @__PURE__ */ new Set([
              "D-SACCHARIDE",
              "D-SACCHARIDE 1,4 AND 1,4 LINKING",
              "D-SACCHARIDE 1,4 AND 1,6 LINKING",
              "L-SACCHARIDE",
              "L-SACCHARIDE 1,4 AND 1,4 LINKING",
              "L-SACCHARIDE 1,4 AND 1,6 LINKING",
              "NON-POLYMER",
              "OTHER",
              "PEPTIDE-LIKE",
              "SACCHARIDE"
            ]);
            function S(y, b) {
              var w = !b.keepH, t = b.altLoc ? b.altLoc : "A", r = !!b.noSecondaryStructure, u = !b.noComputeSecondaryStructure, o = !b.doAssembly, l = b.assemblyIndex ? b.assemblyIndex : 0;
              typeof y == "string" ? y = (0, v.base64ToArray)(y) : y = new Uint8Array(y);
              var e = h.decode(y), n = [[]], a = n.modelData = [], p = 0, x = 0, D = 0, O = e.secStructList, R = e.bFactorList, z = e.altLocList, T = e.occupancyList, B = e.bondAtomList, W = e.bondOrderList, k = e.numModels;
              if (k == 0)
                return n;
              b.multimodel || (k = 1);
              var F, U, V, H, G, Y, J = [];
              if (!o && e.bioAssemblyList && e.bioAssemblyList.length > 0) {
                var re = e.bioAssemblyList[l].transformList;
                for (F = 0, Y = re.length; F < Y; F++) {
                  var le = new M.Matrix4(re[F].matrix);
                  le.transpose(), J.push(le);
                }
              }
              var ie = null;
              if (e.unitCell) {
                var xe = e.unitCell;
                ie = { a: xe[0], b: xe[1], c: xe[2], alpha: xe[3], beta: xe[4], gamma: xe[5] };
              }
              let se = [];
              e.entityList.forEach((ve) => {
                ve.chainIndexList.forEach(($) => {
                  se[$] = ve.type == "polymer";
                });
              });
              var ce = 0;
              for (G = 0; G < k; G++) {
                var Ee = e.chainsPerModel[G], be = n[n.length - 1], Le = [];
                for (a.push({ symmetries: J, cryst: ie }), F = 0; F < Ee; ++F) {
                  var ae = e.groupsPerChain[p], pe = g(e.chainIdList.subarray(p * 4, p * 4 + 4));
                  e.chainNameList && (pe = g(e.chainNameList.subarray(p * 4, p * 4 + 4)));
                  var we = x, Ge = "";
                  for (U = 0; U < ae; ++U) {
                    var We = e.groupList[e.groupTypeList[x]], je = We.atomNameList.length, Fe = 0, ze = !1, Be = !1;
                    if (O) {
                      Fe = O[x];
                      var Ie = C(Fe);
                      (x == 0 || Ie != Ge) && (ze = !0), Ge = Ie;
                      var Te = x + 1;
                      (Te >= O.length || C(O[Te] != Ie)) && (Be = !0);
                    }
                    var Re = e.groupIdList[x], ke = We.groupName;
                    let ve = We.chemCompType;
                    var Ne = D;
                    let $ = c.has(ve) || !se[p];
                    for (V = 0; V < je; ++V) {
                      var X = We.elementList[V];
                      if (w && X == "H") {
                        D += 1;
                        continue;
                      }
                      var K = "";
                      R && (K = R[D]);
                      var q = "";
                      z && z[D] && (q = String.fromCharCode(z[D]));
                      var fe = "";
                      if (T && (fe = T[D]), q != "" && q != t && t != "*") {
                        D += 1;
                        continue;
                      }
                      var ue = e.atomIdList[D], De = We.atomNameList[V], Se = 0;
                      We.atomChargeList && (Se = We.atomChargeList[V]);
                      var Z = e.xCoordList[D], de = e.yCoordList[D], me = e.zCoordList[D];
                      Le[D] = be.length, be.push({
                        resn: ke,
                        x: Z,
                        y: de,
                        z: me,
                        elem: X,
                        hetflag: $,
                        chain: pe,
                        resi: Re,
                        icode: q,
                        rescode: Re + (q != " " ? "^" + q : ""),
                        // resi
                        // and
                        // icode
                        serial: ue,
                        altLoc: q,
                        index: D,
                        atom: De,
                        bonds: [],
                        ss: C(Fe),
                        ssbegin: ze,
                        ssend: Be,
                        bondOrder: [],
                        properties: { charge: Se, occupancy: fe },
                        b: K
                      }), D += 1;
                    }
                    var Pe = We.bondAtomList;
                    for (V = 0, H = We.bondOrderList.length; V < H; ++V) {
                      var oe = Ne + Pe[V * 2], Ce = Ne + Pe[V * 2 + 1], j = We.bondOrderList[V], Oe = Le[oe], He = Le[Ce], I = be[Oe], ge = be[He];
                      I && ge && (I.bonds.push(He), I.bondOrder.push(j), ge.bonds.push(Oe), ge.bondOrder.push(j));
                    }
                    x += 1;
                  }
                  for (x = we, U = 0; U < ae; ++U)
                    x += 1;
                  p += 1;
                }
                if (B)
                  for (let ve = ce, $ = B.length; ve < $; ve += 2) {
                    let ne = B[ve], ye = B[ve + 1], Ze = W ? W[ve / 2] : 1;
                    if (ne >= D) {
                      ce = ve;
                      break;
                    }
                    let Ke = Le[ne], Ve = Le[ye], qe = be[Ke], Et = be[Ve];
                    qe && Et && (qe.bonds.push(Ve), qe.bondOrder.push(Ze), Et.bonds.push(Ke), Et.bondOrder.push(Ze));
                  }
                b.multimodel && (b.onemol || n.push([]));
              }
              if (!o)
                for (let ve = 0; ve < n.length; ve++)
                  (0, A.processSymmetries)(a[ve].symmetries, n[ve], b, a[ve].cryst);
              return u && !r && (0, E.computeSecondaryStructure)(n, b.hbondCutoff), n;
            }
          }
        ),
        /***/
        "./src/parsers/MOL2.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MOL2.ts ***!
            \*****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              MOL2: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            let v = {
              "C.1": "C",
              C1: "C",
              "C.2": "C",
              C2: "C",
              "C.3": "C",
              C3: "C",
              "C.ar": "C",
              Car: "C",
              "C.cat": "C",
              Ccat: "C",
              "H.spc": "H",
              Hspc: "H",
              "H.t3p": "H",
              Ht3p: "H",
              "N.1": "N",
              N1: "N",
              "N.2": "N",
              N2: "N",
              "N.3": "N",
              N3: "N",
              "N.4": "N",
              N4: "N",
              "N.am": "N",
              Nam: "N",
              "N.ar": "N",
              Nar: "N",
              "N.p13": "N",
              Np13: "N",
              "O.2": "O",
              O2: "O",
              "O.3": "O",
              O3: "O",
              "O.co2": "O",
              Oco2: "O",
              "O.spc": "O",
              Ospc: "O",
              "O.t3p": "O",
              Ot3p: "O",
              "P.3": "P",
              P3: "P",
              "S.2": "S",
              S2: "S",
              "S.3": "S",
              S3: "S",
              "S.o": "S",
              So: "S",
              "S.o2": "S",
              So2: "S"
            };
            function M(E, A) {
              var h = [[]], g = !1;
              typeof A.keepH < "u" && (g = !A.keepH);
              var C = E.search(/@<TRIPOS>MOLECULE/), c = E.search(/@<TRIPOS>ATOM/);
              if (C == -1 || c == -1)
                return h;
              for (var S = E.substring(C).split(/\r?\n|\r/); S.length > 0; ) {
                var y = [], b = S[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), w = parseInt(b[0]), t = 0;
                b.length > 1 && (t = parseInt(b[1]));
                var r = 4, u;
                for (u = 3; u < S.length; u++)
                  if (S[u] == "@<TRIPOS>ATOM") {
                    r = u + 1;
                    break;
                  }
                var o = h[h.length - 1].length, l = o + w, e;
                for (u = o; u < l; u++) {
                  e = S[r++], b = e.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  var n = {}, a = b[5];
                  if (v[a] !== void 0 ? a = v[a] : (a = a.split(".")[0], a = a[0].toUpperCase() + a.substring(1).toLowerCase()), n.atom = b[1], n.elem = a, !(n.elem == "H" && g)) {
                    var p = h[h.length - 1].length, x = parseInt(b[0]);
                    n.serial = x, n.x = parseFloat(b[2]), n.y = parseFloat(b[3]), n.z = parseFloat(b[4]), n.atom = b[5];
                    var D = parseFloat(b[8]);
                    n.index = p, n.bonds = [], n.bondOrder = [], n.properties = {
                      charge: D,
                      partialCharge: D
                    }, y[x] = p, h[h.length - 1].push(n);
                  }
                }
                for (var O = !1; r < S.length; )
                  if (S[r++] == "@<TRIPOS>BOND") {
                    O = !0;
                    break;
                  }
                if (O && t)
                  for (u = 0; u < t; u++) {
                    e = S[r++], b = e.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                    var R = parseInt(b[1]), z = h[h.length - 1][y[R]], T = parseInt(b[2]), B = h[h.length - 1][y[T]], W = parseInt(b[3]);
                    isNaN(W) && (W = 1), z !== void 0 && B !== void 0 && (z.bonds.push(y[T]), z.bondOrder.push(W), B.bonds.push(y[R]), B.bondOrder.push(W));
                  }
                if (A.multimodel) {
                  A.onemol || h.push([]), S.splice(0, r), E = S.join(`
`);
                  continue;
                } else
                  break;
              }
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/PDB.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PDB.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              PDB: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/getSinglePDB */
              "./src/parsers/utils/getSinglePDB.ts"
            );
            function M(E, A) {
              A = A || {};
              var h = [], g = {};
              h.modelData = [];
              for (var C = E.split(/\r?\n|\r/); C.length > 0; ) {
                var c = (0, v.getSinglePDB)(C, A, g), S = c[0], y = c[1];
                if (C = c[2], S.length != 0) {
                  if (A.multimodel && A.onemol && h.length > 0)
                    for (var b = h[0].length, w = 0; w < S.length; w++) {
                      var t = S[w];
                      t.index = w;
                      for (var r = 0; r < t.bonds.length; r++)
                        t.bonds[r] += b;
                      h[0].push(t);
                    }
                  else
                    h.modelData.push(y), h.push(S);
                  if (!A.multimodel)
                    break;
                }
              }
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/PQR.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PQR.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              PQR: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), M = s(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            );
            function E(A, h) {
              var g = [[]], C = !h.noSecondaryStructure;
              g.modelData = [{ symmetries: [] }];
              var c = [], S = A.split(/\r?\n|\r/), y;
              for (let O = 0; O < S.length; O++) {
                y = S[O].replace(/^\s*/, "");
                var b = y.substring(0, 6);
                if (b.indexOf("END") == 0)
                  if (h.multimodel) {
                    h.onemol || g.push([]);
                    continue;
                  } else
                    break;
                else if (b == "ATOM  " || b == "HETATM") {
                  var w;
                  let R = parseInt(y.substring(6, 11)), z = y.substring(12, 16).replace(/ /g, ""), T = y.substring(17, 20).trim(), B = y.substring(21, 22), W = parseInt(y.substring(22, 26));
                  var t = y.substring(30).trim().split(/\s+/), r = parseFloat(t[0]), u = parseFloat(t[1]), o = parseFloat(t[2]), l = parseFloat(t[3]), e = parseFloat(t[4]), n = z[0];
                  z.length > 1 && z[1].toUpperCase() != z[1] && (n = z.substring(0, 2)), y[0] == "H" ? w = !0 : w = !1, c[R] = g[g.length - 1].length, g[g.length - 1].push({
                    resn: T,
                    x: r,
                    y: u,
                    z: o,
                    elem: n,
                    hetflag: w,
                    chain: B,
                    resi: W,
                    serial: R,
                    atom: z,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {
                      charge: l,
                      partialCharge: l,
                      radius: e
                    },
                    pdbline: y
                  });
                } else if (b == "CONECT") {
                  var a = parseInt(y.substring(6, 11)), p = g[g.length - 1][c[a]];
                  for (let R = 0; R < 4; R++) {
                    var x = parseInt(y.substring([11, 16, 21, 26][R], [11, 16, 21, 26][R] + 5)), D = g[g.length - 1][c[x]];
                    p !== void 0 && D !== void 0 && (p.bonds.push(c[x]), p.bondOrder.push(1));
                  }
                }
              }
              for (let O = 0; O < g.length; O++)
                (0, v.assignPDBBonds)(g[O]), C && (0, M.computeSecondaryStructure)(g[O], h.hbondCutoff);
              return g;
            }
          }
        ),
        /***/
        "./src/parsers/PRMTOP.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/PRMTOP.ts ***!
            \*******************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              PRMTOP: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M) {
              var E = [], A, h = 0, g = M.split(/\r?\n|\r/);
              if (g.length > 0 && g[0].includes("VERSION")) {
                var C = g.filter(function(r) {
                  return r.includes("POINTERS") || r.includes("ATOM_NAME") || r.includes("CHARGE") || r.includes("RADII") || r.includes("BONDS_INC_HYDROGEN") || r.includes("BONDS_WITHOUT_HYDROGEN");
                }), c = w("POINTERS");
                if (c == -1)
                  return [];
                var S = t(c), y = parseInt(g[c + 1].slice(0, S[1]));
                if (isNaN(y) || y <= 0)
                  return [];
                if (c = w("ATOM_NAME"), c == -1)
                  return [];
                S = t(c);
                var b = S[0];
                for (let r = 0; r < y / S[0]; r++) {
                  r == parseInt(y / S[0]) && (b = y % S[0]);
                  for (let u = 0; u < b; u++) {
                    let o = {}, l = { charge: "", radii: "" };
                    o.serial = h, o.x = 0, o.y = 0, o.z = 0, o.atom = g[c + 1].slice(S[1] * u, S[1] * (u + 1)), o.elem = g[c + 1].slice(S[1] * u, S[1] * u + 1), o.properties = l, o.bonds = [], o.bondOrder = [], E.push(o), h++;
                  }
                  c++;
                }
                if (c = w("CHARGE"), c != -1) {
                  S = t(c), h = 0, b = S[0];
                  for (let r = 0; r < y / S[0]; r++) {
                    r == parseInt(y / S[0]) && (b = y % S[0]);
                    for (let u = 0; u < b; u++)
                      E[h].properties.charge = parseFloat(g[c + 1].slice(S[1] * u, S[1] * (u + 1))), h++;
                    c++;
                  }
                }
                if (c = w("RADII"), c != -1) {
                  S = t(c), h = 0, b = S[0];
                  for (let r = 0; r < y / S[0]; r++) {
                    r == parseInt(y / S[0]) && (b = y % S[0]);
                    for (let u = 0; u < b; u++)
                      E[h].properties.radii = parseFloat(g[c + 1].slice(S[1] * u, S[1] * (u + 1))), h++;
                    c++;
                  }
                }
                if (c = w("BONDS_WITHOUT_HYDROGEN"), c != -1)
                  for (S = t(c), h = 0, b = S[0], c = c + 1; !g[c].match(/^%FLAG/); ) {
                    g[c + 1].match(/^%FLAG/) && (b = y % S[0]);
                    for (let r = 0; r < b; r++)
                      h % 3 == 0 ? A = parseInt(g[c].slice(S[1] * r, S[1] * (r + 1)) / 3) : h % 3 == 1 && E[A].bonds.push(parseInt(g[c].slice(S[1] * r, S[1] * (r + 1)) / 3)), h++;
                    c++;
                  }
                if (c = w("BONDS_INC_HYDROGEN"), c != -1)
                  for (S = t(c), h = 0, b = S[0], c = c + 1; !g[c].match(/^%FLAG/); ) {
                    g[c + 1].match(/^%FLAG/) && (b = y % S[0]);
                    for (let r = 0; r < b; r++)
                      h % 3 == 0 ? A = parseInt(g[c].slice(S[1] * r, S[1] * (r + 1)) / 3) : h % 3 == 1 && E[A].bonds.push(parseInt(g[c].slice(S[1] * r, S[1] * (r + 1)) / 3)), h++;
                    c++;
                  }
              } else
                return [];
              function w(r) {
                var u = g.indexOf(C.filter(function(o) {
                  return o.includes(r);
                })[0]);
                if (Number.isInteger(u) && u > 0) {
                  for (; !g[u].includes("FORMAT"); )
                    u++;
                  return u;
                } else
                  return -1;
              }
              function t(r) {
                var u = g[r].match(/\((\d*)\S*/), o = g[r].match(/[a-zA-Z](\d*)\)\s*/);
                return o == null && (o = g[r].match(/[a-zA-Z](\d*)\.\d*\)\s*/)), [u[1], o[1]];
              }
              return [E];
            }
          }
        ),
        /***/
        "./src/parsers/SDF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/SDF.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              SDF: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = function(A, h) {
              var g = [[]], C = !1;
              for (typeof h.keepH < "u" && (C = !h.keepH); A.length > 0 && !(A.length < 4); ) {
                var c = parseInt(A[3].substring(0, 3));
                if (isNaN(c) || c <= 0)
                  break;
                var S = parseInt(A[3].substring(3, 6)), y = 4;
                if (A.length < 4 + c + S)
                  break;
                var b = [], w = g[g.length - 1].length, t = w + c, r, u;
                for (r = w; r < t; r++, y++) {
                  u = A[y];
                  var o = {}, l = u.substring(31, 34).replace(/ /g, "");
                  o.atom = o.elem = l[0].toUpperCase() + l.substring(1).toLowerCase(), (o.elem !== "H" || !C) && (o.serial = r, b[r] = g[g.length - 1].length, o.x = parseFloat(u.substring(0, 10)), o.y = parseFloat(u.substring(10, 20)), o.z = parseFloat(u.substring(20, 30)), o.hetflag = !0, o.bonds = [], o.bondOrder = [], o.properties = {}, o.index = g[g.length - 1].length, g[g.length - 1].push(o));
                }
                for (r = 0; r < S; r++, y++) {
                  u = A[y];
                  var e = b[parseInt(u.substring(0, 3)) - 1 + w], n = b[parseInt(u.substring(3, 6)) - 1 + w], a = parseFloat(u.substring(6));
                  typeof e < "u" && typeof n < "u" && (g[g.length - 1][e].bonds.push(n), g[g.length - 1][e].bondOrder.push(a), g[g.length - 1][n].bonds.push(e), g[g.length - 1][n].bondOrder.push(a));
                }
                if (h.multimodel) {
                  for (h.onemol || g.push([]); A[y] !== "$$$$" && y < A.length; )
                    y++;
                  A.splice(0, ++y);
                } else
                  break;
              }
              return g;
            }, M = function(A, h) {
              var g = [[]], C = !1;
              for (typeof h.keepH < "u" && (C = !h.keepH); A.length > 0 && !(A.length < 8 || !A[4].startsWith("M  V30 BEGIN CTAB") || !A[5].startsWith("M  V30 COUNTS") || A[5].length < 14); ) {
                var c = A[5].substring(13).match(/\S+/g);
                if (c.length < 2)
                  break;
                var S = parseInt(c[0]);
                if (isNaN(S) || S <= 0)
                  break;
                var y = parseInt(c[1]), b = 7;
                if (A.length < 8 + S + y)
                  break;
                var w = [], t = g[g.length - 1].length, r = t + S, u, o;
                for (u = t; u < r; u++, b++) {
                  o = A[b];
                  var l = o.substring(6).match(/\S+/g);
                  if (l.length > 4) {
                    var e = {}, n = l[1].replace(/ /g, "");
                    e.atom = e.elem = n[0].toUpperCase() + n.substring(1).toLowerCase(), (e.elem !== "H" || !C) && (e.serial = u, w[u] = g[g.length - 1].length, e.x = parseFloat(l[2]), e.y = parseFloat(l[3]), e.z = parseFloat(l[4]), e.hetflag = !0, e.bonds = [], e.bondOrder = [], e.properties = {}, e.index = g[g.length - 1].length, g[g.length - 1].push(e));
                  }
                }
                if (A[b] === "M  V30 END ATOM")
                  b++;
                else
                  break;
                if (y !== 0 && A[b] === "M  V30 BEGIN BOND")
                  b++;
                else
                  break;
                for (u = 0; u < y; u++, b++) {
                  o = A[b];
                  var a = o.substring(6).match(/\S+/g);
                  if (a.length > 3) {
                    var p = w[parseInt(a[2]) - 1 + t], x = w[parseInt(a[3]) - 1 + t], D = parseFloat(a[1]);
                    typeof p < "u" && typeof x < "u" && (g[g.length - 1][p].bonds.push(x), g[g.length - 1][p].bondOrder.push(D), g[g.length - 1][x].bonds.push(p), g[g.length - 1][x].bondOrder.push(D));
                  }
                }
                if (h.multimodel) {
                  for (h.onemol || g.push([]); A[b] !== "$$$$" && b < A.length; )
                    b++;
                  A.splice(0, ++b);
                } else
                  break;
              }
              return g;
            };
            function E(A, h) {
              var g = "V2000", C = A.split(/\r?\n|\r/);
              return C.length > 3 && C[3].length > 38 && (g = C[3].substring(34, 39)), g === "V2000" ? v(C, h) : g === "V3000" ? M(C, h) : [[""]];
            }
          }
        ),
        /***/
        "./src/parsers/VASP.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/VASP.ts ***!
            \*****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              VASP: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            );
            function M(E) {
              var A = [[]], h = {}, g = E.replace(/^\s+/, "").split(/\r?\n/);
              if (g.length < 3)
                return A;
              if (g[1].match(/\d+/))
                h.length = parseFloat(g[1]);
              else
                return console.log("Warning: second line of the vasp structure file must be a number"), A;
              if (h.length < 0)
                return console.log("Warning: Vasp implementation for negative lattice lengths is not yet available"), A;
              h.xVec = new Float32Array(g[2].replace(/^\s+/, "").split(/\s+/)), h.yVec = new Float32Array(g[3].replace(/^\s+/, "").split(/\s+/)), h.zVec = new Float32Array(g[4].replace(/^\s+/, "").split(/\s+/));
              var C = new v.Matrix3(h.xVec[0], h.xVec[1], h.xVec[2], h.yVec[0], h.yVec[1], h.yVec[2], h.zVec[0], h.zVec[1], h.zVec[2]);
              C.multiplyScalar(h.length), A.modelData = [{ symmetries: [], cryst: { matrix: C } }];
              var c = g[5].replace(/\s+/, "").replace(/\s+$/, "").split(/\s+/), S = new Int16Array(g[6].replace(/^\s+/, "").split(/\s+/)), y = g[7].replace(/\s+/, "");
              if (y.match(/C/))
                y = "cartesian";
              else if (y.match(/D/))
                y = "direct";
              else
                return console.log("Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)"), A;
              if (c.length != S.length)
                return console.log("Warning: declaration of atomary species wrong:"), console.log(c), console.log(S), A;
              g.splice(0, 8);
              for (var b = 0, w = 0, t = c.length; w < t; w++) {
                for (var r = c[w], u = 0, o = S[w]; u < o; u++) {
                  var l = new Float32Array(g[b + u].replace(/^\s+/, "").split(/\s+/)), e = {};
                  e.elem = r, y == "cartesian" ? (e.x = h.length * l[0], e.y = h.length * l[1], e.z = h.length * l[2]) : (e.x = h.length * (l[0] * h.xVec[0] + l[1] * h.yVec[0] + l[2] * h.zVec[0]), e.y = h.length * (l[0] * h.xVec[1] + l[1] * h.yVec[1] + l[2] * h.zVec[1]), e.z = h.length * (l[0] * h.xVec[2] + l[1] * h.yVec[2] + l[2] * h.zVec[2])), e.bonds = [], A[0].push(e);
                }
                b += S[w];
              }
              return A;
            }
          }
        ),
        /***/
        "./src/parsers/XYZ.ts": (
          /*!****************************!*\
            !*** ./src/parsers/XYZ.ts ***!
            \****************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              XYZ: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            var v = s(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function E(A, h) {
              h = h || {};
              for (var g = [[]], C = h.assignBonds === void 0 ? !0 : h.assignBonds, c = A.split(/\r?\n|\r/); c.length > 0 && !(c.length < 3); ) {
                var S = parseInt(c[0]);
                if (isNaN(S) || S <= 0 || c.length < S + 2)
                  break;
                var y = /Lattice\s*=\s*["\{\}]([^"\{\}]+)["\{\}]\s*/gi, b = y.exec(c[1]);
                if (b != null && b.length > 1) {
                  var w = new Float32Array(b[1].split(/\s+/)), t = new v.Matrix3(w[0], w[3], w[6], w[1], w[4], w[7], w[2], w[5], w[8]);
                  g.modelData = [{ cryst: { matrix: t } }];
                }
                for (var r = 2, u = g[g.length - 1].length, o = u + S, l = u; l < o; l++) {
                  var e = c[r++], n = e.replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), a = {};
                  a.serial = l;
                  var p = n[0];
                  a.atom = a.elem = p[0].toUpperCase() + p.substring(1, 2).toLowerCase(), a.x = parseFloat(n[1]), a.y = parseFloat(n[2]), a.z = parseFloat(n[3]), a.hetflag = !0, a.bonds = [], a.bondOrder = [], a.properties = {}, g[g.length - 1][l] = a, n.length >= 7 && (a.dx = parseFloat(n[4]), a.dy = parseFloat(n[5]), a.dz = parseFloat(n[6]));
                }
                if (h.multimodel)
                  g.push([]), c.splice(0, r);
                else
                  break;
              }
              if (C)
                for (let D = 0; D < g.length; D++)
                  (0, M.assignBonds)(g[D]);
              if (h.onemol) {
                var x = g;
                g = [], g.push(x[0]);
                for (let D = 1; D < x.length; D++) {
                  let O = g[0].length;
                  for (let R = 0; R < x[D].length; R++) {
                    let z = x[D][R];
                    for (let T = 0; T < z.bonds.length; T++)
                      z.bonds[T] = z.bonds[T] + O;
                    z.index = g[0].length, z.serial = g[0].length, g[0].push(z);
                  }
                }
              }
              return g;
            }
          }
        ),
        /***/
        "./src/parsers/index.ts": (
          /*!******************************!*\
            !*** ./src/parsers/index.ts ***!
            \******************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Parsers: () => (
                /* binding */
                u
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                r.bondLength
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                r.setBondLength
              )
              /* harmony export */
            });
            var v = s(
              /*! ./VASP */
              "./src/parsers/VASP.ts"
            ), M = s(
              /*! ./CUBE */
              "./src/parsers/CUBE.ts"
            ), E = s(
              /*! ./XYZ */
              "./src/parsers/XYZ.ts"
            ), A = s(
              /*! ./SDF */
              "./src/parsers/SDF.ts"
            ), h = s(
              /*! ./CDJSON */
              "./src/parsers/CDJSON.ts"
            ), g = s(
              /*! ./CIF */
              "./src/parsers/CIF.ts"
            ), C = s(
              /*! ./MOL2 */
              "./src/parsers/MOL2.ts"
            ), c = s(
              /*! ./PDB */
              "./src/parsers/PDB.ts"
            ), S = s(
              /*! ./PQR */
              "./src/parsers/PQR.ts"
            ), y = s(
              /*! ./MMTF */
              "./src/parsers/MMTF.ts"
            ), b = s(
              /*! ./PRMTOP */
              "./src/parsers/PRMTOP.ts"
            ), w = s(
              /*! ./GRO */
              "./src/parsers/GRO.ts"
            ), t = s(
              /*! ./LAMMPSTRJ */
              "./src/parsers/LAMMPSTRJ.ts"
            ), r = s(
              /*! ./utils/bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            const u = {
              vasp: v.VASP,
              VASP: v.VASP,
              cube: M.CUBE,
              CUBE: M.CUBE,
              xyz: E.XYZ,
              XYZ: E.XYZ,
              sdf: A.SDF,
              SDF: A.SDF,
              json: h.CDJSON,
              cdjson: h.CDJSON,
              CDJSON: h.CDJSON,
              mcif: g.CIF,
              cif: g.CIF,
              CIF: g.CIF,
              mol2: C.MOL2,
              MOL2: C.MOL2,
              pdb: c.PDB,
              PDB: c.PDB,
              pdbqt: c.PDB,
              PDBQT: c.PDB,
              pqr: S.PQR,
              PQR: S.PQR,
              mmtf: y.MMTFparser,
              MMTF: y.MMTFparser,
              prmtop: b.PRMTOP,
              PRMTOP: b.PRMTOP,
              gro: w.GRO,
              GRO: w.GRO,
              lammpstrj: t.LAMMPSTRJ,
              LAMMPSTRJ: t.LAMMPSTRJ
            };
          }
        ),
        /***/
        "./src/parsers/utils/anumToSymbol.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/anumToSymbol.ts ***!
            \*******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              anumToSymbol: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = {
              1: "H",
              2: "He",
              3: "Li",
              4: "Be",
              5: "B",
              6: "C",
              7: "N",
              8: "O",
              9: "F",
              10: "Ne",
              11: "Na",
              12: "Mg",
              13: "Al",
              14: "Si",
              15: "P",
              16: "S",
              17: "Cl",
              18: "Ar",
              19: "K",
              20: "Ca",
              21: "Sc",
              22: "Ti",
              23: "V",
              24: "Cr",
              25: "Mn",
              26: "Fe",
              27: "Co",
              28: "Ni",
              29: "Cu",
              30: "Zn",
              31: "Ga",
              32: "Ge",
              33: "As",
              34: "Se",
              35: "Br",
              36: "Kr",
              37: "Rb",
              38: "Sr",
              39: "Y",
              40: "Zr",
              41: "Nb",
              42: "Mo",
              43: "Tc",
              44: "Ru",
              45: "Rh",
              46: "Pd",
              47: "Ag",
              48: "Cd",
              49: "In",
              50: "Sn",
              51: "Sb",
              52: "Te",
              53: "I",
              54: "Xe",
              55: "Cs",
              56: "Ba",
              71: "Lu",
              72: "Hf",
              73: "Ta",
              74: "W",
              75: "Re",
              76: "Os",
              77: "Ir",
              78: "Pt",
              79: "Au",
              80: "Hg",
              81: "Tl",
              82: "Pb",
              83: "Bi",
              84: "Po",
              85: "At",
              86: "Rn",
              87: "Fr",
              88: "Ra",
              104: "Rf",
              105: "Db",
              106: "Sg",
              107: "Bh",
              108: "Hs",
              109: "Mt",
              110: "Ds",
              111: "Rg",
              112: "Cn",
              113: "Nh",
              114: "Fl",
              115: "Mc",
              116: "Lv",
              117: "Ts",
              118: "Og",
              57: "La",
              58: "Ce",
              59: "Pr",
              60: "Nd",
              61: "Pm",
              62: "Sm",
              63: "Eu",
              64: "Gd",
              65: "Tb",
              66: "Dy",
              67: "Ho",
              68: "Er",
              69: "Tm",
              70: "Yb",
              89: "Ac",
              90: "Th",
              91: "Pa",
              92: "U",
              93: "Np",
              94: "Pu",
              95: "Am",
              96: "Cm",
              97: "Bk",
              98: "Cf",
              99: "Es",
              100: "Fm",
              101: "Md",
              102: "No"
            };
          }
        ),
        /***/
        "./src/parsers/utils/areConnected.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/areConnected.ts ***!
            \*******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              areConnected: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            function M(E, A) {
              var h = (0, v.bondLength)(E.elem) + (0, v.bondLength)(A.elem);
              h += 0.25, h *= h;
              var g = E.x - A.x;
              if (g *= g, g > h)
                return !1;
              var C = E.y - A.y;
              if (C *= C, C > h)
                return !1;
              var c = E.z - A.z;
              if (c *= c, c > h)
                return !1;
              var S = g + C + c;
              return isNaN(S) || S < 0.5 || S > h ? !1 : !(E.altLoc != A.altLoc && E.altLoc != " " && A.altLoc != " ");
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBackboneHBonds.ts": (
          /*!***************************************************!*\
            !*** ./src/parsers/utils/assignBackboneHBonds.ts ***!
            \***************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              assignBackboneHBonds: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M, E) {
              let A = E || 3.2, h = A * A, g = [];
              for (let r = 0, u = M.length; r < u; r++) {
                M[r].index = r;
                var C = M[r];
                !C.hetflag && (C.atom === "N" || C.atom === "O") && (g.push(C), C.hbondOther = null, C.hbondDistanceSq = Number.POSITIVE_INFINITY);
              }
              g.sort(function(r, u) {
                return r.z - u.z;
              });
              for (let r = 0, u = g.length; r < u; r++) {
                var c = g[r];
                for (let o = r + 1; o < u; o++) {
                  var S = g[o], y = S.z - c.z;
                  if (y > A)
                    break;
                  if (S.atom != c.atom) {
                    var b = Math.abs(S.y - c.y);
                    if (!(b > A)) {
                      var w = Math.abs(S.x - c.x);
                      if (!(w > A)) {
                        var t = w * w + b * b + y * y;
                        t > h || S.chain == c.chain && Math.abs(S.resi - c.resi) < 4 || (t < c.hbondDistanceSq && (c.hbondOther = S, c.hbondDistanceSq = t), t < S.hbondDistanceSq && (S.hbondOther = c, S.hbondDistanceSq = t));
                      }
                    }
                  }
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBonds.ts": (
          /*!******************************************!*\
            !*** ./src/parsers/utils/assignBonds.ts ***!
            \******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              assignBonds: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            );
            function M(E) {
              for (var A = 0, h = E.length; A < h; A++)
                E[A].index || (E[A].index = A);
              for (var g = {}, C = 4.95, c = 0; c < E.length; c++) {
                var S = E[c], y = Math.floor(S.x / C), b = Math.floor(S.y / C), w = Math.floor(S.z / C);
                g[y] || (g[y] = {}), g[y][b] || (g[y][b] = {}), g[y][b][w] || (g[y][b][w] = []), g[y][b][w].push(S);
              }
              var t = function(u, o) {
                for (var l = 0; l < u.length; l++)
                  for (var e = u[l], n = 0; n < o.length; n++) {
                    var a = o[n];
                    if ((0, v.areConnected)(e, a)) {
                      var p = e.bonds.indexOf(a.index), x = a.bonds.indexOf(e.index);
                      p == -1 && x == -1 ? (e.bonds.push(a.index), e.bondOrder.push(1), a.bonds.push(e.index), a.bondOrder.push(1)) : p == -1 ? (e.bonds.push(a.index), e.bondOrder.push(a.bondOrder[x])) : x == -1 && (a.bonds.push(e.index), a.bondOrder.push(e.bondOrder[p]));
                    }
                  }
              }, r = [
                { x: 0, y: 0, z: 1 },
                { x: 0, y: 1, z: -1 },
                { x: 0, y: 1, z: 0 },
                { x: 0, y: 1, z: 1 },
                { x: 1, y: -1, z: -1 },
                { x: 1, y: -1, z: 0 },
                { x: 1, y: -1, z: 1 },
                { x: 1, y: 0, z: -1 },
                { x: 1, y: 0, z: 0 },
                { x: 1, y: 0, z: 1 },
                { x: 1, y: 1, z: -1 },
                { x: 1, y: 1, z: 0 },
                { x: 1, y: 1, z: 1 }
              ];
              for (let u in g) {
                let o = parseInt(u);
                for (let l in g[o]) {
                  let e = parseInt(l);
                  for (let n in g[o][e]) {
                    let a = parseInt(n), p = g[o][e][a];
                    for (let x = 0; x < p.length; x++) {
                      let D = p[x];
                      for (let O = x + 1; O < p.length; O++) {
                        let R = p[O];
                        (0, v.areConnected)(D, R) && D.bonds.indexOf(R.index) == -1 && (D.bonds.push(R.index), D.bondOrder.push(1), R.bonds.push(D.index), R.bondOrder.push(1));
                      }
                    }
                    for (let x = 0; x < r.length; x++) {
                      let D = r[x];
                      if (!g[o + D.x] || !g[o + D.x][e + D.y] || !g[o + D.x][e + D.y][a + D.z])
                        continue;
                      let O = g[o + D.x][e + D.y][a + D.z];
                      t(p, O);
                    }
                  }
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignPDBBonds.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/assignPDBBonds.ts ***!
            \*********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              assignPDBBonds: () => (
                /* binding */
                A
              )
              /* harmony export */
            });
            var v = s(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            ), M = s(
              /*! ./assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), E = s(
              /*! ./standardResidues */
              "./src/parsers/utils/standardResidues.ts"
            );
            function A(h) {
              var g = [], C = [], c, S;
              for (c = 0, S = h.length; c < S; c++) {
                var y = h[c];
                y.index = c, y.hetflag || !E.standardResidues.has(y.resn) ? C.push(y) : g.push(y);
              }
              (0, M.assignBonds)(C), g.sort(function(l, e) {
                return l.chain != e.chain ? l.chain < e.chain ? -1 : 1 : l.resi - e.resi;
              });
              var b = -1, w = -1, t;
              for (c = 0, S = g.length; c < S; c++) {
                var r = g[c];
                r.resi !== b && (b = r.resi, t || w++, t = !1), r.reschain = w;
                for (var u = c + 1; u < g.length; u++) {
                  var o = g[u];
                  if (o.chain != r.chain || o.resi - r.resi > 1)
                    break;
                  (0, v.areConnected)(r, o) && (r.bonds.indexOf(o.index) === -1 && (r.bonds.push(o.index), r.bondOrder.push(1), o.bonds.push(r.index), o.bondOrder.push(1)), r.resi !== o.resi && (t = !0));
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/atomNameToElem.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/atomNameToElem.ts ***!
            \*********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              atomNameToElem: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            function M(E, A) {
              var h = E.replace(/ /g, "");
              return h.length > 0 && h[0] == "H" && h != "Hg" && h != "He" && h != "Hf" && h != "Hs" && h != "Ho" && (h = "H"), h.length > 1 && (h = h[0].toUpperCase() + h.substring(1).toLowerCase(), typeof v.bondTable[h] > "u" ? h = h[0] : A && (h == "Ca" || h == "Cd") && (h = "C")), h;
            }
          }
        ),
        /***/
        "./src/parsers/utils/bondLength.ts": (
          /*!*****************************************!*\
            !*** ./src/parsers/utils/bondLength.ts ***!
            \*****************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              bondLength: () => (
                /* binding */
                M
              ),
              /* harmony export */
              bondTable: () => (
                /* binding */
                v
              ),
              /* harmony export */
              setBondLength: () => (
                /* binding */
                E
              )
              /* harmony export */
            });
            let v = {
              H: 0.37,
              He: 0.32,
              Li: 1.34,
              Be: 0.9,
              B: 0.82,
              C: 0.77,
              N: 0.75,
              O: 0.73,
              F: 0.71,
              Ne: 0.69,
              Na: 1.54,
              Mg: 1.3,
              Al: 1.18,
              Si: 1.11,
              P: 1.06,
              S: 1.02,
              Cl: 0.99,
              Ar: 0.97,
              K: 1.96,
              Ca: 1.74,
              Sc: 1.44,
              Ti: 1.56,
              V: 1.25,
              /* Cr */
              Mn: 1.39,
              Fe: 1.25,
              Co: 1.26,
              Ni: 1.21,
              Cu: 1.38,
              Zn: 1.31,
              Ga: 1.26,
              Ge: 1.22,
              /* As */
              Se: 1.16,
              Br: 1.14,
              Kr: 1.1,
              Rb: 2.11,
              Sr: 1.92,
              Y: 1.62,
              Zr: 1.48,
              Nb: 1.37,
              Mo: 1.45,
              Tc: 1.56,
              Ru: 1.26,
              Rh: 1.35,
              Pd: 1.31,
              Ag: 1.53,
              Cd: 1.48,
              In: 1.44,
              Sn: 1.41,
              Sb: 1.38,
              Te: 1.35,
              I: 1.33,
              Xe: 1.3,
              Cs: 2.25,
              Ba: 1.98,
              Lu: 1.6,
              Hf: 1.5,
              Ta: 1.38,
              W: 1.46,
              Re: 1.59,
              Os: 1.44,
              Ir: 1.37,
              Pt: 1.28,
              Au: 1.44,
              Hg: 1.49,
              Tl: 1.48,
              Pb: 1.47,
              Bi: 1.46,
              /* Po */
              /* At */
              Rn: 1.45
              // None of the bottom row or any of the Lanthanides have bond lengths
            };
            function M(A) {
              return v[A] || 1.6;
            }
            function E(A, h) {
              h < 0 && (h = 0), v[A] = h;
            }
          }
        ),
        /***/
        "./src/parsers/utils/computeSecondaryStructure.ts": (
          /*!********************************************************!*\
            !*** ./src/parsers/utils/computeSecondaryStructure.ts ***!
            \********************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              computeSecondaryStructure: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ./assignBackboneHBonds */
              "./src/parsers/utils/assignBackboneHBonds.ts"
            );
            function M(E, A) {
              (0, v.assignBackboneHBonds)(E, A);
              var h = {}, g, C, c, S, y, b;
              for (g = 0, C = E.length; g < C; g++)
                if (y = E[g], typeof h[y.chain] > "u" && (h[y.chain] = []), isFinite(y.hbondDistanceSq)) {
                  var w = y.hbondOther;
                  typeof h[w.chain] > "u" && (h[w.chain] = []), Math.abs(w.resi - y.resi) === 4 && (h[y.chain][y.resi] = "h");
                }
              for (c in h)
                for (S = 1; S < h[c].length - 1; S++) {
                  var t = h[c][S - 1], r = h[c][S + 1];
                  b = h[c][S], t == "h" && t == r && b != t && (h[c][S] = t);
                }
              for (g = 0, C = E.length; g < C; g++)
                y = E[g], isFinite(y.hbondDistanceSq) && h[y.chain][y.resi] != "h" && y.ss != "h" && (h[y.chain][y.resi] = "maybesheet");
              for (let u = 0, o = E.length; u < o; u++)
                if (y = E[u], isFinite(y.hbondDistanceSq) && h[y.chain][y.resi] == "maybesheet") {
                  let l = y.hbondOther, e = h[l.chain][l.resi];
                  (e == "maybesheet" || e == "s") && (h[y.chain][y.resi] = "s", h[l.chain][l.resi] = "s");
                }
              for (let u in h) {
                for (let o = 1; o < h[u].length - 1; o++) {
                  let l = h[u][o - 1], e = h[u][o + 1];
                  b = h[u][o], l == "s" && l == e && b != l && (h[u][o] = l);
                }
                for (let o = 0; o < h[u].length; o++) {
                  let l = h[u][o];
                  (l == "h" || l == "s") && h[u][o - 1] != l && h[u][o + 1] != l && delete h[u][o];
                }
              }
              for (g = 0, C = E.length; g < C; g++)
                y = E[g], b = h[y.chain][y.resi], delete y.hbondOther, delete y.hbondDistanceSq, !(typeof b > "u" || b == "maybesheet") && (y.ss = b, h[y.chain][y.resi - 1] != b && (y.ssbegin = !0), h[y.chain][y.resi + 1] != b && (y.ssend = !0));
            }
          }
        ),
        /***/
        "./src/parsers/utils/getSinglePDB.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/getSinglePDB.ts ***!
            \*******************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              getSinglePDB: () => (
                /* binding */
                S
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            ), M = s(
              /*! ./atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            ), E = s(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            ), A = s(
              /*! ./computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), h = s(
              /*! ./isEmpty */
              "./src/parsers/utils/isEmpty.ts"
            ), g = s(
              /*! ./processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), C = s(
              /*! ./assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), c = s(
              /*! ./validateBonds */
              "./src/parsers/utils/validateBonds.ts"
            );
            function S(y, b, w) {
              var t = [], r = b.assignBonds === void 0 ? !0 : b.assignBonds, u = !b.keepH, o = !!b.noSecondaryStructure, l = !b.noComputeSecondaryStructure, e = !b.doAssembly, n = b.altLoc ? b.altLoc : "A", a = { symmetries: [] }, p, x = [], D = [], O, R = {};
              for (let ke = 0; ke < y.length; ke++) {
                O = y[ke].replace(/^\s*/, "");
                var z = O.substring(0, 6), T, B, W;
                if (z.indexOf("END") == 0) {
                  if (x = y.slice(ke + 1), z == "END")
                    for (var k in w)
                      w.hasOwnProperty(k) && delete w[k];
                  break;
                } else if (z == "ATOM  " || z == "HETATM") {
                  var F, U, V, H, G, Y, J, re, le, ie, xe, se;
                  if (xe = O.substring(16, 17), xe != " " && xe != n && n != "*" || (ie = parseInt(O.substring(6, 11)), p = O.substring(12, 16).replace(/ /g, ""), F = O.substring(17, 20).replace(/ /g, ""), U = O.substring(21, 22), V = parseInt(O.substring(22, 26)), H = O.substring(26, 27), G = parseFloat(O.substring(30, 38)), Y = parseFloat(O.substring(38, 46)), J = parseFloat(O.substring(46, 54)), se = parseFloat(O.substring(60, 68)), le = O.substring(76, 78).replace(/ /g, ""), le === "" || typeof E.bondTable[le] > "u" ? le = (0, M.atomNameToElem)(O.substring(12, 14), O[0] == "A") : le = le[0].toUpperCase() + le.substring(1).toLowerCase(), le == "H" && u))
                    continue;
                  z[0] == "H" ? re = !0 : re = !1, D[ie] = t.length, t.push({
                    resn: F,
                    x: G,
                    y: Y,
                    z: J,
                    elem: le,
                    hetflag: re,
                    altLoc: xe,
                    chain: U,
                    resi: V,
                    icode: H,
                    rescode: V + (H != " " ? "^" + H : ""),
                    // resi
                    // and
                    // icode
                    serial: ie,
                    atom: p,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {},
                    b: se,
                    pdbline: O
                  });
                } else if (z == "SHEET ") {
                  T = O.substring(21, 22), B = parseInt(O.substring(22, 26)), W = parseInt(O.substring(33, 37)), T in w || (w[T] = {}), w[T][B] = "s1";
                  for (var ce = B + 1; ce < W; ce++)
                    w[T][ce] = "s";
                  w[T][W] = "s2";
                } else if (z == "CONECT") {
                  var Ee = parseInt(O.substring(6, 11)), be = D[Ee], Le = t[be], ae = [11, 16, 21, 26];
                  for (let Ne = 0; Ne < 4; Ne++) {
                    var pe = parseInt(O.substring(ae[Ne], ae[Ne] + 5)), we = D[pe];
                    let X = be + ":" + we;
                    var Ge = t[we];
                    if (Le !== void 0 && Ge !== void 0)
                      if (!R[X])
                        R[X] = 1, (Le.bonds.length == 0 || Le.bonds[Le.bonds.length - 1] != we) && (Le.bonds.push(we), Le.bondOrder.push(1));
                      else {
                        R[X] += 1;
                        for (let K = 0; K < Le.bonds.length; K++)
                          if (Le.bonds[K] == we) {
                            var We = R[X];
                            We >= 4 ? Le.bondOrder[K] = 1 : Le.bondOrder[K] = We;
                          }
                      }
                  }
                } else if (z == "HELIX ") {
                  T = O.substring(19, 20), B = parseInt(O.substring(21, 25)), W = parseInt(O.substring(33, 37)), T in w || (w[T] = {}), w[T][B] = "h1";
                  for (let Ne = B + 1; Ne < W; Ne++)
                    w[T][Ne] = "h";
                  w[T][W] = "h2";
                } else if (!e && z == "REMARK" && O.substring(13, 18) == "BIOMT") {
                  var je, Fe = new v.Matrix4();
                  for (je = 1; je <= 3; je++)
                    if (O = y[ke].replace(/^\s*/, ""), parseInt(O.substring(18, 19)) == je)
                      Fe.elements[je - 1] = parseFloat(O.substring(23, 33)), Fe.elements[je - 1 + 4] = parseFloat(O.substring(33, 43)), Fe.elements[je - 1 + 8] = parseFloat(O.substring(43, 53)), Fe.elements[je - 1 + 12] = parseFloat(O.substring(53)), ke++;
                    else
                      for (; O.substring(13, 18) == "BIOMT"; )
                        ke++, O = y[ke].replace(/^\s*/, "");
                  Fe.elements[3] = 0, Fe.elements[7] = 0, Fe.elements[11] = 0, Fe.elements[15] = 1, a.symmetries.push(Fe), ke--;
                } else if (z == "CRYST1") {
                  let Ne, X, K, q, fe, ue;
                  Ne = parseFloat(O.substring(7, 15)), X = parseFloat(O.substring(16, 24)), K = parseFloat(O.substring(25, 33)), q = parseFloat(O.substring(34, 40)), fe = parseFloat(O.substring(41, 47)), ue = parseFloat(O.substring(48, 54)), a.cryst = {
                    a: Ne,
                    b: X,
                    c: K,
                    alpha: q,
                    beta: fe,
                    gamma: ue
                  };
                } else if (z == "ANISOU") {
                  let Ne = parseInt(O.substring(6, 11));
                  var ze = D[Ne], Be = t[ze];
                  if (Be) {
                    var Ie = O.substring(30).trim().split(/\s+/), Te = {
                      u11: parseInt(Ie[0]),
                      u22: parseInt(Ie[1]),
                      u33: parseInt(Ie[2]),
                      u12: parseInt(Ie[3]),
                      u13: parseInt(Ie[4]),
                      u23: parseInt(Ie[5])
                    };
                    Be.uMat = Te;
                  }
                }
              }
              if ((0, c.validateBonds)(t, D), r && (0, C.assignPDBBonds)(t), e || (0, g.processSymmetries)(a.symmetries, t, b, a.cryst), l && !o && (0, A.computeSecondaryStructure)(t, b.hbondCutoff), !(0, h.isEmpty)(w)) {
                for (let ke = 0; ke < t.length; ke++)
                  if (p = t[ke], p !== void 0 && p.chain in w && p.resi in w[p.chain]) {
                    var Re = w[p.chain][p.resi];
                    p.ss = Re[0], Re.length > 1 && (Re[1] == "1" ? p.ssbegin = !0 : Re[1] == "2" && (p.ssend = !0));
                  }
              }
              return [t, a, x];
            }
          }
        ),
        /***/
        "./src/parsers/utils/isEmpty.ts": (
          /*!**************************************!*\
            !*** ./src/parsers/utils/isEmpty.ts ***!
            \**************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              isEmpty: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M) {
              var E;
              for (E in M)
                return !1;
              return !0;
            }
          }
        ),
        /***/
        "./src/parsers/utils/processSymmetries.ts": (
          /*!************************************************!*\
            !*** ./src/parsers/utils/processSymmetries.ts ***!
            \************************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              processSymmetries: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var v = s(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            );
            function M(E, A, h, g) {
              var C = !h.duplicateAssemblyAtoms, c = A.length, S = c, y, b, w;
              let t = -1;
              if (h.normalizeAssembly && g) {
                let n = (0, v.conversionMatrix3)(g.a, g.b, g.c, g.alpha, g.beta, g.gamma), a = new v.Matrix3();
                for (a.getInverse3(n), y = 0; y < E.length; y++) {
                  let p = new v.Vector3(0, 0, 0);
                  for (w = 0; w < c; w++) {
                    let R = new v.Vector3(A[w].x, A[w].y, A[w].z);
                    R.applyMatrix4(E[y]), R.applyMatrix3(a), p.add(R);
                  }
                  p.divideScalar(c);
                  const x = [p.x, p.y, p.z];
                  let D = [0, 0, 0];
                  for (let R = 0; R < 3; R++) {
                    for (; x[R] < -1e-3; )
                      x[R] += 1, D[R] += 1;
                    for (; x[R] > 1.001; )
                      x[R] -= 1, D[R] -= 1;
                  }
                  const O = new v.Vector3(D[0], D[1], D[2]);
                  O.applyMatrix3(n), E[y].isNearlyIdentity() && O.lengthSq() > 1e-3 && (t = y), E[y].translate(O);
                }
              }
              if (C) {
                if (E.length > 1)
                  for (y = 0; y < A.length; y++) {
                    var l = [];
                    for (b = 0; b < E.length; b++)
                      if (!E[b].isNearlyIdentity()) {
                        var e = new v.Vector3();
                        e.set(A[y].x, A[y].y, A[y].z), e.applyMatrix4(E[b]), l.push(e);
                      }
                    A[y].symmetries = l;
                  }
              } else {
                for (w = 0; w < c; w++)
                  A[w].sym = -1;
                for (y = 0; y < E.length; y++)
                  if (!E[y].isNearlyIdentity() && t != y) {
                    let n = new v.Vector3();
                    for (w = 0; w < c; w++) {
                      var r = [];
                      for (b = 0; b < A[w].bonds.length; b++)
                        r.push(A[w].bonds[b] + S);
                      n.set(A[w].x, A[w].y, A[w].z), n.applyMatrix4(E[y]);
                      var u = {};
                      for (var o in A[w])
                        u[o] = A[w][o];
                      u.x = n.x, u.y = n.y, u.z = n.z, u.bonds = r, u.sym = y, u.index = A.length, A.push(u);
                    }
                    S = A.length;
                  } else
                    for (w = 0; w < c; w++)
                      A[w].sym = y;
                if (t >= 0) {
                  let n = new v.Vector3();
                  for (w = 0; w < c; w++)
                    n.set(A[w].x, A[w].y, A[w].z), n.applyMatrix4(E[t]), A[w].x = n.x, A[w].y = n.y, A[w].z = n.z;
                }
                E.length = 0;
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/standardResidues.ts": (
          /*!***********************************************!*\
            !*** ./src/parsers/utils/standardResidues.ts ***!
            \***********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              standardResidues: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = /* @__PURE__ */ new Set([
              "ABU",
              "ACD",
              "ALA",
              "ALB",
              "ALI",
              "ARG",
              "AR0",
              "ASN",
              "ASP",
              "ASX",
              "BAS",
              "CYS",
              "CYH",
              "CYX",
              "CSS",
              "CSH",
              "GLN",
              "GLU",
              "GLX",
              "GLY",
              "HIS",
              "HIE",
              "HID",
              "HIP",
              "HYP",
              "ILE",
              "ILU",
              "LEU",
              "LYS",
              "MET",
              "PCA",
              "PGA",
              "PHE",
              "PR0",
              "PRO",
              "PRZ",
              "SER",
              "THR",
              "TRP",
              "TYR",
              "VAL",
              "A",
              "1MA",
              "C",
              "5MC",
              "OMC",
              "G",
              "1MG",
              "2MG",
              "M2G",
              "7MG",
              "OMG",
              "YG",
              "I",
              "T",
              "U",
              "+U",
              "H2U",
              "5MU",
              "PSU",
              "ACE",
              "F0R",
              "H2O",
              "HOH",
              "WAT"
            ]);
          }
        ),
        /***/
        "./src/parsers/utils/validateBonds.ts": (
          /*!********************************************!*\
            !*** ./src/parsers/utils/validateBonds.ts ***!
            \********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              validateBonds: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            function v(M, E) {
              for (var A = 0, h = M.length; A < h; A++)
                for (var g = M[A], C = 0; C < g.bonds.length; C++) {
                  var c = g.bonds[C], S = M[c], y = E[g.serial];
                  if (S && y) {
                    var b = S.bonds.indexOf(y);
                    b < 0 && (S.bonds.push(y), S.bondOrder.push(g.bondOrder[C]));
                  }
                }
            }
          }
        ),
        /***/
        "./src/partialCharges.ts": (
          /*!*******************************!*\
            !*** ./src/partialCharges.ts ***!
            \*******************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              applyPartialCharges: () => (
                /* binding */
                M
              ),
              /* harmony export */
              partialCharges: () => (
                /* binding */
                v
              )
              /* harmony export */
            });
            const v = {
              "ALA:N": -0.15,
              "ALA:CA": 0.1,
              "ALA:CB": 0,
              "ALA:C": 0.6,
              "ALA:O": -0.55,
              "ARG:N": -0.15,
              "ARG:CA": 0.1,
              "ARG:CB": 0,
              "ARG:CG": 0,
              "ARG:CD": 0.1,
              "ARG:NE": -0.1,
              "ARG:CZ": 0.5,
              "ARG:NH1": 0.25,
              "ARG:NH2": 0.25,
              "ARG:C": 0.6,
              "ARG:O": -0.55,
              "ASN:N": -0.15,
              "ASN:CA": 0.1,
              "ASN:CB": 0,
              "ASN:CG": 0.55,
              "ASN:OD1": -0.55,
              "ASN:ND2": 0,
              "ASN:C": 0.6,
              "ASN:O": -0.55,
              "ASP:N": -0.15,
              "ASP:CA": 0.1,
              "ASP:CB": 0,
              "ASP:CG": 0.14,
              "ASP:OD1": -0.57,
              "ASP:OD2": -0.57,
              "ASP:C": 0.6,
              "ASP:O": -0.55,
              "CYS:N": -0.15,
              "CYS:CA": 0.1,
              "CYS:CB": 0.19,
              "CYS:SG": -0.19,
              "CYS:C": 0.6,
              "CYS:O": -0.55,
              "GLN:N": -0.15,
              "GLN:CA": 0.1,
              "GLN:CB": 0,
              "GLN:CG": 0,
              "GLN:CD": 0.55,
              "GLN:OE1": -0.55,
              "GLN:NE2": 0,
              "GLN:C": 0.6,
              "GLN:O": -0.55,
              "GLU:N": -0.15,
              "GLU:CA": 0.1,
              "GLU:CB": 0,
              "GLU:CG": 0,
              "GLU:CD": 0.14,
              "GLU:OE1": -0.57,
              "GLU:OE2": -0.57,
              "GLU:C": 0.6,
              "GLU:O": -0.55,
              "GLY:N": -0.15,
              "GLY:CA": 0.1,
              "GLY:C": 0.6,
              "GLY:O": -0.55,
              "HIS:N": -0.15,
              "HIS:CA": 0.1,
              "HIS:CB": 0,
              "HIS:CG": 0.1,
              "HIS:ND1": -0.1,
              "HIS:CD2": 0.1,
              "HIS:NE2": -0.4,
              "HIS:CE1": 0.3,
              "HIS:C": 0.6,
              "HIS:O": -0.55,
              "ILE:N": -0.15,
              "ILE:CA": 0.1,
              "ILE:CB": 0,
              "ILE:CG2": 0,
              "ILE:CG1": 0,
              "ILE:CD": 0,
              "ILE:C": 0.6,
              "ILE:O": -0.55,
              "LEU:N": -0.15,
              "LEU:CA": 0.1,
              "LEU:CB": 0,
              "LEU:CG": 0,
              "LEU:CD1": 0,
              "LEU:CD2": 0,
              "LEU:C": 0.6,
              "LEU:O": -0.55,
              "LYS:N": -0.15,
              "LYS:CA": 0.1,
              "LYS:CB": 0,
              "LYS:CG": 0,
              "LYS:CD": 0,
              "LYS:CE": 0.25,
              "LYS:NZ": 0.75,
              "LYS:C": 0.6,
              "LYS:O": -0.55,
              "MET:N": -0.15,
              "MET:CA": 0.1,
              "MET:CB": 0,
              "MET:CG": 0.06,
              "MET:SD": -0.12,
              "MET:CE": 0.06,
              "MET:C": 0.6,
              "MET:O": -0.55,
              "PHE:N": -0.15,
              "PHE:CA": 0.1,
              "PHE:CB": 0,
              "PHE:CG": 0,
              "PHE:CD1": 0,
              "PHE:CD2": 0,
              "PHE:CE1": 0,
              "PHE:CE2": 0,
              "PHE:CZ": 0,
              "PHE:C": 0.6,
              "PHE:O": -0.55,
              "PRO:N": -0.25,
              "PRO:CD": 0.1,
              "PRO:CA": 0.1,
              "PRO:CB": 0,
              "PRO:CG": 0,
              "PRO:C": 0.6,
              "PRO:O": -0.55,
              "SER:N": -0.15,
              "SER:CA": 0.1,
              "SER:CB": 0.25,
              "SER:OG": -0.25,
              "SER:C": 0.6,
              "SER:O": -0.55,
              "THR:N": -0.15,
              "THR:CA": 0.1,
              "THR:CB": 0.25,
              "THR:OG1": -0.25,
              "THR:CG2": 0,
              "THR:C": 0.6,
              "THR:O": -0.55,
              "TRP:N": -0.15,
              "TRP:CA": 0.1,
              "TRP:CB": 0,
              "TRP:CG": -0.03,
              "TRP:CD2": 0.1,
              "TRP:CE2": -0.04,
              "TRP:CE3": -0.03,
              "TRP:CD1": 0.06,
              "TRP:NE1": -0.06,
              "TRP:CZ2": 0,
              "TRP:CZ3": 0,
              "TRP:CH2": 0,
              "TRP:C": 0.6,
              "TRP:O": -0.55,
              "TYR:N": -0.15,
              "TYR:CA": 0.1,
              "TYR:CB": 0,
              "TYR:CG": 0,
              "TYR:CD1": 0,
              "TYR:CE1": 0,
              "TYR:CD2": 0,
              "TYR:CE2": 0,
              "TYR:CZ": 0.25,
              "TYR:OH": -0.25,
              "TYR:C": 0.6,
              "TYR:O": -0.55,
              "VAL:N": -0.15,
              "VAL:CA": 0.1,
              "VAL:CB": 0,
              "VAL:CG1": 0,
              "VAL:CG2": 0,
              "VAL:C": 0.6,
              "VAL:O": -0.55
            };
            function M(E, A) {
              if ((!A || typeof E.partialCharge > "u") && E.resn && E.atom) {
                var h = E.resn + ":" + E.atom;
                E.properties.partialCharge = v[h];
              }
            }
          }
        ),
        /***/
        "./src/specs.ts": (
          /*!**********************!*\
            !*** ./src/specs.ts ***!
            \**********************/
          /***/
          (P, _, s) => {
            s.r(_);
          }
        ),
        /***/
        "./src/utilities.ts": (
          /*!**************************!*\
            !*** ./src/utilities.ts ***!
            \**************************/
          /***/
          (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              PausableTimer: () => (
                /* binding */
                PausableTimer
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* binding */
                adjustVolumeStyle
              ),
              /* harmony export */
              base64ToArray: () => (
                /* binding */
                base64ToArray
              ),
              /* harmony export */
              deepCopy: () => (
                /* binding */
                deepCopy
              ),
              /* harmony export */
              download: () => (
                /* binding */
                download
              ),
              /* harmony export */
              extend: () => (
                /* binding */
                extend
              ),
              /* harmony export */
              get: () => (
                /* binding */
                get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* binding */
                getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* binding */
                getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* binding */
                getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* binding */
                getExtent
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* binding */
                getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* binding */
                getbin
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* binding */
                isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* binding */
                isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* binding */
                makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* binding */
                mergeGeos
              ),
              /* harmony export */
              specStringToObject: () => (
                /* binding */
                specStringToObject
              )
              /* harmony export */
            });
            var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), _VolumeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
              /*! ./colors */
              "./src/colors.ts"
            );
            function extend(P, _) {
              for (var s in _)
                _.hasOwnProperty(s) && _[s] !== void 0 && (P[s] = _[s]);
              return P;
            }
            function deepCopy(P) {
              let _, s, v;
              if (P == null)
                return {};
              if (typeof P != "object" || P === null)
                return P;
              _ = Array.isArray(P) ? [] : {};
              for (v in P)
                s = P[v], _[v] = deepCopy(s);
              return _;
            }
            function isNumeric(P) {
              var _ = typeof P;
              return (_ === "number" || _ === "string") && !isNaN(P - parseFloat(P));
            }
            function isEmptyObject(P) {
              var _;
              for (_ in P)
                return !1;
              return !0;
            }
            function makeFunction(callback) {
              return callback && typeof callback == "string" && (callback = eval("(" + callback + ")")), callback && typeof callback != "function" ? null : callback;
            }
            function adjustVolumeStyle(P) {
              P && (P.volformat && !(P.voldata instanceof _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData) && (P.voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData(P.voldata, P.volformat)), P.volscheme && (P.volscheme = _Gradient__WEBPACK_IMPORTED_MODULE_0__.Gradient.getGradient(P.volscheme)));
            }
            function getExtent(P, _) {
              var s, v, M, E, A, h, g, C, c, S, y = !_;
              if (s = v = M = 9999, E = A = h = -9999, g = C = c = S = 0, P.length === 0)
                return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
              for (var b = 0; b < P.length; b++) {
                var w = P[b];
                if (!(typeof w > "u" || !isFinite(w.x) || !isFinite(w.y) || !isFinite(w.z)) && (S++, g += w.x, C += w.y, c += w.z, s = s < w.x ? s : w.x, v = v < w.y ? v : w.y, M = M < w.z ? M : w.z, E = E > w.x ? E : w.x, A = A > w.y ? A : w.y, h = h > w.z ? h : w.z, w.symmetries && y))
                  for (var t = 0; t < w.symmetries.length; t++)
                    S++, g += w.symmetries[t].x, C += w.symmetries[t].y, c += w.symmetries[t].z, s = s < w.symmetries[t].x ? s : w.symmetries[t].x, v = v < w.symmetries[t].y ? v : w.symmetries[t].y, M = M < w.symmetries[t].z ? M : w.symmetries[t].z, E = E > w.symmetries[t].x ? E : w.symmetries[t].x, A = A > w.symmetries[t].y ? A : w.symmetries[t].y, h = h > w.symmetries[t].z ? h : w.symmetries[t].z;
              }
              return [
                [s, v, M],
                [E, A, h],
                [g / S, C / S, c / S]
              ];
            }
            function getPropertyRange(P, _) {
              for (var s = Number.POSITIVE_INFINITY, v = Number.NEGATIVE_INFINITY, M = 0, E = P.length; M < E; M++) {
                var A = P[M], h = getAtomProperty(A, _);
                h != null && (h < s && (s = h), h > v && (v = h));
              }
              return !isFinite(s) && !isFinite(v) ? s = v = 0 : isFinite(s) ? isFinite(v) || (v = s) : s = v, [s, v];
            }
            class PausableTimer {
              constructor(_, s, v) {
                this.total_time_run = 0, this.fn = _, this.arg = v, this.countdown = s, this.start_time = (/* @__PURE__ */ new Date()).getTime(), this.ident = setTimeout(_, s, v);
              }
              cancel() {
                clearTimeout(this.ident);
              }
              pause() {
                clearTimeout(this.ident), this.total_time_run = (/* @__PURE__ */ new Date()).getTime() - this.start_time;
              }
              resume() {
                this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);
              }
            }
            function base64ToArray(P) {
              for (var _ = window.atob(P), s = _.length, v = new Uint8Array(s), M = 0; M < s; M++)
                v[M] = _.charCodeAt(M);
              return v;
            }
            function getAtomProperty(P, _) {
              var s = null;
              return P.properties && typeof P.properties[_] < "u" ? s = P.properties[_] : typeof P[_] < "u" && (s = P[_]), s;
            }
            function mergeGeos(P, _) {
              var s = _.geometry;
              s !== void 0 && P.geometryGroups.push(s.geometryGroups[0]);
            }
            function specStringToObject(P) {
              if (typeof P == "object")
                return P;
              if (typeof P > "u" || P == null)
                return P;
              try {
                return JSON.parse(P);
              } catch {
              }
              P = P.replace(/%7E/g, "~");
              var _ = function(y) {
                return isNumeric(y) ? Math.floor(parseFloat(y)) == parseInt(y) || y.indexOf(".") >= 0 ? parseFloat(y) : parseInt(y) : y === "true" ? !0 : y === "false" ? !1 : y;
              }, s = {};
              if (P === "all")
                return s;
              for (var v = P.split(";"), M = 0; M < v.length; M++) {
                var E = v[M].split(":"), A = E[0], h = {}, g = E[1];
                if (g)
                  if (g = g.replace(/~/g, "="), g.indexOf("=") !== -1)
                    for (var C = g.split(","), c = 0; c < C.length; c++) {
                      var S = C[c].split("=", 2);
                      h[S[0]] = _(S[1]);
                    }
                  else
                    g.indexOf(",") !== -1 ? h = g.split(",") : h = _(g);
                s[A] = h;
              }
              return s;
            }
            function checkStatus(P) {
              if (!P.ok)
                throw new Error(`HTTP ${P.status} - ${P.statusText}`);
              return P;
            }
            function get(P, _) {
              var s = fetch(P).then(checkStatus).then((v) => v.text());
              return _ ? s.then(_) : s;
            }
            function getbin(P, _, s, v) {
              var M;
              return s == "POST" ? M = fetch(P, { method: "POST", body: v }).then((E) => checkStatus(E)).then((E) => E.arrayBuffer()) : M = fetch(P).then((E) => checkStatus(E)).then((E) => E.arrayBuffer()), _ ? M.then(_) : M;
            }
            function download(P, _, s, v) {
              var M = "", E = "", A = "", h = "", g = null, C = _.addModel();
              if (P.indexOf(":") < 0 && (P.length == 4 ? P = "pdb:" + P : isNaN(P) ? P = "url:" + P : P = "cid:" + P), P.substring(0, 5) === "mmtf:")
                E = s && s.pdbUri ? s.pdbUri : "https://mmtf.rcsb.org/v1.0/full/", P = P.substring(5).toUpperCase(), h = E + P, s && typeof s.noComputeSecondaryStructure > "u" && (s.noComputeSecondaryStructure = !0), g = new Promise(function(S) {
                  getbin(h).then(function(y) {
                    C.addMolData(y, "mmtf", s), _.zoomTo(), _.render(), S(C);
                  }, function() {
                    console.log("fetch of " + h + " failed.");
                  });
                });
              else {
                if (P.substring(0, 4) === "pdb:") {
                  if (M = "mmtf", s && s.format && (M = s.format), s && typeof s.noComputeSecondaryStructure > "u" && (s.noComputeSecondaryStructure = !0), P = P.substring(4).toUpperCase(), !P.match(/^[1-9][A-Za-z0-9]{3}$/)) {
                    alert("Wrong PDB ID");
                    return;
                  }
                  M == "mmtf" ? (A = s && s.mmtfUri ? s.mmtfUri : "https://mmtf.rcsb.org/v1.0/full/", h = A + P.toUpperCase()) : (E = s && s.pdbUri ? s.pdbUri : "https://files.rcsb.org/view/", h = E + P + "." + M);
                } else if (P.substring(0, 4) == "cid:") {
                  if (M = "sdf", P = P.substring(4), !P.match(/^[0-9]+$/)) {
                    alert("Wrong Compound ID");
                    return;
                  }
                  h = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + P + "/SDF?record_type=3d";
                } else
                  P.substring(0, 4) == "url:" && (h = P.substring(4), M = h);
                var c = function(S) {
                  C.addMolData(S, M, s), _.zoomTo(), _.render();
                };
                g = new Promise(function(S) {
                  M == "mmtf" ? getbin(h).then(function(y) {
                    c(y), S(C);
                  }).catch(function() {
                    E = s && s.pdbUri ? s.pdbUri : "https://files.rcsb.org/view/", h = E + P + ".pdb", M = "pdb", console.log("falling back to pdb format"), get(h).then(function(y) {
                      c(y), S(C);
                    }).catch(function(y) {
                      c(""), S(C), console.log("fetch of " + h + " failed: " + y.statusText);
                    });
                  }) : get(h).then(function(y) {
                    c(y), S(C);
                  }).catch(function(y) {
                    c(""), S(C), console.log("fetch of " + h + " failed: " + y.statusText);
                  });
                });
              }
              return v ? (g.then(function(S) {
                v(S);
              }), C) : g;
            }
            function getColorFromStyle(P, _) {
              let s = _.colorscheme;
              if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[s] < "u")
                s = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[s];
              else if (typeof s == "string" && s.endsWith("Carbon")) {
                let A = s.substring(0, s.lastIndexOf("Carbon")).toLowerCase();
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[A] < "u") {
                  let h = Object.assign({}, _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors);
                  h.C = _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[A], _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[s] = { prop: "elem", map: h }, s = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[s];
                }
              }
              let v = P.color;
              if (typeof _.color < "u" && _.color != "spectrum" && (v = _.color), typeof s < "u") {
                let A, h;
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[s] < "u")
                  s = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[s], typeof s[P[s.prop]] < "u" && (v = s.map[P[s.prop]]);
                else if (typeof s[P[s.prop]] < "u")
                  v = s.map[P[s.prop]];
                else if (typeof s.prop < "u" && typeof s.gradient < "u") {
                  A = s.prop;
                  var M = s.gradient;
                  typeof _Gradient__WEBPACK_IMPORTED_MODULE_0__.builtinGradients[M] < "u" && (M = new _Gradient__WEBPACK_IMPORTED_MODULE_0__.builtinGradients[M](s.min, s.max, s.mid ? s.mid : s.colors));
                  let g = M.range() || [-1, 1];
                  h = getAtomProperty(P, A), h != null && (v = M.valueToHex(h, g));
                } else
                  typeof s.prop < "u" && typeof s.map < "u" ? (A = s.prop, h = getAtomProperty(P, A), typeof s.map[h] < "u" && (v = s.map[h])) : typeof _.colorscheme[P.elem] < "u" ? v = _.colorscheme[P.elem] : console.log("Could not interpret colorscheme " + s);
              } else
                typeof _.colorfunc < "u" && (v = _.colorfunc(P));
              return _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(v);
            }
            function getElement(P) {
              let _ = P;
              return typeof P == "string" ? _ = document.querySelector("#" + P) : typeof P == "object" && P.get && (_ = P.get(0)), _;
            }
          }
        ),
        /***/
        "./node_modules/upng-js/UPNG.js": (
          /*!**************************************!*\
            !*** ./node_modules/upng-js/UPNG.js ***!
            \**************************************/
          /***/
          (P, _, s) => {
            (function() {
              var v = {}, M;
              P.exports = v, M = s(
                /*! pako */
                "./node_modules/upng-js/node_modules/pako/index.js"
              ), function(E, A) {
                E.toRGBA8 = function(h) {
                  var g = h.width, C = h.height;
                  if (h.tabs.acTL == null)
                    return [E.toRGBA8.decodeImage(h.data, g, C, h).buffer];
                  var c = [];
                  h.frames[0].data == null && (h.frames[0].data = h.data);
                  for (var S, y = new Uint8Array(g * C * 4), b = 0; b < h.frames.length; b++) {
                    var w = h.frames[b], t = w.rect.x, r = w.rect.y, u = w.rect.width, o = w.rect.height, l = E.toRGBA8.decodeImage(w.data, u, o, h);
                    if (b == 0 ? S = l : w.blend == 0 ? E._copyTile(l, u, o, S, g, C, t, r, 0) : w.blend == 1 && E._copyTile(l, u, o, S, g, C, t, r, 1), c.push(S.buffer), S = S.slice(0), w.dispose != 0) {
                      if (w.dispose == 1)
                        E._copyTile(y, u, o, S, g, C, t, r, 0);
                      else if (w.dispose == 2) {
                        for (var e = b - 1; h.frames[e].dispose == 2; )
                          e--;
                        S = new Uint8Array(c[e]).slice(0);
                      }
                    }
                  }
                  return c;
                }, E.toRGBA8.decodeImage = function(h, g, C, c) {
                  var S = g * C, y = E.decode._getBPP(c), b = Math.ceil(g * y / 8), w = new Uint8Array(S * 4), t = new Uint32Array(w.buffer), r = c.ctype, u = c.depth, o = E._bin.readUshort;
                  if (r == 6) {
                    var l = S << 2;
                    if (u == 8)
                      for (var e = 0; e < l; e++)
                        w[e] = h[e];
                    if (u == 16)
                      for (var e = 0; e < l; e++)
                        w[e] = h[e << 1];
                  } else if (r == 2) {
                    var n = c.tabs.tRNS, a = -1, p = -1, x = -1;
                    if (n && (a = n[0], p = n[1], x = n[2]), u == 8)
                      for (var e = 0; e < S; e++) {
                        var D = e << 2, O = e * 3;
                        w[D] = h[O], w[D + 1] = h[O + 1], w[D + 2] = h[O + 2], w[D + 3] = 255, a != -1 && h[O] == a && h[O + 1] == p && h[O + 2] == x && (w[D + 3] = 0);
                      }
                    if (u == 16)
                      for (var e = 0; e < S; e++) {
                        var D = e << 2, O = e * 6;
                        w[D] = h[O], w[D + 1] = h[O + 2], w[D + 2] = h[O + 4], w[D + 3] = 255, a != -1 && o(h, O) == a && o(h, O + 2) == p && o(h, O + 4) == x && (w[D + 3] = 0);
                      }
                  } else if (r == 3) {
                    var R = c.tabs.PLTE, z = c.tabs.tRNS, T = z ? z.length : 0;
                    if (u == 1)
                      for (var B = 0; B < C; B++)
                        for (var W = B * b, k = B * g, e = 0; e < g; e++) {
                          var D = k + e << 2, F = h[W + (e >> 3)] >> 7 - ((e & 7) << 0) & 1, U = 3 * F;
                          w[D] = R[U], w[D + 1] = R[U + 1], w[D + 2] = R[U + 2], w[D + 3] = F < T ? z[F] : 255;
                        }
                    if (u == 2)
                      for (var B = 0; B < C; B++)
                        for (var W = B * b, k = B * g, e = 0; e < g; e++) {
                          var D = k + e << 2, F = h[W + (e >> 2)] >> 6 - ((e & 3) << 1) & 3, U = 3 * F;
                          w[D] = R[U], w[D + 1] = R[U + 1], w[D + 2] = R[U + 2], w[D + 3] = F < T ? z[F] : 255;
                        }
                    if (u == 4)
                      for (var B = 0; B < C; B++)
                        for (var W = B * b, k = B * g, e = 0; e < g; e++) {
                          var D = k + e << 2, F = h[W + (e >> 1)] >> 4 - ((e & 1) << 2) & 15, U = 3 * F;
                          w[D] = R[U], w[D + 1] = R[U + 1], w[D + 2] = R[U + 2], w[D + 3] = F < T ? z[F] : 255;
                        }
                    if (u == 8)
                      for (var e = 0; e < S; e++) {
                        var D = e << 2, F = h[e], U = 3 * F;
                        w[D] = R[U], w[D + 1] = R[U + 1], w[D + 2] = R[U + 2], w[D + 3] = F < T ? z[F] : 255;
                      }
                  } else if (r == 4) {
                    if (u == 8)
                      for (var e = 0; e < S; e++) {
                        var D = e << 2, V = e << 1, H = h[V];
                        w[D] = H, w[D + 1] = H, w[D + 2] = H, w[D + 3] = h[V + 1];
                      }
                    if (u == 16)
                      for (var e = 0; e < S; e++) {
                        var D = e << 2, V = e << 2, H = h[V];
                        w[D] = H, w[D + 1] = H, w[D + 2] = H, w[D + 3] = h[V + 2];
                      }
                  } else if (r == 0) {
                    var a = c.tabs.tRNS ? c.tabs.tRNS : -1;
                    if (u == 1)
                      for (var e = 0; e < S; e++) {
                        var H = 255 * (h[e >> 3] >> 7 - (e & 7) & 1), G = H == a * 255 ? 0 : 255;
                        t[e] = G << 24 | H << 16 | H << 8 | H;
                      }
                    if (u == 2)
                      for (var e = 0; e < S; e++) {
                        var H = 85 * (h[e >> 2] >> 6 - ((e & 3) << 1) & 3), G = H == a * 85 ? 0 : 255;
                        t[e] = G << 24 | H << 16 | H << 8 | H;
                      }
                    if (u == 4)
                      for (var e = 0; e < S; e++) {
                        var H = 17 * (h[e >> 1] >> 4 - ((e & 1) << 2) & 15), G = H == a * 17 ? 0 : 255;
                        t[e] = G << 24 | H << 16 | H << 8 | H;
                      }
                    if (u == 8)
                      for (var e = 0; e < S; e++) {
                        var H = h[e], G = H == a ? 0 : 255;
                        t[e] = G << 24 | H << 16 | H << 8 | H;
                      }
                    if (u == 16)
                      for (var e = 0; e < S; e++) {
                        var H = h[e << 1], G = o(h, e << 1) == a ? 0 : 255;
                        t[e] = G << 24 | H << 16 | H << 8 | H;
                      }
                  }
                  return w;
                }, E.decode = function(h) {
                  for (var g = new Uint8Array(h), C = 8, c = E._bin, S = c.readUshort, y = c.readUint, b = { tabs: {}, frames: [] }, w = new Uint8Array(g.length), t = 0, r, u = 0, o = [137, 80, 78, 71, 13, 10, 26, 10], l = 0; l < 8; l++)
                    if (g[l] != o[l])
                      throw "The input is not a PNG file!";
                  for (; C < g.length; ) {
                    var e = c.readUint(g, C);
                    C += 4;
                    var n = c.readASCII(g, C, 4);
                    if (C += 4, n == "IHDR")
                      E.decode._IHDR(g, C, b);
                    else if (n == "IDAT") {
                      for (var l = 0; l < e; l++)
                        w[t + l] = g[C + l];
                      t += e;
                    } else if (n == "acTL")
                      b.tabs[n] = { num_frames: y(g, C), num_plays: y(g, C + 4) }, r = new Uint8Array(g.length);
                    else if (n == "fcTL") {
                      if (u != 0) {
                        var a = b.frames[b.frames.length - 1];
                        a.data = E.decode._decompress(b, r.slice(0, u), a.rect.width, a.rect.height), u = 0;
                      }
                      var p = { x: y(g, C + 12), y: y(g, C + 16), width: y(g, C + 4), height: y(g, C + 8) }, x = S(g, C + 22);
                      x = S(g, C + 20) / (x == 0 ? 100 : x);
                      var D = { rect: p, delay: Math.round(x * 1e3), dispose: g[C + 24], blend: g[C + 25] };
                      b.frames.push(D);
                    } else if (n == "fdAT") {
                      for (var l = 0; l < e - 4; l++)
                        r[u + l] = g[C + l + 4];
                      u += e - 4;
                    } else if (n == "pHYs")
                      b.tabs[n] = [c.readUint(g, C), c.readUint(g, C + 4), g[C + 8]];
                    else if (n == "cHRM") {
                      b.tabs[n] = [];
                      for (var l = 0; l < 8; l++)
                        b.tabs[n].push(c.readUint(g, C + l * 4));
                    } else if (n == "tEXt") {
                      b.tabs[n] == null && (b.tabs[n] = {});
                      var O = c.nextZero(g, C), R = c.readASCII(g, C, O - C), z = c.readASCII(g, O + 1, C + e - O - 1);
                      b.tabs[n][R] = z;
                    } else if (n == "iTXt") {
                      b.tabs[n] == null && (b.tabs[n] = {});
                      var O = 0, T = C;
                      O = c.nextZero(g, T);
                      var R = c.readASCII(g, T, O - T);
                      T = O + 1, g[T], g[T + 1], T += 2, O = c.nextZero(g, T), c.readASCII(g, T, O - T), T = O + 1, O = c.nextZero(g, T), c.readUTF8(g, T, O - T), T = O + 1;
                      var z = c.readUTF8(g, T, e - (T - C));
                      b.tabs[n][R] = z;
                    } else if (n == "PLTE")
                      b.tabs[n] = c.readBytes(g, C, e);
                    else if (n == "hIST") {
                      var B = b.tabs.PLTE.length / 3;
                      b.tabs[n] = [];
                      for (var l = 0; l < B; l++)
                        b.tabs[n].push(S(g, C + l * 2));
                    } else if (n == "tRNS")
                      b.ctype == 3 ? b.tabs[n] = c.readBytes(g, C, e) : b.ctype == 0 ? b.tabs[n] = S(g, C) : b.ctype == 2 && (b.tabs[n] = [S(g, C), S(g, C + 2), S(g, C + 4)]);
                    else if (n == "gAMA")
                      b.tabs[n] = c.readUint(g, C) / 1e5;
                    else if (n == "sRGB")
                      b.tabs[n] = g[C];
                    else if (n == "bKGD")
                      b.ctype == 0 || b.ctype == 4 ? b.tabs[n] = [S(g, C)] : b.ctype == 2 || b.ctype == 6 ? b.tabs[n] = [S(g, C), S(g, C + 2), S(g, C + 4)] : b.ctype == 3 && (b.tabs[n] = g[C]);
                    else if (n == "IEND") {
                      if (u != 0) {
                        var a = b.frames[b.frames.length - 1];
                        a.data = E.decode._decompress(b, r.slice(0, u), a.rect.width, a.rect.height), u = 0;
                      }
                      b.data = E.decode._decompress(b, w, b.width, b.height);
                      break;
                    }
                    C += e, c.readUint(g, C), C += 4;
                  }
                  return delete b.compress, delete b.interlace, delete b.filter, b;
                }, E.decode._decompress = function(h, g, C, c) {
                  return h.compress == 0 && (g = E.decode._inflate(g)), h.interlace == 0 ? g = E.decode._filterZero(g, h, 0, C, c) : h.interlace == 1 && (g = E.decode._readInterlace(g, h)), g;
                }, E.decode._inflate = function(h) {
                  return A.inflate(h);
                }, E.decode._readInterlace = function(h, g) {
                  for (var C = g.width, c = g.height, S = E.decode._getBPP(g), y = S >> 3, b = Math.ceil(C * S / 8), w = new Uint8Array(c * b), t = 0, r = [0, 0, 4, 0, 2, 0, 1], u = [0, 4, 0, 2, 0, 1, 0], o = [8, 8, 8, 4, 4, 2, 2], l = [8, 8, 4, 4, 2, 2, 1], e = 0; e < 7; ) {
                    for (var n = o[e], a = l[e], p = 0, x = 0, D = r[e]; D < c; )
                      D += n, x++;
                    for (var O = u[e]; O < C; )
                      O += a, p++;
                    var R = Math.ceil(p * S / 8);
                    E.decode._filterZero(h, g, t, p, x);
                    for (var z = 0, T = r[e]; T < c; ) {
                      for (var B = u[e], W = t + z * R << 3; B < C; ) {
                        if (S == 1) {
                          var k = h[W >> 3];
                          k = k >> 7 - (W & 7) & 1, w[T * b + (B >> 3)] |= k << 7 - ((B & 3) << 0);
                        }
                        if (S == 2) {
                          var k = h[W >> 3];
                          k = k >> 6 - (W & 7) & 3, w[T * b + (B >> 2)] |= k << 6 - ((B & 3) << 1);
                        }
                        if (S == 4) {
                          var k = h[W >> 3];
                          k = k >> 4 - (W & 7) & 15, w[T * b + (B >> 1)] |= k << 4 - ((B & 1) << 2);
                        }
                        if (S >= 8)
                          for (var F = T * b + B * y, U = 0; U < y; U++)
                            w[F + U] = h[(W >> 3) + U];
                        W += S, B += a;
                      }
                      z++, T += n;
                    }
                    p * x != 0 && (t += x * (1 + R)), e = e + 1;
                  }
                  return w;
                }, E.decode._getBPP = function(h) {
                  var g = [1, null, 3, 1, 2, null, 4][h.ctype];
                  return g * h.depth;
                }, E.decode._filterZero = function(h, g, C, c, S) {
                  var y = E.decode._getBPP(g), b = Math.ceil(c * y / 8), w = E.decode._paeth;
                  y = Math.ceil(y / 8);
                  for (var t = 0; t < S; t++) {
                    var r = C + t * b, u = r + t + 1, o = h[u - 1];
                    if (o == 0)
                      for (var l = 0; l < b; l++)
                        h[r + l] = h[u + l];
                    else if (o == 1) {
                      for (var l = 0; l < y; l++)
                        h[r + l] = h[u + l];
                      for (var l = y; l < b; l++)
                        h[r + l] = h[u + l] + h[r + l - y] & 255;
                    } else if (t == 0) {
                      for (var l = 0; l < y; l++)
                        h[r + l] = h[u + l];
                      if (o == 2)
                        for (var l = y; l < b; l++)
                          h[r + l] = h[u + l] & 255;
                      if (o == 3)
                        for (var l = y; l < b; l++)
                          h[r + l] = h[u + l] + (h[r + l - y] >> 1) & 255;
                      if (o == 4)
                        for (var l = y; l < b; l++)
                          h[r + l] = h[u + l] + w(h[r + l - y], 0, 0) & 255;
                    } else {
                      if (o == 2)
                        for (var l = 0; l < b; l++)
                          h[r + l] = h[u + l] + h[r + l - b] & 255;
                      if (o == 3) {
                        for (var l = 0; l < y; l++)
                          h[r + l] = h[u + l] + (h[r + l - b] >> 1) & 255;
                        for (var l = y; l < b; l++)
                          h[r + l] = h[u + l] + (h[r + l - b] + h[r + l - y] >> 1) & 255;
                      }
                      if (o == 4) {
                        for (var l = 0; l < y; l++)
                          h[r + l] = h[u + l] + w(0, h[r + l - b], 0) & 255;
                        for (var l = y; l < b; l++)
                          h[r + l] = h[u + l] + w(h[r + l - y], h[r + l - b], h[r + l - y - b]) & 255;
                      }
                    }
                  }
                  return h;
                }, E.decode._paeth = function(h, g, C) {
                  var c = h + g - C, S = Math.abs(c - h), y = Math.abs(c - g), b = Math.abs(c - C);
                  return S <= y && S <= b ? h : y <= b ? g : C;
                }, E.decode._IHDR = function(h, g, C) {
                  var c = E._bin;
                  C.width = c.readUint(h, g), g += 4, C.height = c.readUint(h, g), g += 4, C.depth = h[g], g++, C.ctype = h[g], g++, C.compress = h[g], g++, C.filter = h[g], g++, C.interlace = h[g], g++;
                }, E._bin = {
                  nextZero: function(h, g) {
                    for (; h[g] != 0; )
                      g++;
                    return g;
                  },
                  readUshort: function(h, g) {
                    return h[g] << 8 | h[g + 1];
                  },
                  writeUshort: function(h, g, C) {
                    h[g] = C >> 8 & 255, h[g + 1] = C & 255;
                  },
                  readUint: function(h, g) {
                    return h[g] * 16777216 + (h[g + 1] << 16 | h[g + 2] << 8 | h[g + 3]);
                  },
                  writeUint: function(h, g, C) {
                    h[g] = C >> 24 & 255, h[g + 1] = C >> 16 & 255, h[g + 2] = C >> 8 & 255, h[g + 3] = C & 255;
                  },
                  readASCII: function(h, g, C) {
                    for (var c = "", S = 0; S < C; S++)
                      c += String.fromCharCode(h[g + S]);
                    return c;
                  },
                  writeASCII: function(h, g, C) {
                    for (var c = 0; c < C.length; c++)
                      h[g + c] = C.charCodeAt(c);
                  },
                  readBytes: function(h, g, C) {
                    for (var c = [], S = 0; S < C; S++)
                      c.push(h[g + S]);
                    return c;
                  },
                  pad: function(h) {
                    return h.length < 2 ? "0" + h : h;
                  },
                  readUTF8: function(h, g, C) {
                    for (var c = "", S, y = 0; y < C; y++)
                      c += "%" + E._bin.pad(h[g + y].toString(16));
                    try {
                      S = decodeURIComponent(c);
                    } catch {
                      return E._bin.readASCII(h, g, C);
                    }
                    return S;
                  }
                }, E._copyTile = function(h, g, C, c, S, y, b, w, t) {
                  for (var r = Math.min(g, S), u = Math.min(C, y), o = 0, l = 0, e = 0; e < u; e++)
                    for (var n = 0; n < r; n++)
                      if (b >= 0 && w >= 0 ? (o = e * g + n << 2, l = (w + e) * S + b + n << 2) : (o = (-w + e) * g - b + n << 2, l = e * S + n << 2), t == 0)
                        c[l] = h[o], c[l + 1] = h[o + 1], c[l + 2] = h[o + 2], c[l + 3] = h[o + 3];
                      else if (t == 1) {
                        var a = h[o + 3] * 0.00392156862745098, p = h[o] * a, x = h[o + 1] * a, D = h[o + 2] * a, O = c[l + 3] * (1 / 255), R = c[l] * O, z = c[l + 1] * O, T = c[l + 2] * O, B = 1 - a, W = a + O * B, k = W == 0 ? 0 : 1 / W;
                        c[l + 3] = 255 * W, c[l + 0] = (p + R * B) * k, c[l + 1] = (x + z * B) * k, c[l + 2] = (D + T * B) * k;
                      } else if (t == 2) {
                        var a = h[o + 3], p = h[o], x = h[o + 1], D = h[o + 2], O = c[l + 3], R = c[l], z = c[l + 1], T = c[l + 2];
                        a == O && p == R && x == z && D == T ? (c[l] = 0, c[l + 1] = 0, c[l + 2] = 0, c[l + 3] = 0) : (c[l] = p, c[l + 1] = x, c[l + 2] = D, c[l + 3] = a);
                      } else if (t == 3) {
                        var a = h[o + 3], p = h[o], x = h[o + 1], D = h[o + 2], O = c[l + 3], R = c[l], z = c[l + 1], T = c[l + 2];
                        if (a == O && p == R && x == z && D == T)
                          continue;
                        if (a < 220 && O > 20)
                          return !1;
                      }
                  return !0;
                }, E.encode = function(h, g, C, c, S, y) {
                  c == null && (c = 0), y == null && (y = !1);
                  for (var b = new Uint8Array(h[0].byteLength * h.length + 100), w = [137, 80, 78, 71, 13, 10, 26, 10], t = 0; t < 8; t++)
                    b[t] = w[t];
                  var r = 8, u = E._bin, o = E.crc.crc, l = u.writeUint, e = u.writeUshort, n = u.writeASCII, a = E.encode.compressPNG(h, g, C, c, y);
                  l(b, r, 13), r += 4, n(b, r, "IHDR"), r += 4, l(b, r, g), r += 4, l(b, r, C), r += 4, b[r] = a.depth, r++, b[r] = a.ctype, r++, b[r] = 0, r++, b[r] = 0, r++, b[r] = 0, r++, l(b, r, o(b, r - 17, 17)), r += 4, l(b, r, 1), r += 4, n(b, r, "sRGB"), r += 4, b[r] = 1, r++, l(b, r, o(b, r - 5, 5)), r += 4;
                  var p = h.length > 1;
                  if (p && (l(b, r, 8), r += 4, n(b, r, "acTL"), r += 4, l(b, r, h.length), r += 4, l(b, r, 0), r += 4, l(b, r, o(b, r - 12, 12)), r += 4), a.ctype == 3) {
                    var x = a.plte.length;
                    l(b, r, x * 3), r += 4, n(b, r, "PLTE"), r += 4;
                    for (var t = 0; t < x; t++) {
                      var D = t * 3, O = a.plte[t], R = O & 255, z = O >> 8 & 255, T = O >> 16 & 255;
                      b[r + D + 0] = R, b[r + D + 1] = z, b[r + D + 2] = T;
                    }
                    if (r += x * 3, l(b, r, o(b, r - x * 3 - 4, x * 3 + 4)), r += 4, a.gotAlpha) {
                      l(b, r, x), r += 4, n(b, r, "tRNS"), r += 4;
                      for (var t = 0; t < x; t++)
                        b[r + t] = a.plte[t] >> 24 & 255;
                      r += x, l(b, r, o(b, r - x - 4, x + 4)), r += 4;
                    }
                  }
                  for (var B = 0, W = 0; W < a.frames.length; W++) {
                    var k = a.frames[W];
                    p && (l(b, r, 26), r += 4, n(b, r, "fcTL"), r += 4, l(b, r, B++), r += 4, l(b, r, k.rect.width), r += 4, l(b, r, k.rect.height), r += 4, l(b, r, k.rect.x), r += 4, l(b, r, k.rect.y), r += 4, e(b, r, S[W]), r += 2, e(b, r, 1e3), r += 2, b[r] = k.dispose, r++, b[r] = k.blend, r++, l(b, r, o(b, r - 30, 30)), r += 4);
                    var F = k.cimg, x = F.length;
                    l(b, r, x + (W == 0 ? 0 : 4)), r += 4;
                    var U = r;
                    n(b, r, W == 0 ? "IDAT" : "fdAT"), r += 4, W != 0 && (l(b, r, B++), r += 4);
                    for (var t = 0; t < x; t++)
                      b[r + t] = F[t];
                    r += x, l(b, r, o(b, U, r - U)), r += 4;
                  }
                  return l(b, r, 0), r += 4, n(b, r, "IEND"), r += 4, l(b, r, o(b, r - 4, 4)), r += 4, b.buffer.slice(0, r);
                }, E.encode.compressPNG = function(h, g, C, c, S) {
                  for (var y = E.encode.compress(h, g, C, c, !1, S), b = 0; b < h.length; b++) {
                    var w = y.frames[b];
                    w.rect.width;
                    var t = w.rect.height, r = w.bpl, u = w.bpp, o = new Uint8Array(t * r + t);
                    w.cimg = E.encode._filterZero(w.img, t, u, r, o);
                  }
                  return y;
                }, E.encode.compress = function(h, g, C, c, S, y) {
                  y == null && (y = !1);
                  for (var b = 6, w = 8, t = 4, r = 255, u = 0; u < h.length; u++)
                    for (var o = new Uint8Array(h[u]), l = o.length, e = 0; e < l; e += 4)
                      r &= o[e + 3];
                  var n = r != 255, a = {}, p = [];
                  if (h.length != 0 && (a[0] = 0, p.push(0), c != 0 && c--), c != 0) {
                    var x = E.quantize(h, c, S);
                    h = x.bufs;
                    for (var e = 0; e < x.plte.length; e++) {
                      var D = x.plte[e].est.rgba;
                      a[D] == null && (a[D] = p.length, p.push(D));
                    }
                  } else
                    for (var u = 0; u < h.length; u++)
                      for (var O = new Uint32Array(h[u]), l = O.length, e = 0; e < l; e++) {
                        var D = O[e];
                        if ((e < g || D != O[e - 1] && D != O[e - g]) && a[D] == null && (a[D] = p.length, p.push(D), p.length >= 300))
                          break;
                      }
                  var R = n ? S : !1, z = p.length;
                  z <= 256 && y == !1 && (z <= 2 ? w = 1 : z <= 4 ? w = 2 : z <= 16 ? w = 4 : w = 8, S && (w = 8), n = !0);
                  for (var T = [], u = 0; u < h.length; u++) {
                    var B = new Uint8Array(h[u]), W = new Uint32Array(B.buffer), k = 0, F = 0, U = g, V = C, H = 0;
                    if (u != 0 && !R) {
                      for (var G = S || u == 1 || T[T.length - 2].dispose == 2 ? 1 : 2, Y = 0, J = 1e9, re = 0; re < G; re++) {
                        for (var ae = new Uint8Array(h[u - 1 - re]), le = new Uint32Array(h[u - 1 - re]), ie = g, xe = C, se = -1, ce = -1, Ee = 0; Ee < C; Ee++)
                          for (var be = 0; be < g; be++) {
                            var e = Ee * g + be;
                            W[e] != le[e] && (be < ie && (ie = be), be > se && (se = be), Ee < xe && (xe = Ee), Ee > ce && (ce = Ee));
                          }
                        var Le = se == -1 ? 1 : (se - ie + 1) * (ce - xe + 1);
                        Le < J && (J = Le, Y = re, se == -1 ? (k = F = 0, U = V = 1) : (k = ie, F = xe, U = se - ie + 1, V = ce - xe + 1));
                      }
                      var ae = new Uint8Array(h[u - 1 - Y]);
                      Y == 1 && (T[T.length - 1].dispose = 2);
                      var pe = new Uint8Array(U * V * 4);
                      new Uint32Array(pe.buffer), E._copyTile(ae, g, C, pe, U, V, -k, -F, 0), E._copyTile(B, g, C, pe, U, V, -k, -F, 3) ? (E._copyTile(B, g, C, pe, U, V, -k, -F, 2), H = 1) : (E._copyTile(B, g, C, pe, U, V, -k, -F, 0), H = 0), B = pe, W = new Uint32Array(B.buffer);
                    }
                    var we = 4 * U;
                    if (z <= 256 && y == !1) {
                      we = Math.ceil(w * U / 8);
                      for (var pe = new Uint8Array(we * V), Ee = 0; Ee < V; Ee++) {
                        var e = Ee * we, Ge = Ee * U;
                        if (w == 8)
                          for (var be = 0; be < U; be++)
                            pe[e + be] = a[W[Ge + be]];
                        else if (w == 4)
                          for (var be = 0; be < U; be++)
                            pe[e + (be >> 1)] |= a[W[Ge + be]] << 4 - (be & 1) * 4;
                        else if (w == 2)
                          for (var be = 0; be < U; be++)
                            pe[e + (be >> 2)] |= a[W[Ge + be]] << 6 - (be & 3) * 2;
                        else if (w == 1)
                          for (var be = 0; be < U; be++)
                            pe[e + (be >> 3)] |= a[W[Ge + be]] << 7 - (be & 7) * 1;
                      }
                      B = pe, b = 3, t = 1;
                    } else if (n == !1 && h.length == 1) {
                      for (var pe = new Uint8Array(U * V * 3), We = U * V, e = 0; e < We; e++) {
                        var je = e * 3, Fe = e * 4;
                        pe[je] = B[Fe], pe[je + 1] = B[Fe + 1], pe[je + 2] = B[Fe + 2];
                      }
                      B = pe, b = 2, t = 3, we = 3 * U;
                    }
                    T.push({ rect: { x: k, y: F, width: U, height: V }, img: B, bpl: we, bpp: t, blend: H, dispose: R ? 1 : 0 });
                  }
                  return { ctype: b, depth: w, plte: p, gotAlpha: n, frames: T };
                }, E.encode._filterZero = function(h, g, C, c, S) {
                  for (var y = [], b = 0; b < 5; b++)
                    if (!(g * c > 5e5 && (b == 2 || b == 3 || b == 4))) {
                      for (var w = 0; w < g; w++)
                        E.encode._filterLine(S, h, w, c, C, b);
                      if (y.push(A.deflate(S)), C == 1)
                        break;
                    }
                  for (var t, r = 1e9, u = 0; u < y.length; u++)
                    y[u].length < r && (t = u, r = y[u].length);
                  return y[t];
                }, E.encode._filterLine = function(h, g, C, c, S, y) {
                  var b = C * c, w = b + C, t = E.decode._paeth;
                  if (h[w] = y, w++, y == 0)
                    for (var r = 0; r < c; r++)
                      h[w + r] = g[b + r];
                  else if (y == 1) {
                    for (var r = 0; r < S; r++)
                      h[w + r] = g[b + r];
                    for (var r = S; r < c; r++)
                      h[w + r] = g[b + r] - g[b + r - S] + 256 & 255;
                  } else if (C == 0) {
                    for (var r = 0; r < S; r++)
                      h[w + r] = g[b + r];
                    if (y == 2)
                      for (var r = S; r < c; r++)
                        h[w + r] = g[b + r];
                    if (y == 3)
                      for (var r = S; r < c; r++)
                        h[w + r] = g[b + r] - (g[b + r - S] >> 1) + 256 & 255;
                    if (y == 4)
                      for (var r = S; r < c; r++)
                        h[w + r] = g[b + r] - t(g[b + r - S], 0, 0) + 256 & 255;
                  } else {
                    if (y == 2)
                      for (var r = 0; r < c; r++)
                        h[w + r] = g[b + r] + 256 - g[b + r - c] & 255;
                    if (y == 3) {
                      for (var r = 0; r < S; r++)
                        h[w + r] = g[b + r] + 256 - (g[b + r - c] >> 1) & 255;
                      for (var r = S; r < c; r++)
                        h[w + r] = g[b + r] + 256 - (g[b + r - c] + g[b + r - S] >> 1) & 255;
                    }
                    if (y == 4) {
                      for (var r = 0; r < S; r++)
                        h[w + r] = g[b + r] + 256 - t(0, g[b + r - c], 0) & 255;
                      for (var r = S; r < c; r++)
                        h[w + r] = g[b + r] + 256 - t(g[b + r - S], g[b + r - c], g[b + r - S - c]) & 255;
                    }
                  }
                }, E.crc = {
                  table: function() {
                    for (var h = new Uint32Array(256), g = 0; g < 256; g++) {
                      for (var C = g, c = 0; c < 8; c++)
                        C & 1 ? C = 3988292384 ^ C >>> 1 : C = C >>> 1;
                      h[g] = C;
                    }
                    return h;
                  }(),
                  update: function(h, g, C, c) {
                    for (var S = 0; S < c; S++)
                      h = E.crc.table[(h ^ g[C + S]) & 255] ^ h >>> 8;
                    return h;
                  },
                  crc: function(h, g, C) {
                    return E.crc.update(4294967295, h, g, C) ^ 4294967295;
                  }
                }, E.quantize = function(h, g, C) {
                  for (var c = [], S = 0, y = 0; y < h.length; y++)
                    c.push(E.encode.alphaMul(new Uint8Array(h[y]), C)), S += h[y].byteLength;
                  for (var b = new Uint8Array(S), w = new Uint32Array(b.buffer), t = 0, y = 0; y < c.length; y++) {
                    for (var r = c[y], u = r.length, o = 0; o < u; o++)
                      b[t + o] = r[o];
                    t += u;
                  }
                  var l = { i0: 0, i1: b.length, bst: null, est: null, tdst: 0, left: null, right: null };
                  l.bst = E.quantize.stats(b, l.i0, l.i1), l.est = E.quantize.estats(l.bst);
                  for (var e = [l]; e.length < g; ) {
                    for (var n = 0, a = 0, y = 0; y < e.length; y++)
                      e[y].est.L > n && (n = e[y].est.L, a = y);
                    if (n < 1e-3)
                      break;
                    var p = e[a], x = E.quantize.splitPixels(b, w, p.i0, p.i1, p.est.e, p.est.eMq255), D = { i0: p.i0, i1: x, bst: null, est: null, tdst: 0, left: null, right: null };
                    D.bst = E.quantize.stats(b, D.i0, D.i1), D.est = E.quantize.estats(D.bst);
                    var O = { i0: x, i1: p.i1, bst: null, est: null, tdst: 0, left: null, right: null };
                    O.bst = { R: [], m: [], N: p.bst.N - D.bst.N };
                    for (var y = 0; y < 16; y++)
                      O.bst.R[y] = p.bst.R[y] - D.bst.R[y];
                    for (var y = 0; y < 4; y++)
                      O.bst.m[y] = p.bst.m[y] - D.bst.m[y];
                    O.est = E.quantize.estats(O.bst), p.left = D, p.right = O, e[a] = D, e.push(O);
                  }
                  e.sort(function(G, Y) {
                    return Y.bst.N - G.bst.N;
                  });
                  for (var R = 0; R < c.length; R++) {
                    for (var z = E.quantize.planeDst, T = new Uint8Array(c[R].buffer), B = new Uint32Array(c[R].buffer), W = T.length, y = 0; y < W; y += 4) {
                      for (var k = T[y] * 0.00392156862745098, F = T[y + 1] * (1 / 255), U = T[y + 2] * (1 / 255), V = T[y + 3] * (1 / 255), H = l; H.left; )
                        H = z(H.est, k, F, U, V) <= 0 ? H.left : H.right;
                      B[y >> 2] = H.est.rgba;
                    }
                    c[R] = B.buffer;
                  }
                  return { bufs: c, plte: e };
                }, E.quantize.getNearest = function(h, g, C, c, S) {
                  if (h.left == null)
                    return h.tdst = E.quantize.dist(h.est.q, g, C, c, S), h;
                  var y = E.quantize.planeDst(h.est, g, C, c, S), b = h.left, w = h.right;
                  y > 0 && (b = h.right, w = h.left);
                  var t = E.quantize.getNearest(b, g, C, c, S);
                  if (t.tdst <= y * y)
                    return t;
                  var r = E.quantize.getNearest(w, g, C, c, S);
                  return r.tdst < t.tdst ? r : t;
                }, E.quantize.planeDst = function(h, g, C, c, S) {
                  var y = h.e;
                  return y[0] * g + y[1] * C + y[2] * c + y[3] * S - h.eMq;
                }, E.quantize.dist = function(h, g, C, c, S) {
                  var y = g - h[0], b = C - h[1], w = c - h[2], t = S - h[3];
                  return y * y + b * b + w * w + t * t;
                }, E.quantize.splitPixels = function(h, g, C, c, S, y) {
                  var b = E.quantize.vecDot;
                  for (c -= 4; C < c; ) {
                    for (; b(h, C, S) <= y; )
                      C += 4;
                    for (; b(h, c, S) > y; )
                      c -= 4;
                    if (C >= c)
                      break;
                    var w = g[C >> 2];
                    g[C >> 2] = g[c >> 2], g[c >> 2] = w, C += 4, c -= 4;
                  }
                  for (; b(h, C, S) > y; )
                    C -= 4;
                  return C + 4;
                }, E.quantize.vecDot = function(h, g, C) {
                  return h[g] * C[0] + h[g + 1] * C[1] + h[g + 2] * C[2] + h[g + 3] * C[3];
                }, E.quantize.stats = function(h, g, C) {
                  for (var c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], S = [0, 0, 0, 0], y = C - g >> 2, b = g; b < C; b += 4) {
                    var w = h[b] * 0.00392156862745098, t = h[b + 1] * (1 / 255), r = h[b + 2] * (1 / 255), u = h[b + 3] * (1 / 255);
                    S[0] += w, S[1] += t, S[2] += r, S[3] += u, c[0] += w * w, c[1] += w * t, c[2] += w * r, c[3] += w * u, c[5] += t * t, c[6] += t * r, c[7] += t * u, c[10] += r * r, c[11] += r * u, c[15] += u * u;
                  }
                  return c[4] = c[1], c[8] = c[2], c[12] = c[3], c[9] = c[6], c[13] = c[7], c[14] = c[11], { R: c, m: S, N: y };
                }, E.quantize.estats = function(h) {
                  var g = h.R, C = h.m, c = h.N, S = C[0], y = C[1], b = C[2], w = C[3], t = c == 0 ? 0 : 1 / c, r = [
                    g[0] - S * S * t,
                    g[1] - S * y * t,
                    g[2] - S * b * t,
                    g[3] - S * w * t,
                    g[4] - y * S * t,
                    g[5] - y * y * t,
                    g[6] - y * b * t,
                    g[7] - y * w * t,
                    g[8] - b * S * t,
                    g[9] - b * y * t,
                    g[10] - b * b * t,
                    g[11] - b * w * t,
                    g[12] - w * S * t,
                    g[13] - w * y * t,
                    g[14] - w * b * t,
                    g[15] - w * w * t
                  ], u = r, o = E.M4, l = [0.5, 0.5, 0.5, 0.5], e = 0, n = 0;
                  if (c != 0)
                    for (var a = 0; a < 10 && (l = o.multVec(u, l), n = Math.sqrt(o.dot(l, l)), l = o.sml(1 / n, l), !(Math.abs(n - e) < 1e-9)); a++)
                      e = n;
                  var p = [S * t, y * t, b * t, w * t], x = o.dot(o.sml(255, p), l), D = p[3] < 1e-3 ? 0 : 1 / p[3];
                  return {
                    Cov: r,
                    q: p,
                    e: l,
                    L: e,
                    eMq255: x,
                    eMq: o.dot(l, p),
                    rgba: (Math.round(255 * p[3]) << 24 | Math.round(255 * p[2] * D) << 16 | Math.round(255 * p[1] * D) << 8 | Math.round(255 * p[0] * D) << 0) >>> 0
                  };
                }, E.M4 = {
                  multVec: function(h, g) {
                    return [
                      h[0] * g[0] + h[1] * g[1] + h[2] * g[2] + h[3] * g[3],
                      h[4] * g[0] + h[5] * g[1] + h[6] * g[2] + h[7] * g[3],
                      h[8] * g[0] + h[9] * g[1] + h[10] * g[2] + h[11] * g[3],
                      h[12] * g[0] + h[13] * g[1] + h[14] * g[2] + h[15] * g[3]
                    ];
                  },
                  dot: function(h, g) {
                    return h[0] * g[0] + h[1] * g[1] + h[2] * g[2] + h[3] * g[3];
                  },
                  sml: function(h, g) {
                    return [h * g[0], h * g[1], h * g[2], h * g[3]];
                  }
                }, E.encode.alphaMul = function(h, g) {
                  for (var C = new Uint8Array(h.length), c = h.length >> 2, S = 0; S < c; S++) {
                    var y = S << 2, b = h[y + 3];
                    g && (b = b < 128 ? 0 : 255);
                    var w = b * (1 / 255);
                    C[y + 0] = h[y + 0] * w, C[y + 1] = h[y + 1] * w, C[y + 2] = h[y + 2] * w, C[y + 3] = b;
                  }
                  return C;
                };
              }(v, M);
            })();
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/index.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/index.js ***!
            \*********************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ./lib/utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ).assign, M = s(
              /*! ./lib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/deflate.js"
            ), E = s(
              /*! ./lib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/inflate.js"
            ), A = s(
              /*! ./lib/zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), h = {};
            v(h, M, E, A), P.exports = h;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/deflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/deflate.js ***!
            \***************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ./zlib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js"
            ), M = s(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), E = s(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), A = s(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), h = s(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), g = Object.prototype.toString, C = 0, c = 4, S = 0, y = 1, b = 2, w = -1, t = 0, r = 8;
            function u(n) {
              if (!(this instanceof u))
                return new u(n);
              this.options = M.assign({
                level: w,
                method: r,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: t,
                to: ""
              }, n || {});
              var a = this.options;
              a.raw && a.windowBits > 0 ? a.windowBits = -a.windowBits : a.gzip && a.windowBits > 0 && a.windowBits < 16 && (a.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
              var p = v.deflateInit2(
                this.strm,
                a.level,
                a.method,
                a.windowBits,
                a.memLevel,
                a.strategy
              );
              if (p !== S)
                throw new Error(A[p]);
              if (a.header && v.deflateSetHeader(this.strm, a.header), a.dictionary) {
                var x;
                if (typeof a.dictionary == "string" ? x = E.string2buf(a.dictionary) : g.call(a.dictionary) === "[object ArrayBuffer]" ? x = new Uint8Array(a.dictionary) : x = a.dictionary, p = v.deflateSetDictionary(this.strm, x), p !== S)
                  throw new Error(A[p]);
                this._dict_set = !0;
              }
            }
            u.prototype.push = function(n, a) {
              var p = this.strm, x = this.options.chunkSize, D, O;
              if (this.ended)
                return !1;
              O = a === ~~a ? a : a === !0 ? c : C, typeof n == "string" ? p.input = E.string2buf(n) : g.call(n) === "[object ArrayBuffer]" ? p.input = new Uint8Array(n) : p.input = n, p.next_in = 0, p.avail_in = p.input.length;
              do {
                if (p.avail_out === 0 && (p.output = new M.Buf8(x), p.next_out = 0, p.avail_out = x), D = v.deflate(p, O), D !== y && D !== S)
                  return this.onEnd(D), this.ended = !0, !1;
                (p.avail_out === 0 || p.avail_in === 0 && (O === c || O === b)) && (this.options.to === "string" ? this.onData(E.buf2binstring(M.shrinkBuf(p.output, p.next_out))) : this.onData(M.shrinkBuf(p.output, p.next_out)));
              } while ((p.avail_in > 0 || p.avail_out === 0) && D !== y);
              return O === c ? (D = v.deflateEnd(this.strm), this.onEnd(D), this.ended = !0, D === S) : (O === b && (this.onEnd(S), p.avail_out = 0), !0);
            }, u.prototype.onData = function(n) {
              this.chunks.push(n);
            }, u.prototype.onEnd = function(n) {
              n === S && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = M.flattenChunks(this.chunks)), this.chunks = [], this.err = n, this.msg = this.strm.msg;
            };
            function o(n, a) {
              var p = new u(a);
              if (p.push(n, !0), p.err)
                throw p.msg || A[p.err];
              return p.result;
            }
            function l(n, a) {
              return a = a || {}, a.raw = !0, o(n, a);
            }
            function e(n, a) {
              return a = a || {}, a.gzip = !0, o(n, a);
            }
            _.Deflate = u, _.deflate = o, _.deflateRaw = l, _.gzip = e;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/inflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/inflate.js ***!
            \***************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ./zlib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js"
            ), M = s(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), E = s(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), A = s(
              /*! ./zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), h = s(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), g = s(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), C = s(
              /*! ./zlib/gzheader */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js"
            ), c = Object.prototype.toString;
            function S(w) {
              if (!(this instanceof S))
                return new S(w);
              this.options = M.assign({
                chunkSize: 16384,
                windowBits: 0,
                to: ""
              }, w || {});
              var t = this.options;
              t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(w && w.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new g(), this.strm.avail_out = 0;
              var r = v.inflateInit2(
                this.strm,
                t.windowBits
              );
              if (r !== A.Z_OK)
                throw new Error(h[r]);
              if (this.header = new C(), v.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = E.string2buf(t.dictionary) : c.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = v.inflateSetDictionary(this.strm, t.dictionary), r !== A.Z_OK)))
                throw new Error(h[r]);
            }
            S.prototype.push = function(w, t) {
              var r = this.strm, u = this.options.chunkSize, o = this.options.dictionary, l, e, n, a, p, x = !1;
              if (this.ended)
                return !1;
              e = t === ~~t ? t : t === !0 ? A.Z_FINISH : A.Z_NO_FLUSH, typeof w == "string" ? r.input = E.binstring2buf(w) : c.call(w) === "[object ArrayBuffer]" ? r.input = new Uint8Array(w) : r.input = w, r.next_in = 0, r.avail_in = r.input.length;
              do {
                if (r.avail_out === 0 && (r.output = new M.Buf8(u), r.next_out = 0, r.avail_out = u), l = v.inflate(r, A.Z_NO_FLUSH), l === A.Z_NEED_DICT && o && (l = v.inflateSetDictionary(this.strm, o)), l === A.Z_BUF_ERROR && x === !0 && (l = A.Z_OK, x = !1), l !== A.Z_STREAM_END && l !== A.Z_OK)
                  return this.onEnd(l), this.ended = !0, !1;
                r.next_out && (r.avail_out === 0 || l === A.Z_STREAM_END || r.avail_in === 0 && (e === A.Z_FINISH || e === A.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (n = E.utf8border(r.output, r.next_out), a = r.next_out - n, p = E.buf2string(r.output, n), r.next_out = a, r.avail_out = u - a, a && M.arraySet(r.output, r.output, n, a, 0), this.onData(p)) : this.onData(M.shrinkBuf(r.output, r.next_out))), r.avail_in === 0 && r.avail_out === 0 && (x = !0);
              } while ((r.avail_in > 0 || r.avail_out === 0) && l !== A.Z_STREAM_END);
              return l === A.Z_STREAM_END && (e = A.Z_FINISH), e === A.Z_FINISH ? (l = v.inflateEnd(this.strm), this.onEnd(l), this.ended = !0, l === A.Z_OK) : (e === A.Z_SYNC_FLUSH && (this.onEnd(A.Z_OK), r.avail_out = 0), !0);
            }, S.prototype.onData = function(w) {
              this.chunks.push(w);
            }, S.prototype.onEnd = function(w) {
              w === A.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = M.flattenChunks(this.chunks)), this.chunks = [], this.err = w, this.msg = this.strm.msg;
            };
            function y(w, t) {
              var r = new S(t);
              if (r.push(w, !0), r.err)
                throw r.msg || h[r.err];
              return r.result;
            }
            function b(w, t) {
              return t = t || {}, t.raw = !0, y(w, t);
            }
            _.Inflate = S, _.inflate = y, _.inflateRaw = b, _.ungzip = y;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/common.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/common.js ***!
            \********************************************************************/
          /***/
          (P, _) => {
            var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            function v(A, h) {
              return Object.prototype.hasOwnProperty.call(A, h);
            }
            _.assign = function(A) {
              for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
                var g = h.shift();
                if (g) {
                  if (typeof g != "object")
                    throw new TypeError(g + "must be non-object");
                  for (var C in g)
                    v(g, C) && (A[C] = g[C]);
                }
              }
              return A;
            }, _.shrinkBuf = function(A, h) {
              return A.length === h ? A : A.subarray ? A.subarray(0, h) : (A.length = h, A);
            };
            var M = {
              arraySet: function(A, h, g, C, c) {
                if (h.subarray && A.subarray) {
                  A.set(h.subarray(g, g + C), c);
                  return;
                }
                for (var S = 0; S < C; S++)
                  A[c + S] = h[g + S];
              },
              // Join array of chunks to single array.
              flattenChunks: function(A) {
                var h, g, C, c, S, y;
                for (C = 0, h = 0, g = A.length; h < g; h++)
                  C += A[h].length;
                for (y = new Uint8Array(C), c = 0, h = 0, g = A.length; h < g; h++)
                  S = A[h], y.set(S, c), c += S.length;
                return y;
              }
            }, E = {
              arraySet: function(A, h, g, C, c) {
                for (var S = 0; S < C; S++)
                  A[c + S] = h[g + S];
              },
              // Join array of chunks to single array.
              flattenChunks: function(A) {
                return [].concat.apply([], A);
              }
            };
            _.setTyped = function(A) {
              A ? (_.Buf8 = Uint8Array, _.Buf16 = Uint16Array, _.Buf32 = Int32Array, _.assign(_, M)) : (_.Buf8 = Array, _.Buf16 = Array, _.Buf32 = Array, _.assign(_, E));
            }, _.setTyped(s);
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/strings.js ***!
            \*********************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ./common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), M = !0, E = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              M = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              E = !1;
            }
            for (var A = new v.Buf8(256), h = 0; h < 256; h++)
              A[h] = h >= 252 ? 6 : h >= 248 ? 5 : h >= 240 ? 4 : h >= 224 ? 3 : h >= 192 ? 2 : 1;
            A[254] = A[254] = 1, _.string2buf = function(C) {
              var c, S, y, b, w, t = C.length, r = 0;
              for (b = 0; b < t; b++)
                S = C.charCodeAt(b), (S & 64512) === 55296 && b + 1 < t && (y = C.charCodeAt(b + 1), (y & 64512) === 56320 && (S = 65536 + (S - 55296 << 10) + (y - 56320), b++)), r += S < 128 ? 1 : S < 2048 ? 2 : S < 65536 ? 3 : 4;
              for (c = new v.Buf8(r), w = 0, b = 0; w < r; b++)
                S = C.charCodeAt(b), (S & 64512) === 55296 && b + 1 < t && (y = C.charCodeAt(b + 1), (y & 64512) === 56320 && (S = 65536 + (S - 55296 << 10) + (y - 56320), b++)), S < 128 ? c[w++] = S : S < 2048 ? (c[w++] = 192 | S >>> 6, c[w++] = 128 | S & 63) : S < 65536 ? (c[w++] = 224 | S >>> 12, c[w++] = 128 | S >>> 6 & 63, c[w++] = 128 | S & 63) : (c[w++] = 240 | S >>> 18, c[w++] = 128 | S >>> 12 & 63, c[w++] = 128 | S >>> 6 & 63, c[w++] = 128 | S & 63);
              return c;
            };
            function g(C, c) {
              if (c < 65534 && (C.subarray && E || !C.subarray && M))
                return String.fromCharCode.apply(null, v.shrinkBuf(C, c));
              for (var S = "", y = 0; y < c; y++)
                S += String.fromCharCode(C[y]);
              return S;
            }
            _.buf2binstring = function(C) {
              return g(C, C.length);
            }, _.binstring2buf = function(C) {
              for (var c = new v.Buf8(C.length), S = 0, y = c.length; S < y; S++)
                c[S] = C.charCodeAt(S);
              return c;
            }, _.buf2string = function(C, c) {
              var S, y, b, w, t = c || C.length, r = new Array(t * 2);
              for (y = 0, S = 0; S < t; ) {
                if (b = C[S++], b < 128) {
                  r[y++] = b;
                  continue;
                }
                if (w = A[b], w > 4) {
                  r[y++] = 65533, S += w - 1;
                  continue;
                }
                for (b &= w === 2 ? 31 : w === 3 ? 15 : 7; w > 1 && S < t; )
                  b = b << 6 | C[S++] & 63, w--;
                if (w > 1) {
                  r[y++] = 65533;
                  continue;
                }
                b < 65536 ? r[y++] = b : (b -= 65536, r[y++] = 55296 | b >> 10 & 1023, r[y++] = 56320 | b & 1023);
              }
              return g(r, y);
            }, _.utf8border = function(C, c) {
              var S;
              for (c = c || C.length, c > C.length && (c = C.length), S = c - 1; S >= 0 && (C[S] & 192) === 128; )
                S--;
              return S < 0 || S === 0 ? c : S + A[C[S]] > c ? S : c;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js ***!
            \********************************************************************/
          /***/
          (P) => {
            function _(s, v, M, E) {
              for (var A = s & 65535 | 0, h = s >>> 16 & 65535 | 0, g = 0; M !== 0; ) {
                g = M > 2e3 ? 2e3 : M, M -= g;
                do
                  A = A + v[E++] | 0, h = h + A | 0;
                while (--g);
                A %= 65521, h %= 65521;
              }
              return A | h << 16 | 0;
            }
            P.exports = _;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js": (
          /*!**********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js ***!
            \**********************************************************************/
          /***/
          (P) => {
            P.exports = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              //Z_MEM_ERROR:     -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js ***!
            \******************************************************************/
          /***/
          (P) => {
            function _() {
              for (var M, E = [], A = 0; A < 256; A++) {
                M = A;
                for (var h = 0; h < 8; h++)
                  M = M & 1 ? 3988292384 ^ M >>> 1 : M >>> 1;
                E[A] = M;
              }
              return E;
            }
            var s = _();
            function v(M, E, A, h) {
              var g = s, C = h + A;
              M ^= -1;
              for (var c = h; c < C; c++)
                M = M >>> 8 ^ g[(M ^ E[c]) & 255];
              return M ^ -1;
            }
            P.exports = v;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js ***!
            \********************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), M = s(
              /*! ./trees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js"
            ), E = s(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), A = s(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), h = s(
              /*! ./messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), g = 0, C = 1, c = 3, S = 4, y = 5, b = 0, w = 1, t = -2, r = -3, u = -5, o = -1, l = 1, e = 2, n = 3, a = 4, p = 0, x = 2, D = 8, O = 9, R = 15, z = 8, T = 29, B = 256, W = B + 1 + T, k = 30, F = 19, U = 2 * W + 1, V = 15, H = 3, G = 258, Y = G + H + 1, J = 32, re = 42, le = 69, ie = 73, xe = 91, se = 103, ce = 113, Ee = 666, be = 1, Le = 2, ae = 3, pe = 4, we = 3;
            function Ge(I, ge) {
              return I.msg = h[ge], ge;
            }
            function We(I) {
              return (I << 1) - (I > 4 ? 9 : 0);
            }
            function je(I) {
              for (var ge = I.length; --ge >= 0; )
                I[ge] = 0;
            }
            function Fe(I) {
              var ge = I.state, ve = ge.pending;
              ve > I.avail_out && (ve = I.avail_out), ve !== 0 && (v.arraySet(I.output, ge.pending_buf, ge.pending_out, ve, I.next_out), I.next_out += ve, ge.pending_out += ve, I.total_out += ve, I.avail_out -= ve, ge.pending -= ve, ge.pending === 0 && (ge.pending_out = 0));
            }
            function ze(I, ge) {
              M._tr_flush_block(I, I.block_start >= 0 ? I.block_start : -1, I.strstart - I.block_start, ge), I.block_start = I.strstart, Fe(I.strm);
            }
            function Be(I, ge) {
              I.pending_buf[I.pending++] = ge;
            }
            function Ie(I, ge) {
              I.pending_buf[I.pending++] = ge >>> 8 & 255, I.pending_buf[I.pending++] = ge & 255;
            }
            function Te(I, ge, ve, $) {
              var ne = I.avail_in;
              return ne > $ && (ne = $), ne === 0 ? 0 : (I.avail_in -= ne, v.arraySet(ge, I.input, I.next_in, ne, ve), I.state.wrap === 1 ? I.adler = E(I.adler, ge, ne, ve) : I.state.wrap === 2 && (I.adler = A(I.adler, ge, ne, ve)), I.next_in += ne, I.total_in += ne, ne);
            }
            function Re(I, ge) {
              var ve = I.max_chain_length, $ = I.strstart, ne, ye, Ze = I.prev_length, Ke = I.nice_match, Ve = I.strstart > I.w_size - Y ? I.strstart - (I.w_size - Y) : 0, qe = I.window, Et = I.w_mask, nt = I.prev, rt = I.strstart + G, tt = qe[$ + Ze - 1], yt = qe[$ + Ze];
              I.prev_length >= I.good_match && (ve >>= 2), Ke > I.lookahead && (Ke = I.lookahead);
              do
                if (ne = ge, !(qe[ne + Ze] !== yt || qe[ne + Ze - 1] !== tt || qe[ne] !== qe[$] || qe[++ne] !== qe[$ + 1])) {
                  $ += 2, ne++;
                  do
                    ;
                  while (qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && qe[++$] === qe[++ne] && $ < rt);
                  if (ye = G - (rt - $), $ = rt - G, ye > Ze) {
                    if (I.match_start = ge, Ze = ye, ye >= Ke)
                      break;
                    tt = qe[$ + Ze - 1], yt = qe[$ + Ze];
                  }
                }
              while ((ge = nt[ge & Et]) > Ve && --ve !== 0);
              return Ze <= I.lookahead ? Ze : I.lookahead;
            }
            function ke(I) {
              var ge = I.w_size, ve, $, ne, ye, Ze;
              do {
                if (ye = I.window_size - I.lookahead - I.strstart, I.strstart >= ge + (ge - Y)) {
                  v.arraySet(I.window, I.window, ge, ge, 0), I.match_start -= ge, I.strstart -= ge, I.block_start -= ge, $ = I.hash_size, ve = $;
                  do
                    ne = I.head[--ve], I.head[ve] = ne >= ge ? ne - ge : 0;
                  while (--$);
                  $ = ge, ve = $;
                  do
                    ne = I.prev[--ve], I.prev[ve] = ne >= ge ? ne - ge : 0;
                  while (--$);
                  ye += ge;
                }
                if (I.strm.avail_in === 0)
                  break;
                if ($ = Te(I.strm, I.window, I.strstart + I.lookahead, ye), I.lookahead += $, I.lookahead + I.insert >= H)
                  for (Ze = I.strstart - I.insert, I.ins_h = I.window[Ze], I.ins_h = (I.ins_h << I.hash_shift ^ I.window[Ze + 1]) & I.hash_mask; I.insert && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[Ze + H - 1]) & I.hash_mask, I.prev[Ze & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = Ze, Ze++, I.insert--, !(I.lookahead + I.insert < H)); )
                    ;
              } while (I.lookahead < Y && I.strm.avail_in !== 0);
            }
            function Ne(I, ge) {
              var ve = 65535;
              for (ve > I.pending_buf_size - 5 && (ve = I.pending_buf_size - 5); ; ) {
                if (I.lookahead <= 1) {
                  if (ke(I), I.lookahead === 0 && ge === g)
                    return be;
                  if (I.lookahead === 0)
                    break;
                }
                I.strstart += I.lookahead, I.lookahead = 0;
                var $ = I.block_start + ve;
                if ((I.strstart === 0 || I.strstart >= $) && (I.lookahead = I.strstart - $, I.strstart = $, ze(I, !1), I.strm.avail_out === 0) || I.strstart - I.block_start >= I.w_size - Y && (ze(I, !1), I.strm.avail_out === 0))
                  return be;
              }
              return I.insert = 0, ge === S ? (ze(I, !0), I.strm.avail_out === 0 ? ae : pe) : (I.strstart > I.block_start && (ze(I, !1), I.strm.avail_out === 0), be);
            }
            function X(I, ge) {
              for (var ve, $; ; ) {
                if (I.lookahead < Y) {
                  if (ke(I), I.lookahead < Y && ge === g)
                    return be;
                  if (I.lookahead === 0)
                    break;
                }
                if (ve = 0, I.lookahead >= H && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + H - 1]) & I.hash_mask, ve = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), ve !== 0 && I.strstart - ve <= I.w_size - Y && (I.match_length = Re(I, ve)), I.match_length >= H)
                  if ($ = M._tr_tally(I, I.strstart - I.match_start, I.match_length - H), I.lookahead -= I.match_length, I.match_length <= I.max_lazy_match && I.lookahead >= H) {
                    I.match_length--;
                    do
                      I.strstart++, I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + H - 1]) & I.hash_mask, ve = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart;
                    while (--I.match_length !== 0);
                    I.strstart++;
                  } else
                    I.strstart += I.match_length, I.match_length = 0, I.ins_h = I.window[I.strstart], I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + 1]) & I.hash_mask;
                else
                  $ = M._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++;
                if ($ && (ze(I, !1), I.strm.avail_out === 0))
                  return be;
              }
              return I.insert = I.strstart < H - 1 ? I.strstart : H - 1, ge === S ? (ze(I, !0), I.strm.avail_out === 0 ? ae : pe) : I.last_lit && (ze(I, !1), I.strm.avail_out === 0) ? be : Le;
            }
            function K(I, ge) {
              for (var ve, $, ne; ; ) {
                if (I.lookahead < Y) {
                  if (ke(I), I.lookahead < Y && ge === g)
                    return be;
                  if (I.lookahead === 0)
                    break;
                }
                if (ve = 0, I.lookahead >= H && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + H - 1]) & I.hash_mask, ve = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart), I.prev_length = I.match_length, I.prev_match = I.match_start, I.match_length = H - 1, ve !== 0 && I.prev_length < I.max_lazy_match && I.strstart - ve <= I.w_size - Y && (I.match_length = Re(I, ve), I.match_length <= 5 && (I.strategy === l || I.match_length === H && I.strstart - I.match_start > 4096) && (I.match_length = H - 1)), I.prev_length >= H && I.match_length <= I.prev_length) {
                  ne = I.strstart + I.lookahead - H, $ = M._tr_tally(I, I.strstart - 1 - I.prev_match, I.prev_length - H), I.lookahead -= I.prev_length - 1, I.prev_length -= 2;
                  do
                    ++I.strstart <= ne && (I.ins_h = (I.ins_h << I.hash_shift ^ I.window[I.strstart + H - 1]) & I.hash_mask, ve = I.prev[I.strstart & I.w_mask] = I.head[I.ins_h], I.head[I.ins_h] = I.strstart);
                  while (--I.prev_length !== 0);
                  if (I.match_available = 0, I.match_length = H - 1, I.strstart++, $ && (ze(I, !1), I.strm.avail_out === 0))
                    return be;
                } else if (I.match_available) {
                  if ($ = M._tr_tally(I, 0, I.window[I.strstart - 1]), $ && ze(I, !1), I.strstart++, I.lookahead--, I.strm.avail_out === 0)
                    return be;
                } else
                  I.match_available = 1, I.strstart++, I.lookahead--;
              }
              return I.match_available && ($ = M._tr_tally(I, 0, I.window[I.strstart - 1]), I.match_available = 0), I.insert = I.strstart < H - 1 ? I.strstart : H - 1, ge === S ? (ze(I, !0), I.strm.avail_out === 0 ? ae : pe) : I.last_lit && (ze(I, !1), I.strm.avail_out === 0) ? be : Le;
            }
            function q(I, ge) {
              for (var ve, $, ne, ye, Ze = I.window; ; ) {
                if (I.lookahead <= G) {
                  if (ke(I), I.lookahead <= G && ge === g)
                    return be;
                  if (I.lookahead === 0)
                    break;
                }
                if (I.match_length = 0, I.lookahead >= H && I.strstart > 0 && (ne = I.strstart - 1, $ = Ze[ne], $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne])) {
                  ye = I.strstart + G;
                  do
                    ;
                  while ($ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && $ === Ze[++ne] && ne < ye);
                  I.match_length = G - (ye - ne), I.match_length > I.lookahead && (I.match_length = I.lookahead);
                }
                if (I.match_length >= H ? (ve = M._tr_tally(I, 1, I.match_length - H), I.lookahead -= I.match_length, I.strstart += I.match_length, I.match_length = 0) : (ve = M._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++), ve && (ze(I, !1), I.strm.avail_out === 0))
                  return be;
              }
              return I.insert = 0, ge === S ? (ze(I, !0), I.strm.avail_out === 0 ? ae : pe) : I.last_lit && (ze(I, !1), I.strm.avail_out === 0) ? be : Le;
            }
            function fe(I, ge) {
              for (var ve; ; ) {
                if (I.lookahead === 0 && (ke(I), I.lookahead === 0)) {
                  if (ge === g)
                    return be;
                  break;
                }
                if (I.match_length = 0, ve = M._tr_tally(I, 0, I.window[I.strstart]), I.lookahead--, I.strstart++, ve && (ze(I, !1), I.strm.avail_out === 0))
                  return be;
              }
              return I.insert = 0, ge === S ? (ze(I, !0), I.strm.avail_out === 0 ? ae : pe) : I.last_lit && (ze(I, !1), I.strm.avail_out === 0) ? be : Le;
            }
            function ue(I, ge, ve, $, ne) {
              this.good_length = I, this.max_lazy = ge, this.nice_length = ve, this.max_chain = $, this.func = ne;
            }
            var De;
            De = [
              /*      good lazy nice chain */
              new ue(0, 0, 0, 0, Ne),
              /* 0 store only */
              new ue(4, 4, 8, 4, X),
              /* 1 max speed, no lazy matches */
              new ue(4, 5, 16, 8, X),
              /* 2 */
              new ue(4, 6, 32, 32, X),
              /* 3 */
              new ue(4, 4, 16, 16, K),
              /* 4 lazy matches */
              new ue(8, 16, 32, 32, K),
              /* 5 */
              new ue(8, 16, 128, 128, K),
              /* 6 */
              new ue(8, 32, 128, 256, K),
              /* 7 */
              new ue(32, 128, 258, 1024, K),
              /* 8 */
              new ue(32, 258, 258, 4096, K)
              /* 9 max compression */
            ];
            function Se(I) {
              I.window_size = 2 * I.w_size, je(I.head), I.max_lazy_match = De[I.level].max_lazy, I.good_match = De[I.level].good_length, I.nice_match = De[I.level].nice_length, I.max_chain_length = De[I.level].max_chain, I.strstart = 0, I.block_start = 0, I.lookahead = 0, I.insert = 0, I.match_length = I.prev_length = H - 1, I.match_available = 0, I.ins_h = 0;
            }
            function Z() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = D, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new v.Buf16(U * 2), this.dyn_dtree = new v.Buf16((2 * k + 1) * 2), this.bl_tree = new v.Buf16((2 * F + 1) * 2), je(this.dyn_ltree), je(this.dyn_dtree), je(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new v.Buf16(V + 1), this.heap = new v.Buf16(2 * W + 1), je(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new v.Buf16(2 * W + 1), je(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function de(I) {
              var ge;
              return !I || !I.state ? Ge(I, t) : (I.total_in = I.total_out = 0, I.data_type = x, ge = I.state, ge.pending = 0, ge.pending_out = 0, ge.wrap < 0 && (ge.wrap = -ge.wrap), ge.status = ge.wrap ? re : ce, I.adler = ge.wrap === 2 ? 0 : 1, ge.last_flush = g, M._tr_init(ge), b);
            }
            function me(I) {
              var ge = de(I);
              return ge === b && Se(I.state), ge;
            }
            function Pe(I, ge) {
              return !I || !I.state || I.state.wrap !== 2 ? t : (I.state.gzhead = ge, b);
            }
            function oe(I, ge, ve, $, ne, ye) {
              if (!I)
                return t;
              var Ze = 1;
              if (ge === o && (ge = 6), $ < 0 ? (Ze = 0, $ = -$) : $ > 15 && (Ze = 2, $ -= 16), ne < 1 || ne > O || ve !== D || $ < 8 || $ > 15 || ge < 0 || ge > 9 || ye < 0 || ye > a)
                return Ge(I, t);
              $ === 8 && ($ = 9);
              var Ke = new Z();
              return I.state = Ke, Ke.strm = I, Ke.wrap = Ze, Ke.gzhead = null, Ke.w_bits = $, Ke.w_size = 1 << Ke.w_bits, Ke.w_mask = Ke.w_size - 1, Ke.hash_bits = ne + 7, Ke.hash_size = 1 << Ke.hash_bits, Ke.hash_mask = Ke.hash_size - 1, Ke.hash_shift = ~~((Ke.hash_bits + H - 1) / H), Ke.window = new v.Buf8(Ke.w_size * 2), Ke.head = new v.Buf16(Ke.hash_size), Ke.prev = new v.Buf16(Ke.w_size), Ke.lit_bufsize = 1 << ne + 6, Ke.pending_buf_size = Ke.lit_bufsize * 4, Ke.pending_buf = new v.Buf8(Ke.pending_buf_size), Ke.d_buf = 1 * Ke.lit_bufsize, Ke.l_buf = 3 * Ke.lit_bufsize, Ke.level = ge, Ke.strategy = ye, Ke.method = ve, me(I);
            }
            function Ce(I, ge) {
              return oe(I, ge, D, R, z, p);
            }
            function j(I, ge) {
              var ve, $, ne, ye;
              if (!I || !I.state || ge > y || ge < 0)
                return I ? Ge(I, t) : t;
              if ($ = I.state, !I.output || !I.input && I.avail_in !== 0 || $.status === Ee && ge !== S)
                return Ge(I, I.avail_out === 0 ? u : t);
              if ($.strm = I, ve = $.last_flush, $.last_flush = ge, $.status === re)
                if ($.wrap === 2)
                  I.adler = 0, Be($, 31), Be($, 139), Be($, 8), $.gzhead ? (Be(
                    $,
                    ($.gzhead.text ? 1 : 0) + ($.gzhead.hcrc ? 2 : 0) + ($.gzhead.extra ? 4 : 0) + ($.gzhead.name ? 8 : 0) + ($.gzhead.comment ? 16 : 0)
                  ), Be($, $.gzhead.time & 255), Be($, $.gzhead.time >> 8 & 255), Be($, $.gzhead.time >> 16 & 255), Be($, $.gzhead.time >> 24 & 255), Be($, $.level === 9 ? 2 : $.strategy >= e || $.level < 2 ? 4 : 0), Be($, $.gzhead.os & 255), $.gzhead.extra && $.gzhead.extra.length && (Be($, $.gzhead.extra.length & 255), Be($, $.gzhead.extra.length >> 8 & 255)), $.gzhead.hcrc && (I.adler = A(I.adler, $.pending_buf, $.pending, 0)), $.gzindex = 0, $.status = le) : (Be($, 0), Be($, 0), Be($, 0), Be($, 0), Be($, 0), Be($, $.level === 9 ? 2 : $.strategy >= e || $.level < 2 ? 4 : 0), Be($, we), $.status = ce);
                else {
                  var Ze = D + ($.w_bits - 8 << 4) << 8, Ke = -1;
                  $.strategy >= e || $.level < 2 ? Ke = 0 : $.level < 6 ? Ke = 1 : $.level === 6 ? Ke = 2 : Ke = 3, Ze |= Ke << 6, $.strstart !== 0 && (Ze |= J), Ze += 31 - Ze % 31, $.status = ce, Ie($, Ze), $.strstart !== 0 && (Ie($, I.adler >>> 16), Ie($, I.adler & 65535)), I.adler = 1;
                }
              if ($.status === le)
                if ($.gzhead.extra) {
                  for (ne = $.pending; $.gzindex < ($.gzhead.extra.length & 65535) && !($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), Fe(I), ne = $.pending, $.pending === $.pending_buf_size)); )
                    Be($, $.gzhead.extra[$.gzindex] & 255), $.gzindex++;
                  $.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), $.gzindex === $.gzhead.extra.length && ($.gzindex = 0, $.status = ie);
                } else
                  $.status = ie;
              if ($.status === ie)
                if ($.gzhead.name) {
                  ne = $.pending;
                  do {
                    if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), Fe(I), ne = $.pending, $.pending === $.pending_buf_size)) {
                      ye = 1;
                      break;
                    }
                    $.gzindex < $.gzhead.name.length ? ye = $.gzhead.name.charCodeAt($.gzindex++) & 255 : ye = 0, Be($, ye);
                  } while (ye !== 0);
                  $.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), ye === 0 && ($.gzindex = 0, $.status = xe);
                } else
                  $.status = xe;
              if ($.status === xe)
                if ($.gzhead.comment) {
                  ne = $.pending;
                  do {
                    if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), Fe(I), ne = $.pending, $.pending === $.pending_buf_size)) {
                      ye = 1;
                      break;
                    }
                    $.gzindex < $.gzhead.comment.length ? ye = $.gzhead.comment.charCodeAt($.gzindex++) & 255 : ye = 0, Be($, ye);
                  } while (ye !== 0);
                  $.gzhead.hcrc && $.pending > ne && (I.adler = A(I.adler, $.pending_buf, $.pending - ne, ne)), ye === 0 && ($.status = se);
                } else
                  $.status = se;
              if ($.status === se && ($.gzhead.hcrc ? ($.pending + 2 > $.pending_buf_size && Fe(I), $.pending + 2 <= $.pending_buf_size && (Be($, I.adler & 255), Be($, I.adler >> 8 & 255), I.adler = 0, $.status = ce)) : $.status = ce), $.pending !== 0) {
                if (Fe(I), I.avail_out === 0)
                  return $.last_flush = -1, b;
              } else if (I.avail_in === 0 && We(ge) <= We(ve) && ge !== S)
                return Ge(I, u);
              if ($.status === Ee && I.avail_in !== 0)
                return Ge(I, u);
              if (I.avail_in !== 0 || $.lookahead !== 0 || ge !== g && $.status !== Ee) {
                var Ve = $.strategy === e ? fe($, ge) : $.strategy === n ? q($, ge) : De[$.level].func($, ge);
                if ((Ve === ae || Ve === pe) && ($.status = Ee), Ve === be || Ve === ae)
                  return I.avail_out === 0 && ($.last_flush = -1), b;
                if (Ve === Le && (ge === C ? M._tr_align($) : ge !== y && (M._tr_stored_block($, 0, 0, !1), ge === c && (je($.head), $.lookahead === 0 && ($.strstart = 0, $.block_start = 0, $.insert = 0))), Fe(I), I.avail_out === 0))
                  return $.last_flush = -1, b;
              }
              return ge !== S ? b : $.wrap <= 0 ? w : ($.wrap === 2 ? (Be($, I.adler & 255), Be($, I.adler >> 8 & 255), Be($, I.adler >> 16 & 255), Be($, I.adler >> 24 & 255), Be($, I.total_in & 255), Be($, I.total_in >> 8 & 255), Be($, I.total_in >> 16 & 255), Be($, I.total_in >> 24 & 255)) : (Ie($, I.adler >>> 16), Ie($, I.adler & 65535)), Fe(I), $.wrap > 0 && ($.wrap = -$.wrap), $.pending !== 0 ? b : w);
            }
            function Oe(I) {
              var ge;
              return !I || !I.state ? t : (ge = I.state.status, ge !== re && ge !== le && ge !== ie && ge !== xe && ge !== se && ge !== ce && ge !== Ee ? Ge(I, t) : (I.state = null, ge === ce ? Ge(I, r) : b));
            }
            function He(I, ge) {
              var ve = ge.length, $, ne, ye, Ze, Ke, Ve, qe, Et;
              if (!I || !I.state || ($ = I.state, Ze = $.wrap, Ze === 2 || Ze === 1 && $.status !== re || $.lookahead))
                return t;
              for (Ze === 1 && (I.adler = E(I.adler, ge, ve, 0)), $.wrap = 0, ve >= $.w_size && (Ze === 0 && (je($.head), $.strstart = 0, $.block_start = 0, $.insert = 0), Et = new v.Buf8($.w_size), v.arraySet(Et, ge, ve - $.w_size, $.w_size, 0), ge = Et, ve = $.w_size), Ke = I.avail_in, Ve = I.next_in, qe = I.input, I.avail_in = ve, I.next_in = 0, I.input = ge, ke($); $.lookahead >= H; ) {
                ne = $.strstart, ye = $.lookahead - (H - 1);
                do
                  $.ins_h = ($.ins_h << $.hash_shift ^ $.window[ne + H - 1]) & $.hash_mask, $.prev[ne & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = ne, ne++;
                while (--ye);
                $.strstart = ne, $.lookahead = H - 1, ke($);
              }
              return $.strstart += $.lookahead, $.block_start = $.strstart, $.insert = $.lookahead, $.lookahead = 0, $.match_length = $.prev_length = H - 1, $.match_available = 0, I.next_in = Ve, I.input = qe, I.avail_in = Ke, $.wrap = Ze, b;
            }
            _.deflateInit = Ce, _.deflateInit2 = oe, _.deflateReset = me, _.deflateResetKeep = de, _.deflateSetHeader = Pe, _.deflate = j, _.deflateEnd = Oe, _.deflateSetDictionary = He, _.deflateInfo = "pako deflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js ***!
            \*********************************************************************/
          /***/
          (P) => {
            function _() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            P.exports = _;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js ***!
            \********************************************************************/
          /***/
          (P) => {
            var _ = 30, s = 12;
            P.exports = function(M, E) {
              var A, h, g, C, c, S, y, b, w, t, r, u, o, l, e, n, a, p, x, D, O, R, z, T, B;
              A = M.state, h = M.next_in, T = M.input, g = h + (M.avail_in - 5), C = M.next_out, B = M.output, c = C - (E - M.avail_out), S = C + (M.avail_out - 257), y = A.dmax, b = A.wsize, w = A.whave, t = A.wnext, r = A.window, u = A.hold, o = A.bits, l = A.lencode, e = A.distcode, n = (1 << A.lenbits) - 1, a = (1 << A.distbits) - 1;
              e:
                do {
                  o < 15 && (u += T[h++] << o, o += 8, u += T[h++] << o, o += 8), p = l[u & n];
                  t:
                    for (; ; ) {
                      if (x = p >>> 24, u >>>= x, o -= x, x = p >>> 16 & 255, x === 0)
                        B[C++] = p & 65535;
                      else if (x & 16) {
                        D = p & 65535, x &= 15, x && (o < x && (u += T[h++] << o, o += 8), D += u & (1 << x) - 1, u >>>= x, o -= x), o < 15 && (u += T[h++] << o, o += 8, u += T[h++] << o, o += 8), p = e[u & a];
                        i:
                          for (; ; ) {
                            if (x = p >>> 24, u >>>= x, o -= x, x = p >>> 16 & 255, x & 16) {
                              if (O = p & 65535, x &= 15, o < x && (u += T[h++] << o, o += 8, o < x && (u += T[h++] << o, o += 8)), O += u & (1 << x) - 1, O > y) {
                                M.msg = "invalid distance too far back", A.mode = _;
                                break e;
                              }
                              if (u >>>= x, o -= x, x = C - c, O > x) {
                                if (x = O - x, x > w && A.sane) {
                                  M.msg = "invalid distance too far back", A.mode = _;
                                  break e;
                                }
                                if (R = 0, z = r, t === 0) {
                                  if (R += b - x, x < D) {
                                    D -= x;
                                    do
                                      B[C++] = r[R++];
                                    while (--x);
                                    R = C - O, z = B;
                                  }
                                } else if (t < x) {
                                  if (R += b + t - x, x -= t, x < D) {
                                    D -= x;
                                    do
                                      B[C++] = r[R++];
                                    while (--x);
                                    if (R = 0, t < D) {
                                      x = t, D -= x;
                                      do
                                        B[C++] = r[R++];
                                      while (--x);
                                      R = C - O, z = B;
                                    }
                                  }
                                } else if (R += t - x, x < D) {
                                  D -= x;
                                  do
                                    B[C++] = r[R++];
                                  while (--x);
                                  R = C - O, z = B;
                                }
                                for (; D > 2; )
                                  B[C++] = z[R++], B[C++] = z[R++], B[C++] = z[R++], D -= 3;
                                D && (B[C++] = z[R++], D > 1 && (B[C++] = z[R++]));
                              } else {
                                R = C - O;
                                do
                                  B[C++] = B[R++], B[C++] = B[R++], B[C++] = B[R++], D -= 3;
                                while (D > 2);
                                D && (B[C++] = B[R++], D > 1 && (B[C++] = B[R++]));
                              }
                            } else if (x & 64) {
                              M.msg = "invalid distance code", A.mode = _;
                              break e;
                            } else {
                              p = e[(p & 65535) + (u & (1 << x) - 1)];
                              continue i;
                            }
                            break;
                          }
                      } else if (x & 64)
                        if (x & 32) {
                          A.mode = s;
                          break e;
                        } else {
                          M.msg = "invalid literal/length code", A.mode = _;
                          break e;
                        }
                      else {
                        p = l[(p & 65535) + (u & (1 << x) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (h < g && C < S);
              D = o >> 3, h -= D, o -= D << 3, u &= (1 << o) - 1, M.next_in = h, M.next_out = C, M.avail_in = h < g ? 5 + (g - h) : 5 - (h - g), M.avail_out = C < S ? 257 + (S - C) : 257 - (C - S), A.hold = u, A.bits = o;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js ***!
            \********************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), M = s(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), E = s(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), A = s(
              /*! ./inffast */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js"
            ), h = s(
              /*! ./inftrees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js"
            ), g = 0, C = 1, c = 2, S = 4, y = 5, b = 6, w = 0, t = 1, r = 2, u = -2, o = -3, l = -4, e = -5, n = 8, a = 1, p = 2, x = 3, D = 4, O = 5, R = 6, z = 7, T = 8, B = 9, W = 10, k = 11, F = 12, U = 13, V = 14, H = 15, G = 16, Y = 17, J = 18, re = 19, le = 20, ie = 21, xe = 22, se = 23, ce = 24, Ee = 25, be = 26, Le = 27, ae = 28, pe = 29, we = 30, Ge = 31, We = 32, je = 852, Fe = 592, ze = 15, Be = ze;
            function Ie(oe) {
              return (oe >>> 24 & 255) + (oe >>> 8 & 65280) + ((oe & 65280) << 8) + ((oe & 255) << 24);
            }
            function Te() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new v.Buf16(320), this.work = new v.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function Re(oe) {
              var Ce;
              return !oe || !oe.state ? u : (Ce = oe.state, oe.total_in = oe.total_out = Ce.total = 0, oe.msg = "", Ce.wrap && (oe.adler = Ce.wrap & 1), Ce.mode = a, Ce.last = 0, Ce.havedict = 0, Ce.dmax = 32768, Ce.head = null, Ce.hold = 0, Ce.bits = 0, Ce.lencode = Ce.lendyn = new v.Buf32(je), Ce.distcode = Ce.distdyn = new v.Buf32(Fe), Ce.sane = 1, Ce.back = -1, w);
            }
            function ke(oe) {
              var Ce;
              return !oe || !oe.state ? u : (Ce = oe.state, Ce.wsize = 0, Ce.whave = 0, Ce.wnext = 0, Re(oe));
            }
            function Ne(oe, Ce) {
              var j, Oe;
              return !oe || !oe.state || (Oe = oe.state, Ce < 0 ? (j = 0, Ce = -Ce) : (j = (Ce >> 4) + 1, Ce < 48 && (Ce &= 15)), Ce && (Ce < 8 || Ce > 15)) ? u : (Oe.window !== null && Oe.wbits !== Ce && (Oe.window = null), Oe.wrap = j, Oe.wbits = Ce, ke(oe));
            }
            function X(oe, Ce) {
              var j, Oe;
              return oe ? (Oe = new Te(), oe.state = Oe, Oe.window = null, j = Ne(oe, Ce), j !== w && (oe.state = null), j) : u;
            }
            function K(oe) {
              return X(oe, Be);
            }
            var q = !0, fe, ue;
            function De(oe) {
              if (q) {
                var Ce;
                for (fe = new v.Buf32(512), ue = new v.Buf32(32), Ce = 0; Ce < 144; )
                  oe.lens[Ce++] = 8;
                for (; Ce < 256; )
                  oe.lens[Ce++] = 9;
                for (; Ce < 280; )
                  oe.lens[Ce++] = 7;
                for (; Ce < 288; )
                  oe.lens[Ce++] = 8;
                for (h(C, oe.lens, 0, 288, fe, 0, oe.work, { bits: 9 }), Ce = 0; Ce < 32; )
                  oe.lens[Ce++] = 5;
                h(c, oe.lens, 0, 32, ue, 0, oe.work, { bits: 5 }), q = !1;
              }
              oe.lencode = fe, oe.lenbits = 9, oe.distcode = ue, oe.distbits = 5;
            }
            function Se(oe, Ce, j, Oe) {
              var He, I = oe.state;
              return I.window === null && (I.wsize = 1 << I.wbits, I.wnext = 0, I.whave = 0, I.window = new v.Buf8(I.wsize)), Oe >= I.wsize ? (v.arraySet(I.window, Ce, j - I.wsize, I.wsize, 0), I.wnext = 0, I.whave = I.wsize) : (He = I.wsize - I.wnext, He > Oe && (He = Oe), v.arraySet(I.window, Ce, j - Oe, He, I.wnext), Oe -= He, Oe ? (v.arraySet(I.window, Ce, j - Oe, Oe, 0), I.wnext = Oe, I.whave = I.wsize) : (I.wnext += He, I.wnext === I.wsize && (I.wnext = 0), I.whave < I.wsize && (I.whave += He))), 0;
            }
            function Z(oe, Ce) {
              var j, Oe, He, I, ge, ve, $, ne, ye, Ze, Ke, Ve, qe, Et, nt = 0, rt, tt, yt, _t, It, Ot, pt, mt, gt = new v.Buf8(4), Ct, Mt, Wt = (
                /* permutation of code lengths */
                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
              );
              if (!oe || !oe.state || !oe.output || !oe.input && oe.avail_in !== 0)
                return u;
              j = oe.state, j.mode === F && (j.mode = U), ge = oe.next_out, He = oe.output, $ = oe.avail_out, I = oe.next_in, Oe = oe.input, ve = oe.avail_in, ne = j.hold, ye = j.bits, Ze = ve, Ke = $, mt = w;
              e:
                for (; ; )
                  switch (j.mode) {
                    case a:
                      if (j.wrap === 0) {
                        j.mode = U;
                        break;
                      }
                      for (; ye < 16; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if (j.wrap & 2 && ne === 35615) {
                        j.check = 0, gt[0] = ne & 255, gt[1] = ne >>> 8 & 255, j.check = E(j.check, gt, 2, 0), ne = 0, ye = 0, j.mode = p;
                        break;
                      }
                      if (j.flags = 0, j.head && (j.head.done = !1), !(j.wrap & 1) || /* check if zlib header allowed */
                      (((ne & 255) << 8) + (ne >> 8)) % 31) {
                        oe.msg = "incorrect header check", j.mode = we;
                        break;
                      }
                      if ((ne & 15) !== n) {
                        oe.msg = "unknown compression method", j.mode = we;
                        break;
                      }
                      if (ne >>>= 4, ye -= 4, pt = (ne & 15) + 8, j.wbits === 0)
                        j.wbits = pt;
                      else if (pt > j.wbits) {
                        oe.msg = "invalid window size", j.mode = we;
                        break;
                      }
                      j.dmax = 1 << pt, oe.adler = j.check = 1, j.mode = ne & 512 ? W : F, ne = 0, ye = 0;
                      break;
                    case p:
                      for (; ye < 16; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if (j.flags = ne, (j.flags & 255) !== n) {
                        oe.msg = "unknown compression method", j.mode = we;
                        break;
                      }
                      if (j.flags & 57344) {
                        oe.msg = "unknown header flags set", j.mode = we;
                        break;
                      }
                      j.head && (j.head.text = ne >> 8 & 1), j.flags & 512 && (gt[0] = ne & 255, gt[1] = ne >>> 8 & 255, j.check = E(j.check, gt, 2, 0)), ne = 0, ye = 0, j.mode = x;
                    case x:
                      for (; ye < 32; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      j.head && (j.head.time = ne), j.flags & 512 && (gt[0] = ne & 255, gt[1] = ne >>> 8 & 255, gt[2] = ne >>> 16 & 255, gt[3] = ne >>> 24 & 255, j.check = E(j.check, gt, 4, 0)), ne = 0, ye = 0, j.mode = D;
                    case D:
                      for (; ye < 16; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      j.head && (j.head.xflags = ne & 255, j.head.os = ne >> 8), j.flags & 512 && (gt[0] = ne & 255, gt[1] = ne >>> 8 & 255, j.check = E(j.check, gt, 2, 0)), ne = 0, ye = 0, j.mode = O;
                    case O:
                      if (j.flags & 1024) {
                        for (; ye < 16; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        j.length = ne, j.head && (j.head.extra_len = ne), j.flags & 512 && (gt[0] = ne & 255, gt[1] = ne >>> 8 & 255, j.check = E(j.check, gt, 2, 0)), ne = 0, ye = 0;
                      } else
                        j.head && (j.head.extra = null);
                      j.mode = R;
                    case R:
                      if (j.flags & 1024 && (Ve = j.length, Ve > ve && (Ve = ve), Ve && (j.head && (pt = j.head.extra_len - j.length, j.head.extra || (j.head.extra = new Array(j.head.extra_len)), v.arraySet(
                        j.head.extra,
                        Oe,
                        I,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        Ve,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        pt
                      )), j.flags & 512 && (j.check = E(j.check, Oe, Ve, I)), ve -= Ve, I += Ve, j.length -= Ve), j.length))
                        break e;
                      j.length = 0, j.mode = z;
                    case z:
                      if (j.flags & 2048) {
                        if (ve === 0)
                          break e;
                        Ve = 0;
                        do
                          pt = Oe[I + Ve++], j.head && pt && j.length < 65536 && (j.head.name += String.fromCharCode(pt));
                        while (pt && Ve < ve);
                        if (j.flags & 512 && (j.check = E(j.check, Oe, Ve, I)), ve -= Ve, I += Ve, pt)
                          break e;
                      } else
                        j.head && (j.head.name = null);
                      j.length = 0, j.mode = T;
                    case T:
                      if (j.flags & 4096) {
                        if (ve === 0)
                          break e;
                        Ve = 0;
                        do
                          pt = Oe[I + Ve++], j.head && pt && j.length < 65536 && (j.head.comment += String.fromCharCode(pt));
                        while (pt && Ve < ve);
                        if (j.flags & 512 && (j.check = E(j.check, Oe, Ve, I)), ve -= Ve, I += Ve, pt)
                          break e;
                      } else
                        j.head && (j.head.comment = null);
                      j.mode = B;
                    case B:
                      if (j.flags & 512) {
                        for (; ye < 16; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        if (ne !== (j.check & 65535)) {
                          oe.msg = "header crc mismatch", j.mode = we;
                          break;
                        }
                        ne = 0, ye = 0;
                      }
                      j.head && (j.head.hcrc = j.flags >> 9 & 1, j.head.done = !0), oe.adler = j.check = 0, j.mode = F;
                      break;
                    case W:
                      for (; ye < 32; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      oe.adler = j.check = Ie(ne), ne = 0, ye = 0, j.mode = k;
                    case k:
                      if (j.havedict === 0)
                        return oe.next_out = ge, oe.avail_out = $, oe.next_in = I, oe.avail_in = ve, j.hold = ne, j.bits = ye, r;
                      oe.adler = j.check = 1, j.mode = F;
                    case F:
                      if (Ce === y || Ce === b)
                        break e;
                    case U:
                      if (j.last) {
                        ne >>>= ye & 7, ye -= ye & 7, j.mode = Le;
                        break;
                      }
                      for (; ye < 3; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      switch (j.last = ne & 1, ne >>>= 1, ye -= 1, ne & 3) {
                        case 0:
                          j.mode = V;
                          break;
                        case 1:
                          if (De(j), j.mode = le, Ce === b) {
                            ne >>>= 2, ye -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          j.mode = Y;
                          break;
                        case 3:
                          oe.msg = "invalid block type", j.mode = we;
                      }
                      ne >>>= 2, ye -= 2;
                      break;
                    case V:
                      for (ne >>>= ye & 7, ye -= ye & 7; ye < 32; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if ((ne & 65535) !== (ne >>> 16 ^ 65535)) {
                        oe.msg = "invalid stored block lengths", j.mode = we;
                        break;
                      }
                      if (j.length = ne & 65535, ne = 0, ye = 0, j.mode = H, Ce === b)
                        break e;
                    case H:
                      j.mode = G;
                    case G:
                      if (Ve = j.length, Ve) {
                        if (Ve > ve && (Ve = ve), Ve > $ && (Ve = $), Ve === 0)
                          break e;
                        v.arraySet(He, Oe, I, Ve, ge), ve -= Ve, I += Ve, $ -= Ve, ge += Ve, j.length -= Ve;
                        break;
                      }
                      j.mode = F;
                      break;
                    case Y:
                      for (; ye < 14; ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if (j.nlen = (ne & 31) + 257, ne >>>= 5, ye -= 5, j.ndist = (ne & 31) + 1, ne >>>= 5, ye -= 5, j.ncode = (ne & 15) + 4, ne >>>= 4, ye -= 4, j.nlen > 286 || j.ndist > 30) {
                        oe.msg = "too many length or distance symbols", j.mode = we;
                        break;
                      }
                      j.have = 0, j.mode = J;
                    case J:
                      for (; j.have < j.ncode; ) {
                        for (; ye < 3; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        j.lens[Wt[j.have++]] = ne & 7, ne >>>= 3, ye -= 3;
                      }
                      for (; j.have < 19; )
                        j.lens[Wt[j.have++]] = 0;
                      if (j.lencode = j.lendyn, j.lenbits = 7, Ct = { bits: j.lenbits }, mt = h(g, j.lens, 0, 19, j.lencode, 0, j.work, Ct), j.lenbits = Ct.bits, mt) {
                        oe.msg = "invalid code lengths set", j.mode = we;
                        break;
                      }
                      j.have = 0, j.mode = re;
                    case re:
                      for (; j.have < j.nlen + j.ndist; ) {
                        for (; nt = j.lencode[ne & (1 << j.lenbits) - 1], rt = nt >>> 24, tt = nt >>> 16 & 255, yt = nt & 65535, !(rt <= ye); ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        if (yt < 16)
                          ne >>>= rt, ye -= rt, j.lens[j.have++] = yt;
                        else {
                          if (yt === 16) {
                            for (Mt = rt + 2; ye < Mt; ) {
                              if (ve === 0)
                                break e;
                              ve--, ne += Oe[I++] << ye, ye += 8;
                            }
                            if (ne >>>= rt, ye -= rt, j.have === 0) {
                              oe.msg = "invalid bit length repeat", j.mode = we;
                              break;
                            }
                            pt = j.lens[j.have - 1], Ve = 3 + (ne & 3), ne >>>= 2, ye -= 2;
                          } else if (yt === 17) {
                            for (Mt = rt + 3; ye < Mt; ) {
                              if (ve === 0)
                                break e;
                              ve--, ne += Oe[I++] << ye, ye += 8;
                            }
                            ne >>>= rt, ye -= rt, pt = 0, Ve = 3 + (ne & 7), ne >>>= 3, ye -= 3;
                          } else {
                            for (Mt = rt + 7; ye < Mt; ) {
                              if (ve === 0)
                                break e;
                              ve--, ne += Oe[I++] << ye, ye += 8;
                            }
                            ne >>>= rt, ye -= rt, pt = 0, Ve = 11 + (ne & 127), ne >>>= 7, ye -= 7;
                          }
                          if (j.have + Ve > j.nlen + j.ndist) {
                            oe.msg = "invalid bit length repeat", j.mode = we;
                            break;
                          }
                          for (; Ve--; )
                            j.lens[j.have++] = pt;
                        }
                      }
                      if (j.mode === we)
                        break;
                      if (j.lens[256] === 0) {
                        oe.msg = "invalid code -- missing end-of-block", j.mode = we;
                        break;
                      }
                      if (j.lenbits = 9, Ct = { bits: j.lenbits }, mt = h(C, j.lens, 0, j.nlen, j.lencode, 0, j.work, Ct), j.lenbits = Ct.bits, mt) {
                        oe.msg = "invalid literal/lengths set", j.mode = we;
                        break;
                      }
                      if (j.distbits = 6, j.distcode = j.distdyn, Ct = { bits: j.distbits }, mt = h(c, j.lens, j.nlen, j.ndist, j.distcode, 0, j.work, Ct), j.distbits = Ct.bits, mt) {
                        oe.msg = "invalid distances set", j.mode = we;
                        break;
                      }
                      if (j.mode = le, Ce === b)
                        break e;
                    case le:
                      j.mode = ie;
                    case ie:
                      if (ve >= 6 && $ >= 258) {
                        oe.next_out = ge, oe.avail_out = $, oe.next_in = I, oe.avail_in = ve, j.hold = ne, j.bits = ye, A(oe, Ke), ge = oe.next_out, He = oe.output, $ = oe.avail_out, I = oe.next_in, Oe = oe.input, ve = oe.avail_in, ne = j.hold, ye = j.bits, j.mode === F && (j.back = -1);
                        break;
                      }
                      for (j.back = 0; nt = j.lencode[ne & (1 << j.lenbits) - 1], rt = nt >>> 24, tt = nt >>> 16 & 255, yt = nt & 65535, !(rt <= ye); ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if (tt && !(tt & 240)) {
                        for (_t = rt, It = tt, Ot = yt; nt = j.lencode[Ot + ((ne & (1 << _t + It) - 1) >> _t)], rt = nt >>> 24, tt = nt >>> 16 & 255, yt = nt & 65535, !(_t + rt <= ye); ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        ne >>>= _t, ye -= _t, j.back += _t;
                      }
                      if (ne >>>= rt, ye -= rt, j.back += rt, j.length = yt, tt === 0) {
                        j.mode = be;
                        break;
                      }
                      if (tt & 32) {
                        j.back = -1, j.mode = F;
                        break;
                      }
                      if (tt & 64) {
                        oe.msg = "invalid literal/length code", j.mode = we;
                        break;
                      }
                      j.extra = tt & 15, j.mode = xe;
                    case xe:
                      if (j.extra) {
                        for (Mt = j.extra; ye < Mt; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        j.length += ne & (1 << j.extra) - 1, ne >>>= j.extra, ye -= j.extra, j.back += j.extra;
                      }
                      j.was = j.length, j.mode = se;
                    case se:
                      for (; nt = j.distcode[ne & (1 << j.distbits) - 1], rt = nt >>> 24, tt = nt >>> 16 & 255, yt = nt & 65535, !(rt <= ye); ) {
                        if (ve === 0)
                          break e;
                        ve--, ne += Oe[I++] << ye, ye += 8;
                      }
                      if (!(tt & 240)) {
                        for (_t = rt, It = tt, Ot = yt; nt = j.distcode[Ot + ((ne & (1 << _t + It) - 1) >> _t)], rt = nt >>> 24, tt = nt >>> 16 & 255, yt = nt & 65535, !(_t + rt <= ye); ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        ne >>>= _t, ye -= _t, j.back += _t;
                      }
                      if (ne >>>= rt, ye -= rt, j.back += rt, tt & 64) {
                        oe.msg = "invalid distance code", j.mode = we;
                        break;
                      }
                      j.offset = yt, j.extra = tt & 15, j.mode = ce;
                    case ce:
                      if (j.extra) {
                        for (Mt = j.extra; ye < Mt; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        j.offset += ne & (1 << j.extra) - 1, ne >>>= j.extra, ye -= j.extra, j.back += j.extra;
                      }
                      if (j.offset > j.dmax) {
                        oe.msg = "invalid distance too far back", j.mode = we;
                        break;
                      }
                      j.mode = Ee;
                    case Ee:
                      if ($ === 0)
                        break e;
                      if (Ve = Ke - $, j.offset > Ve) {
                        if (Ve = j.offset - Ve, Ve > j.whave && j.sane) {
                          oe.msg = "invalid distance too far back", j.mode = we;
                          break;
                        }
                        Ve > j.wnext ? (Ve -= j.wnext, qe = j.wsize - Ve) : qe = j.wnext - Ve, Ve > j.length && (Ve = j.length), Et = j.window;
                      } else
                        Et = He, qe = ge - j.offset, Ve = j.length;
                      Ve > $ && (Ve = $), $ -= Ve, j.length -= Ve;
                      do
                        He[ge++] = Et[qe++];
                      while (--Ve);
                      j.length === 0 && (j.mode = ie);
                      break;
                    case be:
                      if ($ === 0)
                        break e;
                      He[ge++] = j.length, $--, j.mode = ie;
                      break;
                    case Le:
                      if (j.wrap) {
                        for (; ye < 32; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne |= Oe[I++] << ye, ye += 8;
                        }
                        if (Ke -= $, oe.total_out += Ke, j.total += Ke, Ke && (oe.adler = j.check = /*UPDATE(state.check, put - _out, _out);*/
                        j.flags ? E(j.check, He, Ke, ge - Ke) : M(j.check, He, Ke, ge - Ke)), Ke = $, (j.flags ? ne : Ie(ne)) !== j.check) {
                          oe.msg = "incorrect data check", j.mode = we;
                          break;
                        }
                        ne = 0, ye = 0;
                      }
                      j.mode = ae;
                    case ae:
                      if (j.wrap && j.flags) {
                        for (; ye < 32; ) {
                          if (ve === 0)
                            break e;
                          ve--, ne += Oe[I++] << ye, ye += 8;
                        }
                        if (ne !== (j.total & 4294967295)) {
                          oe.msg = "incorrect length check", j.mode = we;
                          break;
                        }
                        ne = 0, ye = 0;
                      }
                      j.mode = pe;
                    case pe:
                      mt = t;
                      break e;
                    case we:
                      mt = o;
                      break e;
                    case Ge:
                      return l;
                    case We:
                    default:
                      return u;
                  }
              return oe.next_out = ge, oe.avail_out = $, oe.next_in = I, oe.avail_in = ve, j.hold = ne, j.bits = ye, (j.wsize || Ke !== oe.avail_out && j.mode < we && (j.mode < Le || Ce !== S)) && Se(oe, oe.output, oe.next_out, Ke - oe.avail_out), Ze -= oe.avail_in, Ke -= oe.avail_out, oe.total_in += Ze, oe.total_out += Ke, j.total += Ke, j.wrap && Ke && (oe.adler = j.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
              j.flags ? E(j.check, He, Ke, oe.next_out - Ke) : M(j.check, He, Ke, oe.next_out - Ke)), oe.data_type = j.bits + (j.last ? 64 : 0) + (j.mode === F ? 128 : 0) + (j.mode === le || j.mode === H ? 256 : 0), (Ze === 0 && Ke === 0 || Ce === S) && mt === w && (mt = e), mt;
            }
            function de(oe) {
              if (!oe || !oe.state)
                return u;
              var Ce = oe.state;
              return Ce.window && (Ce.window = null), oe.state = null, w;
            }
            function me(oe, Ce) {
              var j;
              return !oe || !oe.state || (j = oe.state, !(j.wrap & 2)) ? u : (j.head = Ce, Ce.done = !1, w);
            }
            function Pe(oe, Ce) {
              var j = Ce.length, Oe, He, I;
              return !oe || !oe.state || (Oe = oe.state, Oe.wrap !== 0 && Oe.mode !== k) ? u : Oe.mode === k && (He = 1, He = M(He, Ce, j, 0), He !== Oe.check) ? o : (I = Se(oe, Ce, j, j), I ? (Oe.mode = Ge, l) : (Oe.havedict = 1, w));
            }
            _.inflateReset = ke, _.inflateReset2 = Ne, _.inflateResetKeep = Re, _.inflateInit = K, _.inflateInit2 = X, _.inflate = Z, _.inflateEnd = de, _.inflateGetHeader = me, _.inflateSetDictionary = Pe, _.inflateInfo = "pako inflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js ***!
            \*********************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), M = 15, E = 852, A = 592, h = 0, g = 1, C = 2, c = [
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ], S = [
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ], y = [
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ], b = [
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ];
            P.exports = function(t, r, u, o, l, e, n, a) {
              var p = a.bits, x = 0, D = 0, O = 0, R = 0, z = 0, T = 0, B = 0, W = 0, k = 0, F = 0, U, V, H, G, Y, J = null, re = 0, le, ie = new v.Buf16(M + 1), xe = new v.Buf16(M + 1), se = null, ce = 0, Ee, be, Le;
              for (x = 0; x <= M; x++)
                ie[x] = 0;
              for (D = 0; D < o; D++)
                ie[r[u + D]]++;
              for (z = p, R = M; R >= 1 && ie[R] === 0; R--)
                ;
              if (z > R && (z = R), R === 0)
                return l[e++] = 20971520, l[e++] = 20971520, a.bits = 1, 0;
              for (O = 1; O < R && ie[O] === 0; O++)
                ;
              for (z < O && (z = O), W = 1, x = 1; x <= M; x++)
                if (W <<= 1, W -= ie[x], W < 0)
                  return -1;
              if (W > 0 && (t === h || R !== 1))
                return -1;
              for (xe[1] = 0, x = 1; x < M; x++)
                xe[x + 1] = xe[x] + ie[x];
              for (D = 0; D < o; D++)
                r[u + D] !== 0 && (n[xe[r[u + D]]++] = D);
              if (t === h ? (J = se = n, le = 19) : t === g ? (J = c, re -= 257, se = S, ce -= 257, le = 256) : (J = y, se = b, le = -1), F = 0, D = 0, x = O, Y = e, T = z, B = 0, H = -1, k = 1 << z, G = k - 1, t === g && k > E || t === C && k > A)
                return 1;
              for (; ; ) {
                Ee = x - B, n[D] < le ? (be = 0, Le = n[D]) : n[D] > le ? (be = se[ce + n[D]], Le = J[re + n[D]]) : (be = 96, Le = 0), U = 1 << x - B, V = 1 << T, O = V;
                do
                  V -= U, l[Y + (F >> B) + V] = Ee << 24 | be << 16 | Le | 0;
                while (V !== 0);
                for (U = 1 << x - 1; F & U; )
                  U >>= 1;
                if (U !== 0 ? (F &= U - 1, F += U) : F = 0, D++, --ie[x] === 0) {
                  if (x === R)
                    break;
                  x = r[u + n[D]];
                }
                if (x > z && (F & G) !== H) {
                  for (B === 0 && (B = z), Y += O, T = x - B, W = 1 << T; T + B < R && (W -= ie[T + B], !(W <= 0)); )
                    T++, W <<= 1;
                  if (k += 1 << T, t === g && k > E || t === C && k > A)
                    return 1;
                  H = F & G, l[H] = z << 24 | T << 16 | Y - e | 0;
                }
              }
              return F !== 0 && (l[Y + F] = x - B << 24 | 4194304 | 0), a.bits = z, 0;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js ***!
            \*********************************************************************/
          /***/
          (P) => {
            P.exports = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js ***!
            \******************************************************************/
          /***/
          (P, _, s) => {
            var v = s(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), M = 4, E = 0, A = 1, h = 2;
            function g(Z) {
              for (var de = Z.length; --de >= 0; )
                Z[de] = 0;
            }
            var C = 0, c = 1, S = 2, y = 3, b = 258, w = 29, t = 256, r = t + 1 + w, u = 30, o = 19, l = 2 * r + 1, e = 15, n = 16, a = 7, p = 256, x = 16, D = 17, O = 18, R = (
              /* extra bits for each length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
            ), z = (
              /* extra bits for each distance code */
              [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
            ), T = (
              /* extra bits for each bit length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
            ), B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W = 512, k = new Array((r + 2) * 2);
            g(k);
            var F = new Array(u * 2);
            g(F);
            var U = new Array(W);
            g(U);
            var V = new Array(b - y + 1);
            g(V);
            var H = new Array(w);
            g(H);
            var G = new Array(u);
            g(G);
            function Y(Z, de, me, Pe, oe) {
              this.static_tree = Z, this.extra_bits = de, this.extra_base = me, this.elems = Pe, this.max_length = oe, this.has_stree = Z && Z.length;
            }
            var J, re, le;
            function ie(Z, de) {
              this.dyn_tree = Z, this.max_code = 0, this.stat_desc = de;
            }
            function xe(Z) {
              return Z < 256 ? U[Z] : U[256 + (Z >>> 7)];
            }
            function se(Z, de) {
              Z.pending_buf[Z.pending++] = de & 255, Z.pending_buf[Z.pending++] = de >>> 8 & 255;
            }
            function ce(Z, de, me) {
              Z.bi_valid > n - me ? (Z.bi_buf |= de << Z.bi_valid & 65535, se(Z, Z.bi_buf), Z.bi_buf = de >> n - Z.bi_valid, Z.bi_valid += me - n) : (Z.bi_buf |= de << Z.bi_valid & 65535, Z.bi_valid += me);
            }
            function Ee(Z, de, me) {
              ce(
                Z,
                me[de * 2],
                me[de * 2 + 1]
                /*.Len*/
              );
            }
            function be(Z, de) {
              var me = 0;
              do
                me |= Z & 1, Z >>>= 1, me <<= 1;
              while (--de > 0);
              return me >>> 1;
            }
            function Le(Z) {
              Z.bi_valid === 16 ? (se(Z, Z.bi_buf), Z.bi_buf = 0, Z.bi_valid = 0) : Z.bi_valid >= 8 && (Z.pending_buf[Z.pending++] = Z.bi_buf & 255, Z.bi_buf >>= 8, Z.bi_valid -= 8);
            }
            function ae(Z, de) {
              var me = de.dyn_tree, Pe = de.max_code, oe = de.stat_desc.static_tree, Ce = de.stat_desc.has_stree, j = de.stat_desc.extra_bits, Oe = de.stat_desc.extra_base, He = de.stat_desc.max_length, I, ge, ve, $, ne, ye, Ze = 0;
              for ($ = 0; $ <= e; $++)
                Z.bl_count[$] = 0;
              for (me[Z.heap[Z.heap_max] * 2 + 1] = 0, I = Z.heap_max + 1; I < l; I++)
                ge = Z.heap[I], $ = me[me[ge * 2 + 1] * 2 + 1] + 1, $ > He && ($ = He, Ze++), me[ge * 2 + 1] = $, !(ge > Pe) && (Z.bl_count[$]++, ne = 0, ge >= Oe && (ne = j[ge - Oe]), ye = me[ge * 2], Z.opt_len += ye * ($ + ne), Ce && (Z.static_len += ye * (oe[ge * 2 + 1] + ne)));
              if (Ze !== 0) {
                do {
                  for ($ = He - 1; Z.bl_count[$] === 0; )
                    $--;
                  Z.bl_count[$]--, Z.bl_count[$ + 1] += 2, Z.bl_count[He]--, Ze -= 2;
                } while (Ze > 0);
                for ($ = He; $ !== 0; $--)
                  for (ge = Z.bl_count[$]; ge !== 0; )
                    ve = Z.heap[--I], !(ve > Pe) && (me[ve * 2 + 1] !== $ && (Z.opt_len += ($ - me[ve * 2 + 1]) * me[ve * 2], me[ve * 2 + 1] = $), ge--);
              }
            }
            function pe(Z, de, me) {
              var Pe = new Array(e + 1), oe = 0, Ce, j;
              for (Ce = 1; Ce <= e; Ce++)
                Pe[Ce] = oe = oe + me[Ce - 1] << 1;
              for (j = 0; j <= de; j++) {
                var Oe = Z[j * 2 + 1];
                Oe !== 0 && (Z[j * 2] = be(Pe[Oe]++, Oe));
              }
            }
            function we() {
              var Z, de, me, Pe, oe, Ce = new Array(e + 1);
              for (me = 0, Pe = 0; Pe < w - 1; Pe++)
                for (H[Pe] = me, Z = 0; Z < 1 << R[Pe]; Z++)
                  V[me++] = Pe;
              for (V[me - 1] = Pe, oe = 0, Pe = 0; Pe < 16; Pe++)
                for (G[Pe] = oe, Z = 0; Z < 1 << z[Pe]; Z++)
                  U[oe++] = Pe;
              for (oe >>= 7; Pe < u; Pe++)
                for (G[Pe] = oe << 7, Z = 0; Z < 1 << z[Pe] - 7; Z++)
                  U[256 + oe++] = Pe;
              for (de = 0; de <= e; de++)
                Ce[de] = 0;
              for (Z = 0; Z <= 143; )
                k[Z * 2 + 1] = 8, Z++, Ce[8]++;
              for (; Z <= 255; )
                k[Z * 2 + 1] = 9, Z++, Ce[9]++;
              for (; Z <= 279; )
                k[Z * 2 + 1] = 7, Z++, Ce[7]++;
              for (; Z <= 287; )
                k[Z * 2 + 1] = 8, Z++, Ce[8]++;
              for (pe(k, r + 1, Ce), Z = 0; Z < u; Z++)
                F[Z * 2 + 1] = 5, F[Z * 2] = be(Z, 5);
              J = new Y(k, R, t + 1, r, e), re = new Y(F, z, 0, u, e), le = new Y(new Array(0), T, 0, o, a);
            }
            function Ge(Z) {
              var de;
              for (de = 0; de < r; de++)
                Z.dyn_ltree[de * 2] = 0;
              for (de = 0; de < u; de++)
                Z.dyn_dtree[de * 2] = 0;
              for (de = 0; de < o; de++)
                Z.bl_tree[de * 2] = 0;
              Z.dyn_ltree[p * 2] = 1, Z.opt_len = Z.static_len = 0, Z.last_lit = Z.matches = 0;
            }
            function We(Z) {
              Z.bi_valid > 8 ? se(Z, Z.bi_buf) : Z.bi_valid > 0 && (Z.pending_buf[Z.pending++] = Z.bi_buf), Z.bi_buf = 0, Z.bi_valid = 0;
            }
            function je(Z, de, me, Pe) {
              We(Z), Pe && (se(Z, me), se(Z, ~me)), v.arraySet(Z.pending_buf, Z.window, de, me, Z.pending), Z.pending += me;
            }
            function Fe(Z, de, me, Pe) {
              var oe = de * 2, Ce = me * 2;
              return Z[oe] < Z[Ce] || Z[oe] === Z[Ce] && Pe[de] <= Pe[me];
            }
            function ze(Z, de, me) {
              for (var Pe = Z.heap[me], oe = me << 1; oe <= Z.heap_len && (oe < Z.heap_len && Fe(de, Z.heap[oe + 1], Z.heap[oe], Z.depth) && oe++, !Fe(de, Pe, Z.heap[oe], Z.depth)); )
                Z.heap[me] = Z.heap[oe], me = oe, oe <<= 1;
              Z.heap[me] = Pe;
            }
            function Be(Z, de, me) {
              var Pe, oe, Ce = 0, j, Oe;
              if (Z.last_lit !== 0)
                do
                  Pe = Z.pending_buf[Z.d_buf + Ce * 2] << 8 | Z.pending_buf[Z.d_buf + Ce * 2 + 1], oe = Z.pending_buf[Z.l_buf + Ce], Ce++, Pe === 0 ? Ee(Z, oe, de) : (j = V[oe], Ee(Z, j + t + 1, de), Oe = R[j], Oe !== 0 && (oe -= H[j], ce(Z, oe, Oe)), Pe--, j = xe(Pe), Ee(Z, j, me), Oe = z[j], Oe !== 0 && (Pe -= G[j], ce(Z, Pe, Oe)));
                while (Ce < Z.last_lit);
              Ee(Z, p, de);
            }
            function Ie(Z, de) {
              var me = de.dyn_tree, Pe = de.stat_desc.static_tree, oe = de.stat_desc.has_stree, Ce = de.stat_desc.elems, j, Oe, He = -1, I;
              for (Z.heap_len = 0, Z.heap_max = l, j = 0; j < Ce; j++)
                me[j * 2] !== 0 ? (Z.heap[++Z.heap_len] = He = j, Z.depth[j] = 0) : me[j * 2 + 1] = 0;
              for (; Z.heap_len < 2; )
                I = Z.heap[++Z.heap_len] = He < 2 ? ++He : 0, me[I * 2] = 1, Z.depth[I] = 0, Z.opt_len--, oe && (Z.static_len -= Pe[I * 2 + 1]);
              for (de.max_code = He, j = Z.heap_len >> 1; j >= 1; j--)
                ze(Z, me, j);
              I = Ce;
              do
                j = Z.heap[
                  1
                  /*SMALLEST*/
                ], Z.heap[
                  1
                  /*SMALLEST*/
                ] = Z.heap[Z.heap_len--], ze(
                  Z,
                  me,
                  1
                  /*SMALLEST*/
                ), Oe = Z.heap[
                  1
                  /*SMALLEST*/
                ], Z.heap[--Z.heap_max] = j, Z.heap[--Z.heap_max] = Oe, me[I * 2] = me[j * 2] + me[Oe * 2], Z.depth[I] = (Z.depth[j] >= Z.depth[Oe] ? Z.depth[j] : Z.depth[Oe]) + 1, me[j * 2 + 1] = me[Oe * 2 + 1] = I, Z.heap[
                  1
                  /*SMALLEST*/
                ] = I++, ze(
                  Z,
                  me,
                  1
                  /*SMALLEST*/
                );
              while (Z.heap_len >= 2);
              Z.heap[--Z.heap_max] = Z.heap[
                1
                /*SMALLEST*/
              ], ae(Z, de), pe(me, He, Z.bl_count);
            }
            function Te(Z, de, me) {
              var Pe, oe = -1, Ce, j = de[0 * 2 + 1], Oe = 0, He = 7, I = 4;
              for (j === 0 && (He = 138, I = 3), de[(me + 1) * 2 + 1] = 65535, Pe = 0; Pe <= me; Pe++)
                Ce = j, j = de[(Pe + 1) * 2 + 1], !(++Oe < He && Ce === j) && (Oe < I ? Z.bl_tree[Ce * 2] += Oe : Ce !== 0 ? (Ce !== oe && Z.bl_tree[Ce * 2]++, Z.bl_tree[x * 2]++) : Oe <= 10 ? Z.bl_tree[D * 2]++ : Z.bl_tree[O * 2]++, Oe = 0, oe = Ce, j === 0 ? (He = 138, I = 3) : Ce === j ? (He = 6, I = 3) : (He = 7, I = 4));
            }
            function Re(Z, de, me) {
              var Pe, oe = -1, Ce, j = de[0 * 2 + 1], Oe = 0, He = 7, I = 4;
              for (j === 0 && (He = 138, I = 3), Pe = 0; Pe <= me; Pe++)
                if (Ce = j, j = de[(Pe + 1) * 2 + 1], !(++Oe < He && Ce === j)) {
                  if (Oe < I)
                    do
                      Ee(Z, Ce, Z.bl_tree);
                    while (--Oe !== 0);
                  else
                    Ce !== 0 ? (Ce !== oe && (Ee(Z, Ce, Z.bl_tree), Oe--), Ee(Z, x, Z.bl_tree), ce(Z, Oe - 3, 2)) : Oe <= 10 ? (Ee(Z, D, Z.bl_tree), ce(Z, Oe - 3, 3)) : (Ee(Z, O, Z.bl_tree), ce(Z, Oe - 11, 7));
                  Oe = 0, oe = Ce, j === 0 ? (He = 138, I = 3) : Ce === j ? (He = 6, I = 3) : (He = 7, I = 4);
                }
            }
            function ke(Z) {
              var de;
              for (Te(Z, Z.dyn_ltree, Z.l_desc.max_code), Te(Z, Z.dyn_dtree, Z.d_desc.max_code), Ie(Z, Z.bl_desc), de = o - 1; de >= 3 && Z.bl_tree[B[de] * 2 + 1] === 0; de--)
                ;
              return Z.opt_len += 3 * (de + 1) + 5 + 5 + 4, de;
            }
            function Ne(Z, de, me, Pe) {
              var oe;
              for (ce(Z, de - 257, 5), ce(Z, me - 1, 5), ce(Z, Pe - 4, 4), oe = 0; oe < Pe; oe++)
                ce(Z, Z.bl_tree[B[oe] * 2 + 1], 3);
              Re(Z, Z.dyn_ltree, de - 1), Re(Z, Z.dyn_dtree, me - 1);
            }
            function X(Z) {
              var de = 4093624447, me;
              for (me = 0; me <= 31; me++, de >>>= 1)
                if (de & 1 && Z.dyn_ltree[me * 2] !== 0)
                  return E;
              if (Z.dyn_ltree[18] !== 0 || Z.dyn_ltree[20] !== 0 || Z.dyn_ltree[26] !== 0)
                return A;
              for (me = 32; me < t; me++)
                if (Z.dyn_ltree[me * 2] !== 0)
                  return A;
              return E;
            }
            var K = !1;
            function q(Z) {
              K || (we(), K = !0), Z.l_desc = new ie(Z.dyn_ltree, J), Z.d_desc = new ie(Z.dyn_dtree, re), Z.bl_desc = new ie(Z.bl_tree, le), Z.bi_buf = 0, Z.bi_valid = 0, Ge(Z);
            }
            function fe(Z, de, me, Pe) {
              ce(Z, (C << 1) + (Pe ? 1 : 0), 3), je(Z, de, me, !0);
            }
            function ue(Z) {
              ce(Z, c << 1, 3), Ee(Z, p, k), Le(Z);
            }
            function De(Z, de, me, Pe) {
              var oe, Ce, j = 0;
              Z.level > 0 ? (Z.strm.data_type === h && (Z.strm.data_type = X(Z)), Ie(Z, Z.l_desc), Ie(Z, Z.d_desc), j = ke(Z), oe = Z.opt_len + 3 + 7 >>> 3, Ce = Z.static_len + 3 + 7 >>> 3, Ce <= oe && (oe = Ce)) : oe = Ce = me + 5, me + 4 <= oe && de !== -1 ? fe(Z, de, me, Pe) : Z.strategy === M || Ce === oe ? (ce(Z, (c << 1) + (Pe ? 1 : 0), 3), Be(Z, k, F)) : (ce(Z, (S << 1) + (Pe ? 1 : 0), 3), Ne(Z, Z.l_desc.max_code + 1, Z.d_desc.max_code + 1, j + 1), Be(Z, Z.dyn_ltree, Z.dyn_dtree)), Ge(Z), Pe && We(Z);
            }
            function Se(Z, de, me) {
              return Z.pending_buf[Z.d_buf + Z.last_lit * 2] = de >>> 8 & 255, Z.pending_buf[Z.d_buf + Z.last_lit * 2 + 1] = de & 255, Z.pending_buf[Z.l_buf + Z.last_lit] = me & 255, Z.last_lit++, de === 0 ? Z.dyn_ltree[me * 2]++ : (Z.matches++, de--, Z.dyn_ltree[(V[me] + t + 1) * 2]++, Z.dyn_dtree[xe(de) * 2]++), Z.last_lit === Z.lit_bufsize - 1;
            }
            _._tr_init = q, _._tr_stored_block = fe, _._tr_flush_block = De, _._tr_tally = Se, _._tr_align = ue;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js ***!
            \********************************************************************/
          /***/
          (P) => {
            function _() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            P.exports = _;
          }
        ),
        /***/
        "./src/SurfaceWorker.js": (
          /*!******************************!*\
            !*** ./src/SurfaceWorker.js ***!
            \******************************/
          /***/
          () => {
            $3Dmol.workerString = (function() {
              self.onmessage = function(P) {
                var _ = P.data, s = _.type;
                if (s < 0)
                  self.atomData = _.atoms, self.volume = _.volume, self.ps = new ProteinSurface();
                else {
                  var v = self.ps;
                  v.initparm(_.expandedExtent, s != 1, self.volume), v.fillvoxels(self.atomData, _.extendedAtoms), v.buildboundary(), (s === 4 || s === 2) && (v.fastdistancemap(), v.boundingatom(!1), v.fillvoxelswaals(self.atomData, _.extendedAtoms)), v.marchingcube(s);
                  var M = v.getFacesAndVertices(_.atomsToShow);
                  self.postMessage(M);
                }
              };
            }).toString().replace(/(^.*?\{|\}$)/g, ""), $3Dmol.workerString += `;
function _classCallCheck() {};`, $3Dmol.workerString += `;
` + $3Dmol.Vector3.toString(), $3Dmol.workerString += `;
` + $3Dmol.MarchingCubeInitializer.toString() + `;

`, $3Dmol.workerString += `;
` + $3Dmol.PointGrid.toString() + `;
`, $3Dmol.workerString += `;
var ProteinSurface = ` + $3Dmol.ProteinSurface.toString() + `;
`, $3Dmol.SurfaceWorker = window.URL ? window.URL.createObjectURL(new Blob([$3Dmol.workerString], { type: "text/javascript" })) : void 0;
          }
        ),
        /***/
        "./src/exporter.js": (
          /*!*************************!*\
            !*** ./src/exporter.js ***!
            \*************************/
          /***/
          (P) => {
            typeof P.exports == "object" && (P.exports = window.$3Dmol);
          }
        ),
        /***/
        "./src/vendor/mmtf.js": (
          /*!****************************!*\
            !*** ./src/vendor/mmtf.js ***!
            \****************************/
          /***/
          function(P, _) {
            (function(s, v) {
              v(_);
            })(this, function(s) {
              function v(X, K, q) {
                for (var fe = (X.byteLength, 0), ue = q.length; ue > fe; fe++) {
                  var De = q.charCodeAt(fe);
                  if (128 > De)
                    X.setUint8(K++, De >>> 0 & 127 | 0);
                  else if (2048 > De)
                    X.setUint8(K++, De >>> 6 & 31 | 192), X.setUint8(K++, De >>> 0 & 63 | 128);
                  else if (65536 > De)
                    X.setUint8(K++, De >>> 12 & 15 | 224), X.setUint8(K++, De >>> 6 & 63 | 128), X.setUint8(K++, De >>> 0 & 63 | 128);
                  else {
                    if (!(1114112 > De))
                      throw new Error("bad codepoint " + De);
                    X.setUint8(K++, De >>> 18 & 7 | 240), X.setUint8(K++, De >>> 12 & 63 | 128), X.setUint8(K++, De >>> 6 & 63 | 128), X.setUint8(K++, De >>> 0 & 63 | 128);
                  }
                }
              }
              function M(X) {
                for (var K = 0, q = 0, fe = X.length; fe > q; q++) {
                  var ue = X.charCodeAt(q);
                  if (128 > ue)
                    K += 1;
                  else if (2048 > ue)
                    K += 2;
                  else if (65536 > ue)
                    K += 3;
                  else {
                    if (!(1114112 > ue))
                      throw new Error("bad codepoint " + ue);
                    K += 4;
                  }
                }
                return K;
              }
              function E(X, K, q) {
                var fe = typeof X;
                if (fe === "string") {
                  var ue = M(X);
                  if (32 > ue)
                    return K.setUint8(q, 160 | ue), v(K, q + 1, X), 1 + ue;
                  if (256 > ue)
                    return K.setUint8(q, 217), K.setUint8(q + 1, ue), v(K, q + 2, X), 2 + ue;
                  if (65536 > ue)
                    return K.setUint8(q, 218), K.setUint16(q + 1, ue), v(K, q + 3, X), 3 + ue;
                  if (4294967296 > ue)
                    return K.setUint8(q, 219), K.setUint32(q + 1, ue), v(K, q + 5, X), 5 + ue;
                }
                if (X instanceof Uint8Array) {
                  var ue = X.byteLength, De = new Uint8Array(K.buffer);
                  if (256 > ue)
                    return K.setUint8(q, 196), K.setUint8(q + 1, ue), De.set(X, q + 2), 2 + ue;
                  if (65536 > ue)
                    return K.setUint8(q, 197), K.setUint16(q + 1, ue), De.set(X, q + 3), 3 + ue;
                  if (4294967296 > ue)
                    return K.setUint8(q, 198), K.setUint32(q + 1, ue), De.set(X, q + 5), 5 + ue;
                }
                if (fe === "number") {
                  if (!isFinite(X))
                    throw new Error("Number not finite: " + X);
                  if (Math.floor(X) !== X)
                    return K.setUint8(q, 203), K.setFloat64(q + 1, X), 9;
                  if (X >= 0) {
                    if (128 > X)
                      return K.setUint8(q, X), 1;
                    if (256 > X)
                      return K.setUint8(q, 204), K.setUint8(q + 1, X), 2;
                    if (65536 > X)
                      return K.setUint8(q, 205), K.setUint16(q + 1, X), 3;
                    if (4294967296 > X)
                      return K.setUint8(q, 206), K.setUint32(q + 1, X), 5;
                    throw new Error("Number too big 0x" + X.toString(16));
                  }
                  if (X >= -32)
                    return K.setInt8(q, X), 1;
                  if (X >= -128)
                    return K.setUint8(q, 208), K.setInt8(q + 1, X), 2;
                  if (X >= -32768)
                    return K.setUint8(q, 209), K.setInt16(q + 1, X), 3;
                  if (X >= -2147483648)
                    return K.setUint8(q, 210), K.setInt32(q + 1, X), 5;
                  throw new Error("Number too small -0x" + (-X).toString(16).substr(1));
                }
                if (X === null)
                  return K.setUint8(q, 192), 1;
                if (fe === "boolean")
                  return K.setUint8(q, X ? 195 : 194), 1;
                if (fe === "object") {
                  var ue, de = 0, Se = Array.isArray(X);
                  if (Se)
                    ue = X.length;
                  else {
                    var Z = Object.keys(X);
                    ue = Z.length;
                  }
                  var de;
                  if (16 > ue ? (K.setUint8(q, ue | (Se ? 144 : 128)), de = 1) : 65536 > ue ? (K.setUint8(q, Se ? 220 : 222), K.setUint16(q + 1, ue), de = 3) : 4294967296 > ue && (K.setUint8(q, Se ? 221 : 223), K.setUint32(q + 1, ue), de = 5), Se)
                    for (var me = 0; ue > me; me++)
                      de += E(X[me], K, q + de);
                  else
                    for (var me = 0; ue > me; me++) {
                      var Pe = Z[me];
                      de += E(Pe, K, q + de), de += E(X[Pe], K, q + de);
                    }
                  return de;
                }
                throw new Error("Unknown type " + fe);
              }
              function A(X) {
                var K = typeof X;
                if (K === "string") {
                  var q = M(X);
                  if (32 > q)
                    return 1 + q;
                  if (256 > q)
                    return 2 + q;
                  if (65536 > q)
                    return 3 + q;
                  if (4294967296 > q)
                    return 5 + q;
                }
                if (X instanceof Uint8Array) {
                  var q = X.byteLength;
                  if (256 > q)
                    return 2 + q;
                  if (65536 > q)
                    return 3 + q;
                  if (4294967296 > q)
                    return 5 + q;
                }
                if (K === "number") {
                  if (Math.floor(X) !== X)
                    return 9;
                  if (X >= 0) {
                    if (128 > X)
                      return 1;
                    if (256 > X)
                      return 2;
                    if (65536 > X)
                      return 3;
                    if (4294967296 > X)
                      return 5;
                    throw new Error("Number too big 0x" + X.toString(16));
                  }
                  if (X >= -32)
                    return 1;
                  if (X >= -128)
                    return 2;
                  if (X >= -32768)
                    return 3;
                  if (X >= -2147483648)
                    return 5;
                  throw new Error("Number too small -0x" + X.toString(16).substr(1));
                }
                if (K === "boolean" || X === null)
                  return 1;
                if (K === "object") {
                  var q, fe = 0;
                  if (Array.isArray(X)) {
                    q = X.length;
                    for (var ue = 0; q > ue; ue++)
                      fe += A(X[ue]);
                  } else {
                    var De = Object.keys(X);
                    q = De.length;
                    for (var ue = 0; q > ue; ue++) {
                      var Se = De[ue];
                      fe += A(Se) + A(X[Se]);
                    }
                  }
                  if (16 > q)
                    return 1 + fe;
                  if (65536 > q)
                    return 3 + fe;
                  if (4294967296 > q)
                    return 5 + fe;
                  throw new Error("Array or object too long 0x" + q.toString(16));
                }
                throw new Error("Unknown type " + K);
              }
              function h(X) {
                var K = new ArrayBuffer(A(X)), q = new DataView(K);
                return E(X, q, 0), new Uint8Array(K);
              }
              function g(X, K, q) {
                return K ? new X(K.buffer, K.byteOffset, K.byteLength / (q || 1)) : void 0;
              }
              function C(X) {
                return g(DataView, X);
              }
              function c(X) {
                return g(Uint8Array, X);
              }
              function S(X) {
                return g(Int8Array, X);
              }
              function y(X) {
                return g(Int32Array, X, 4);
              }
              function b(X) {
                return g(Float32Array, X, 4);
              }
              function w(X, K) {
                var q = X.length / 2;
                K || (K = new Int16Array(q));
                for (var fe = 0, ue = 0; q > fe; ++fe, ue += 2)
                  K[fe] = X[ue] << 8 ^ X[ue + 1] << 0;
                return K;
              }
              function t(X, K) {
                var q = X.length;
                K || (K = new Uint8Array(2 * q));
                for (var fe = C(K), ue = 0; q > ue; ++ue)
                  fe.setInt16(2 * ue, X[ue]);
                return c(K);
              }
              function r(X, K) {
                var q = X.length / 4;
                K || (K = new Int32Array(q));
                for (var fe = 0, ue = 0; q > fe; ++fe, ue += 4)
                  K[fe] = X[ue] << 24 ^ X[ue + 1] << 16 ^ X[ue + 2] << 8 ^ X[ue + 3] << 0;
                return K;
              }
              function u(X, K) {
                var q = X.length;
                K || (K = new Uint8Array(4 * q));
                for (var fe = C(K), ue = 0; q > ue; ++ue)
                  fe.setInt32(4 * ue, X[ue]);
                return c(K);
              }
              function o(X, K) {
                var q = X.length;
                K || (K = new Float32Array(q / 4));
                for (var fe = C(K), ue = C(X), De = 0, Se = 0, Z = q / 4; Z > De; ++De, Se += 4)
                  fe.setFloat32(Se, ue.getFloat32(Se), !0);
                return K;
              }
              function l(X, K, q) {
                var fe = X.length, ue = 1 / K;
                q || (q = new Float32Array(fe));
                for (var De = 0; fe > De; ++De)
                  q[De] = X[De] * ue;
                return q;
              }
              function e(X, K, q) {
                var fe = X.length;
                q || (q = new Int32Array(fe));
                for (var ue = 0; fe > ue; ++ue)
                  q[ue] = Math.round(X[ue] * K);
                return q;
              }
              function n(X, K) {
                var q, fe;
                if (!K) {
                  var ue = 0;
                  for (q = 0, fe = X.length; fe > q; q += 2)
                    ue += X[q + 1];
                  K = new X.constructor(ue);
                }
                var De = 0;
                for (q = 0, fe = X.length; fe > q; q += 2)
                  for (var Se = X[q], Z = X[q + 1], de = 0; Z > de; ++de)
                    K[De] = Se, ++De;
                return K;
              }
              function a(X) {
                if (X.length === 0)
                  return new Int32Array();
                var K, q, fe = 2;
                for (K = 1, q = X.length; q > K; ++K)
                  X[K - 1] !== X[K] && (fe += 2);
                var ue = new Int32Array(fe), De = 0, Se = 1;
                for (K = 1, q = X.length; q > K; ++K)
                  X[K - 1] !== X[K] ? (ue[De] = X[K - 1], ue[De + 1] = Se, Se = 1, De += 2) : ++Se;
                return ue[De] = X[X.length - 1], ue[De + 1] = Se, ue;
              }
              function p(X, K) {
                var q = X.length;
                K || (K = new X.constructor(q)), q && (K[0] = X[0]);
                for (var fe = 1; q > fe; ++fe)
                  K[fe] = X[fe] + K[fe - 1];
                return K;
              }
              function x(X, K) {
                var q = X.length;
                K || (K = new X.constructor(q)), K[0] = X[0];
                for (var fe = 1; q > fe; ++fe)
                  K[fe] = X[fe] - X[fe - 1];
                return K;
              }
              function D(X, K) {
                var q, fe, ue = X instanceof Int8Array ? 127 : 32767, De = -ue - 1, Se = X.length;
                if (!K) {
                  var Z = 0;
                  for (q = 0; Se > q; ++q)
                    X[q] < ue && X[q] > De && ++Z;
                  K = new Int32Array(Z);
                }
                for (q = 0, fe = 0; Se > q; ) {
                  for (var de = 0; X[q] === ue || X[q] === De; )
                    de += X[q], ++q;
                  de += X[q], ++q, K[fe] = de, ++fe;
                }
                return K;
              }
              function O(X, K) {
                var q, fe = K ? 127 : 32767, ue = -fe - 1, De = X.length, Se = 0;
                for (q = 0; De > q; ++q) {
                  var Z = X[q];
                  Z === 0 ? ++Se : Z > 0 ? (Se += Math.ceil(Z / fe), Z % fe === 0 && (Se += 1)) : (Se += Math.ceil(Z / ue), Z % ue === 0 && (Se += 1));
                }
                var de = K ? new Int8Array(Se) : new Int16Array(Se), me = 0;
                for (q = 0; De > q; ++q) {
                  var Z = X[q];
                  if (Z >= 0)
                    for (; Z >= fe; )
                      de[me] = fe, ++me, Z -= fe;
                  else
                    for (; ue >= Z; )
                      de[me] = ue, ++me, Z -= ue;
                  de[me] = Z, ++me;
                }
                return de;
              }
              function R(X, K) {
                return p(n(X), K);
              }
              function z(X) {
                return a(x(X));
              }
              function T(X, K, q) {
                return l(n(X, y(q)), K, q);
              }
              function B(X, K) {
                return a(e(X, K));
              }
              function W(X, K, q) {
                return l(p(X, y(q)), K, q);
              }
              function k(X, K, q) {
                return x(e(X, K), q);
              }
              function F(X, K, q) {
                return l(D(X, y(q)), K, q);
              }
              function U(X, K, q) {
                var fe = D(X, y(q));
                return W(fe, K, b(fe));
              }
              function V(X, K, q) {
                return O(k(X, K), q);
              }
              function H(De) {
                var K = C(De), q = K.getInt32(0), fe = K.getInt32(4), ue = De.subarray(8, 12), De = De.subarray(12);
                return [q, De, fe, ue];
              }
              function G(X, K, q, fe) {
                var ue = new ArrayBuffer(12 + fe.byteLength), De = new Uint8Array(ue), Se = new DataView(ue);
                return Se.setInt32(0, X), Se.setInt32(4, K), q && De.set(q, 8), De.set(fe, 12), De;
              }
              function Y(X) {
                var K = X.length, q = c(X);
                return G(2, K, void 0, q);
              }
              function J(X) {
                var K = X.length, q = u(X);
                return G(4, K, void 0, q);
              }
              function re(X, K) {
                var q = X.length / K, fe = u([K]), ue = c(X);
                return G(5, q, fe, ue);
              }
              function le(X) {
                var K = X.length, q = u(a(X));
                return G(6, K, void 0, q);
              }
              function ie(X) {
                var K = X.length, q = u(z(X));
                return G(8, K, void 0, q);
              }
              function xe(X, K) {
                var q = X.length, fe = u([K]), ue = u(B(X, K));
                return G(9, q, fe, ue);
              }
              function se(X, K) {
                var q = X.length, fe = u([K]), ue = t(V(X, K));
                return G(10, q, fe, ue);
              }
              function ce(X) {
                var K = {};
                return ze.forEach(function(q) {
                  X[q] !== void 0 && (K[q] = X[q]);
                }), X.bondAtomList && (K.bondAtomList = J(X.bondAtomList)), X.bondOrderList && (K.bondOrderList = Y(X.bondOrderList)), K.xCoordList = se(X.xCoordList, 1e3), K.yCoordList = se(X.yCoordList, 1e3), K.zCoordList = se(X.zCoordList, 1e3), X.bFactorList && (K.bFactorList = se(X.bFactorList, 100)), X.atomIdList && (K.atomIdList = ie(X.atomIdList)), X.altLocList && (K.altLocList = le(X.altLocList)), X.occupancyList && (K.occupancyList = xe(X.occupancyList, 100)), K.groupIdList = ie(X.groupIdList), K.groupTypeList = J(X.groupTypeList), X.secStructList && (K.secStructList = Y(X.secStructList)), X.insCodeList && (K.insCodeList = le(X.insCodeList)), X.sequenceIndexList && (K.sequenceIndexList = ie(X.sequenceIndexList)), K.chainIdList = re(X.chainIdList, 4), X.chainNameList && (K.chainNameList = re(X.chainNameList, 4)), K;
              }
              function Ee(X) {
                function K(de) {
                  for (var me = {}, Pe = 0; de > Pe; Pe++) {
                    var oe = De();
                    me[oe] = De();
                  }
                  return me;
                }
                function q(de) {
                  var me = X.subarray(Se, Se + de);
                  return Se += de, me;
                }
                function fe(de) {
                  var me = X.subarray(Se, Se + de);
                  Se += de;
                  var Pe = 65535;
                  if (de > Pe) {
                    for (var oe = [], Ce = 0; Ce < me.length; Ce += Pe)
                      oe.push(String.fromCharCode.apply(null, me.subarray(Ce, Ce + Pe)));
                    return oe.join("");
                  }
                  return String.fromCharCode.apply(null, me);
                }
                function ue(de) {
                  for (var me = new Array(de), Pe = 0; de > Pe; Pe++)
                    me[Pe] = De();
                  return me;
                }
                function De() {
                  var de, me, Pe = X[Se];
                  if (!(128 & Pe))
                    return Se++, Pe;
                  if ((240 & Pe) === 128)
                    return me = 15 & Pe, Se++, K(me);
                  if ((240 & Pe) === 144)
                    return me = 15 & Pe, Se++, ue(me);
                  if ((224 & Pe) === 160)
                    return me = 31 & Pe, Se++, fe(me);
                  if ((224 & Pe) === 224)
                    return de = Z.getInt8(Se), Se++, de;
                  switch (Pe) {
                    case 192:
                      return Se++, null;
                    case 194:
                      return Se++, !1;
                    case 195:
                      return Se++, !0;
                    case 196:
                      return me = Z.getUint8(Se + 1), Se += 2, q(me);
                    case 197:
                      return me = Z.getUint16(Se + 1), Se += 3, q(me);
                    case 198:
                      return me = Z.getUint32(Se + 1), Se += 5, q(me);
                    case 202:
                      return de = Z.getFloat32(Se + 1), Se += 5, de;
                    case 203:
                      return de = Z.getFloat64(Se + 1), Se += 9, de;
                    case 204:
                      return de = X[Se + 1], Se += 2, de;
                    case 205:
                      return de = Z.getUint16(Se + 1), Se += 3, de;
                    case 206:
                      return de = Z.getUint32(Se + 1), Se += 5, de;
                    case 208:
                      return de = Z.getInt8(Se + 1), Se += 2, de;
                    case 209:
                      return de = Z.getInt16(Se + 1), Se += 3, de;
                    case 210:
                      return de = Z.getInt32(Se + 1), Se += 5, de;
                    case 217:
                      return me = Z.getUint8(Se + 1), Se += 2, fe(me);
                    case 218:
                      return me = Z.getUint16(Se + 1), Se += 3, fe(me);
                    case 219:
                      return me = Z.getUint32(Se + 1), Se += 5, fe(me);
                    case 220:
                      return me = Z.getUint16(Se + 1), Se += 3, ue(me);
                    case 221:
                      return me = Z.getUint32(Se + 1), Se += 5, ue(me);
                    case 222:
                      return me = Z.getUint16(Se + 1), Se += 3, K(me);
                    case 223:
                      return me = Z.getUint32(Se + 1), Se += 5, K(me);
                  }
                  throw new Error("Unknown type 0x" + Pe.toString(16));
                }
                var Se = 0, Z = new DataView(X.buffer);
                return De();
              }
              function be(X, K, q, fe) {
                switch (X) {
                  case 1:
                    return o(K);
                  case 2:
                    return S(K);
                  case 3:
                    return w(K);
                  case 4:
                    return r(K);
                  case 5:
                    return c(K);
                  case 6:
                    return n(r(K), new Uint8Array(q));
                  case 7:
                    return n(r(K));
                  case 8:
                    return R(r(K));
                  case 9:
                    return T(r(K), r(fe)[0]);
                  case 10:
                    return U(w(K), r(fe)[0]);
                  case 11:
                    return l(w(K), r(fe)[0]);
                  case 12:
                    return F(w(K), r(fe)[0]);
                  case 13:
                    return F(S(K), r(fe)[0]);
                  case 14:
                    return D(w(K));
                  case 15:
                    return D(S(K));
                }
              }
              function Le(X, K) {
                K = K || {};
                var q = K.ignoreFields, fe = {};
                return Ie.forEach(function(ue) {
                  var De = q ? q.indexOf(ue) !== -1 : !1, Se = X[ue];
                  De || Se === void 0 || (Se instanceof Uint8Array ? fe[ue] = be.apply(null, H(Se)) : fe[ue] = Se);
                }), fe;
              }
              function ae(X) {
                return String.fromCharCode.apply(null, X).replace(/\0/g, "");
              }
              function pe(X, K, q) {
                q = q || {};
                var fe, ue, De, Se, Z, de, me = q.firstModelOnly, Pe = K.onModel, oe = K.onChain, Ce = K.onGroup, j = K.onAtom, Oe = K.onBond, He = 0, I = 0, ge = 0, ve = 0, $ = 0, ne = -1, ye = X.chainNameList, Ze = X.secStructList, Ke = X.insCodeList, Ve = X.sequenceIndexList, qe = X.atomIdList, Et = X.bFactorList, nt = X.altLocList, rt = X.occupancyList, tt = X.bondAtomList, yt = X.bondOrderList;
                for (fe = 0, ue = X.chainsPerModel.length; ue > fe && !(me && He > 0); ++fe) {
                  var _t = X.chainsPerModel[He];
                  for (Pe && Pe({ chainCount: _t, modelIndex: He }), De = 0; _t > De; ++De) {
                    var It = X.groupsPerChain[I];
                    if (oe) {
                      var Ot = ae(X.chainIdList.subarray(4 * I, 4 * I + 4)), pt = null;
                      ye && (pt = ae(ye.subarray(4 * I, 4 * I + 4))), oe({ groupCount: It, chainIndex: I, modelIndex: He, chainId: Ot, chainName: pt });
                    }
                    for (Se = 0; It > Se; ++Se) {
                      var mt = X.groupList[X.groupTypeList[ge]], gt = mt.atomNameList.length;
                      if (Ce) {
                        var Ct = null;
                        Ze && (Ct = Ze[ge]);
                        var Mt = null;
                        X.insCodeList && (Mt = String.fromCharCode(Ke[ge]));
                        var Wt = null;
                        Ve && (Wt = Ve[ge]), Ce({ atomCount: gt, groupIndex: ge, chainIndex: I, modelIndex: He, groupId: X.groupIdList[ge], groupType: X.groupTypeList[ge], groupName: mt.groupName, singleLetterCode: mt.singleLetterCode, chemCompType: mt.chemCompType, secStruct: Ct, insCode: Mt, sequenceIndex: Wt });
                      }
                      for (Z = 0; gt > Z; ++Z) {
                        if (j) {
                          var di = null;
                          qe && (di = qe[ve]);
                          var Gt = null;
                          Et && (Gt = Et[ve]);
                          var ci = null;
                          nt && (ci = String.fromCharCode(nt[ve]));
                          var ui = null;
                          rt && (ui = rt[ve]), j({ atomIndex: ve, groupIndex: ge, chainIndex: I, modelIndex: He, atomId: di, element: mt.elementList[Z], atomName: mt.atomNameList[Z], formalCharge: mt.formalChargeList[Z], xCoord: X.xCoordList[ve], yCoord: X.yCoordList[ve], zCoord: X.zCoordList[ve], bFactor: Gt, altLoc: ci, occupancy: ui });
                        }
                        ve += 1;
                      }
                      if (Oe) {
                        var _i = mt.bondAtomList;
                        for (Z = 0, de = mt.bondOrderList.length; de > Z; ++Z)
                          Oe({ atomIndex1: ve - gt + _i[2 * Z], atomIndex2: ve - gt + _i[2 * Z + 1], bondOrder: mt.bondOrderList[Z] });
                      }
                      ge += 1;
                    }
                    I += 1;
                  }
                  if ($ = ne + 1, ne = ve - 1, Oe && tt)
                    for (Z = 0, de = tt.length; de > Z; Z += 2) {
                      var qt = tt[Z], gi = tt[Z + 1];
                      (qt >= $ && ne >= qt || gi >= $ && ne >= gi) && Oe({ atomIndex1: qt, atomIndex2: gi, bondOrder: yt ? yt[Z / 2] : null });
                    }
                  He += 1;
                }
              }
              function we(X) {
                return h(ce(X));
              }
              function Ge(X, K) {
                X instanceof ArrayBuffer && (X = new Uint8Array(X));
                var q;
                return q = X instanceof Uint8Array ? Ee(X) : X, Le(q, K);
              }
              function We(X, K, q, fe) {
                function ue() {
                  try {
                    var Se = Ge(De.response);
                    q(Se);
                  } catch (Z) {
                    fe(Z);
                  }
                }
                var De = new XMLHttpRequest();
                De.addEventListener("load", ue, !0), De.addEventListener("error", fe, !0), De.responseType = "arraybuffer", De.open("GET", K + X.toUpperCase()), De.send();
              }
              function je(X, K, q) {
                We(X, ke, K, q);
              }
              function Fe(X, K, q) {
                We(X, Ne, K, q);
              }
              var ze = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], Be = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], Ie = ze.concat(Be), Te = "v1.0.1", Re = "//mmtf.rcsb.org/v1.0/", ke = Re + "full/", Ne = Re + "reduced/";
              s.encode = we, s.decode = Ge, s.traverse = pe, s.fetch = je, s.fetchReduced = Fe, s.version = Te, s.fetchUrl = ke, s.fetchReducedUrl = Ne, s.encodeMsgpack = h, s.encodeMmtf = ce, s.decodeMsgpack = Ee, s.decodeMmtf = Le;
            });
          }
        ),
        /***/
        "./node_modules/pako/dist/pako.esm.mjs": (
          /*!*********************************************!*\
            !*** ./node_modules/pako/dist/pako.esm.mjs ***!
            \*********************************************/
          /***/
          (P, _, s) => {
            s.r(_), s.d(_, {
              /* harmony export */
              Deflate: () => (
                /* binding */
                Nr
              ),
              /* harmony export */
              Inflate: () => (
                /* binding */
                Hr
              ),
              /* harmony export */
              constants: () => (
                /* binding */
                Xr
              ),
              /* harmony export */
              default: () => (
                /* binding */
                Hs
              ),
              /* harmony export */
              deflate: () => (
                /* binding */
                kr
              ),
              /* harmony export */
              deflateRaw: () => (
                /* binding */
                Vr
              ),
              /* harmony export */
              gzip: () => (
                /* binding */
                jr
              ),
              /* harmony export */
              inflate: () => (
                /* binding */
                Kr
              ),
              /* harmony export */
              inflateRaw: () => (
                /* binding */
                Zr
              ),
              /* harmony export */
              ungzip: () => (
                /* binding */
                Yr
              )
              /* harmony export */
            });
            /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
            const v = 4, M = 0, E = 1, A = 2;
            function h(f) {
              let N = f.length;
              for (; --N >= 0; )
                f[N] = 0;
            }
            const g = 0, C = 1, c = 2, S = 3, y = 258, b = 29, w = 256, t = w + 1 + b, r = 30, u = 19, o = 2 * t + 1, l = 15, e = 16, n = 7, a = 256, p = 16, x = 17, D = 18, O = (
              /* extra bits for each length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
            ), R = (
              /* extra bits for each distance code */
              new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
            ), z = (
              /* extra bits for each bit length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
            ), T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), B = 512, W = new Array((t + 2) * 2);
            h(W);
            const k = new Array(r * 2);
            h(k);
            const F = new Array(B);
            h(F);
            const U = new Array(y - S + 1);
            h(U);
            const V = new Array(b);
            h(V);
            const H = new Array(r);
            h(H);
            function G(f, N, L, Q, te) {
              this.static_tree = f, this.extra_bits = N, this.extra_base = L, this.elems = Q, this.max_length = te, this.has_stree = f && f.length;
            }
            let Y, J, re;
            function le(f, N) {
              this.dyn_tree = f, this.max_code = 0, this.stat_desc = N;
            }
            const ie = (f) => f < 256 ? F[f] : F[256 + (f >>> 7)], xe = (f, N) => {
              f.pending_buf[f.pending++] = N & 255, f.pending_buf[f.pending++] = N >>> 8 & 255;
            }, se = (f, N, L) => {
              f.bi_valid > e - L ? (f.bi_buf |= N << f.bi_valid & 65535, xe(f, f.bi_buf), f.bi_buf = N >> e - f.bi_valid, f.bi_valid += L - e) : (f.bi_buf |= N << f.bi_valid & 65535, f.bi_valid += L);
            }, ce = (f, N, L) => {
              se(
                f,
                L[N * 2],
                L[N * 2 + 1]
                /*.Len*/
              );
            }, Ee = (f, N) => {
              let L = 0;
              do
                L |= f & 1, f >>>= 1, L <<= 1;
              while (--N > 0);
              return L >>> 1;
            }, be = (f) => {
              f.bi_valid === 16 ? (xe(f, f.bi_buf), f.bi_buf = 0, f.bi_valid = 0) : f.bi_valid >= 8 && (f.pending_buf[f.pending++] = f.bi_buf & 255, f.bi_buf >>= 8, f.bi_valid -= 8);
            }, Le = (f, N) => {
              const L = N.dyn_tree, Q = N.max_code, te = N.stat_desc.static_tree, ee = N.stat_desc.has_stree, Me = N.stat_desc.extra_bits, _e = N.stat_desc.extra_base, $e = N.stat_desc.max_length;
              let he, Ae, ft, Xe, Ue, Qe, bt = 0;
              for (Xe = 0; Xe <= l; Xe++)
                f.bl_count[Xe] = 0;
              for (L[f.heap[f.heap_max] * 2 + 1] = 0, he = f.heap_max + 1; he < o; he++)
                Ae = f.heap[he], Xe = L[L[Ae * 2 + 1] * 2 + 1] + 1, Xe > $e && (Xe = $e, bt++), L[Ae * 2 + 1] = Xe, !(Ae > Q) && (f.bl_count[Xe]++, Ue = 0, Ae >= _e && (Ue = Me[Ae - _e]), Qe = L[Ae * 2], f.opt_len += Qe * (Xe + Ue), ee && (f.static_len += Qe * (te[Ae * 2 + 1] + Ue)));
              if (bt !== 0) {
                do {
                  for (Xe = $e - 1; f.bl_count[Xe] === 0; )
                    Xe--;
                  f.bl_count[Xe]--, f.bl_count[Xe + 1] += 2, f.bl_count[$e]--, bt -= 2;
                } while (bt > 0);
                for (Xe = $e; Xe !== 0; Xe--)
                  for (Ae = f.bl_count[Xe]; Ae !== 0; )
                    ft = f.heap[--he], !(ft > Q) && (L[ft * 2 + 1] !== Xe && (f.opt_len += (Xe - L[ft * 2 + 1]) * L[ft * 2], L[ft * 2 + 1] = Xe), Ae--);
              }
            }, ae = (f, N, L) => {
              const Q = new Array(l + 1);
              let te = 0, ee, Me;
              for (ee = 1; ee <= l; ee++)
                te = te + L[ee - 1] << 1, Q[ee] = te;
              for (Me = 0; Me <= N; Me++) {
                let _e = f[Me * 2 + 1];
                _e !== 0 && (f[Me * 2] = Ee(Q[_e]++, _e));
              }
            }, pe = () => {
              let f, N, L, Q, te;
              const ee = new Array(l + 1);
              for (L = 0, Q = 0; Q < b - 1; Q++)
                for (V[Q] = L, f = 0; f < 1 << O[Q]; f++)
                  U[L++] = Q;
              for (U[L - 1] = Q, te = 0, Q = 0; Q < 16; Q++)
                for (H[Q] = te, f = 0; f < 1 << R[Q]; f++)
                  F[te++] = Q;
              for (te >>= 7; Q < r; Q++)
                for (H[Q] = te << 7, f = 0; f < 1 << R[Q] - 7; f++)
                  F[256 + te++] = Q;
              for (N = 0; N <= l; N++)
                ee[N] = 0;
              for (f = 0; f <= 143; )
                W[f * 2 + 1] = 8, f++, ee[8]++;
              for (; f <= 255; )
                W[f * 2 + 1] = 9, f++, ee[9]++;
              for (; f <= 279; )
                W[f * 2 + 1] = 7, f++, ee[7]++;
              for (; f <= 287; )
                W[f * 2 + 1] = 8, f++, ee[8]++;
              for (ae(W, t + 1, ee), f = 0; f < r; f++)
                k[f * 2 + 1] = 5, k[f * 2] = Ee(f, 5);
              Y = new G(W, O, w + 1, t, l), J = new G(k, R, 0, r, l), re = new G(new Array(0), z, 0, u, n);
            }, we = (f) => {
              let N;
              for (N = 0; N < t; N++)
                f.dyn_ltree[N * 2] = 0;
              for (N = 0; N < r; N++)
                f.dyn_dtree[N * 2] = 0;
              for (N = 0; N < u; N++)
                f.bl_tree[N * 2] = 0;
              f.dyn_ltree[a * 2] = 1, f.opt_len = f.static_len = 0, f.sym_next = f.matches = 0;
            }, Ge = (f) => {
              f.bi_valid > 8 ? xe(f, f.bi_buf) : f.bi_valid > 0 && (f.pending_buf[f.pending++] = f.bi_buf), f.bi_buf = 0, f.bi_valid = 0;
            }, We = (f, N, L, Q) => {
              const te = N * 2, ee = L * 2;
              return f[te] < f[ee] || f[te] === f[ee] && Q[N] <= Q[L];
            }, je = (f, N, L) => {
              const Q = f.heap[L];
              let te = L << 1;
              for (; te <= f.heap_len && (te < f.heap_len && We(N, f.heap[te + 1], f.heap[te], f.depth) && te++, !We(N, Q, f.heap[te], f.depth)); )
                f.heap[L] = f.heap[te], L = te, te <<= 1;
              f.heap[L] = Q;
            }, Fe = (f, N, L) => {
              let Q, te, ee = 0, Me, _e;
              if (f.sym_next !== 0)
                do
                  Q = f.pending_buf[f.sym_buf + ee++] & 255, Q += (f.pending_buf[f.sym_buf + ee++] & 255) << 8, te = f.pending_buf[f.sym_buf + ee++], Q === 0 ? ce(f, te, N) : (Me = U[te], ce(f, Me + w + 1, N), _e = O[Me], _e !== 0 && (te -= V[Me], se(f, te, _e)), Q--, Me = ie(Q), ce(f, Me, L), _e = R[Me], _e !== 0 && (Q -= H[Me], se(f, Q, _e)));
                while (ee < f.sym_next);
              ce(f, a, N);
            }, ze = (f, N) => {
              const L = N.dyn_tree, Q = N.stat_desc.static_tree, te = N.stat_desc.has_stree, ee = N.stat_desc.elems;
              let Me, _e, $e = -1, he;
              for (f.heap_len = 0, f.heap_max = o, Me = 0; Me < ee; Me++)
                L[Me * 2] !== 0 ? (f.heap[++f.heap_len] = $e = Me, f.depth[Me] = 0) : L[Me * 2 + 1] = 0;
              for (; f.heap_len < 2; )
                he = f.heap[++f.heap_len] = $e < 2 ? ++$e : 0, L[he * 2] = 1, f.depth[he] = 0, f.opt_len--, te && (f.static_len -= Q[he * 2 + 1]);
              for (N.max_code = $e, Me = f.heap_len >> 1; Me >= 1; Me--)
                je(f, L, Me);
              he = ee;
              do
                Me = f.heap[
                  1
                  /*SMALLEST*/
                ], f.heap[
                  1
                  /*SMALLEST*/
                ] = f.heap[f.heap_len--], je(
                  f,
                  L,
                  1
                  /*SMALLEST*/
                ), _e = f.heap[
                  1
                  /*SMALLEST*/
                ], f.heap[--f.heap_max] = Me, f.heap[--f.heap_max] = _e, L[he * 2] = L[Me * 2] + L[_e * 2], f.depth[he] = (f.depth[Me] >= f.depth[_e] ? f.depth[Me] : f.depth[_e]) + 1, L[Me * 2 + 1] = L[_e * 2 + 1] = he, f.heap[
                  1
                  /*SMALLEST*/
                ] = he++, je(
                  f,
                  L,
                  1
                  /*SMALLEST*/
                );
              while (f.heap_len >= 2);
              f.heap[--f.heap_max] = f.heap[
                1
                /*SMALLEST*/
              ], Le(f, N), ae(L, $e, f.bl_count);
            }, Be = (f, N, L) => {
              let Q, te = -1, ee, Me = N[0 * 2 + 1], _e = 0, $e = 7, he = 4;
              for (Me === 0 && ($e = 138, he = 3), N[(L + 1) * 2 + 1] = 65535, Q = 0; Q <= L; Q++)
                ee = Me, Me = N[(Q + 1) * 2 + 1], !(++_e < $e && ee === Me) && (_e < he ? f.bl_tree[ee * 2] += _e : ee !== 0 ? (ee !== te && f.bl_tree[ee * 2]++, f.bl_tree[p * 2]++) : _e <= 10 ? f.bl_tree[x * 2]++ : f.bl_tree[D * 2]++, _e = 0, te = ee, Me === 0 ? ($e = 138, he = 3) : ee === Me ? ($e = 6, he = 3) : ($e = 7, he = 4));
            }, Ie = (f, N, L) => {
              let Q, te = -1, ee, Me = N[0 * 2 + 1], _e = 0, $e = 7, he = 4;
              for (Me === 0 && ($e = 138, he = 3), Q = 0; Q <= L; Q++)
                if (ee = Me, Me = N[(Q + 1) * 2 + 1], !(++_e < $e && ee === Me)) {
                  if (_e < he)
                    do
                      ce(f, ee, f.bl_tree);
                    while (--_e !== 0);
                  else
                    ee !== 0 ? (ee !== te && (ce(f, ee, f.bl_tree), _e--), ce(f, p, f.bl_tree), se(f, _e - 3, 2)) : _e <= 10 ? (ce(f, x, f.bl_tree), se(f, _e - 3, 3)) : (ce(f, D, f.bl_tree), se(f, _e - 11, 7));
                  _e = 0, te = ee, Me === 0 ? ($e = 138, he = 3) : ee === Me ? ($e = 6, he = 3) : ($e = 7, he = 4);
                }
            }, Te = (f) => {
              let N;
              for (Be(f, f.dyn_ltree, f.l_desc.max_code), Be(f, f.dyn_dtree, f.d_desc.max_code), ze(f, f.bl_desc), N = u - 1; N >= 3 && f.bl_tree[T[N] * 2 + 1] === 0; N--)
                ;
              return f.opt_len += 3 * (N + 1) + 5 + 5 + 4, N;
            }, Re = (f, N, L, Q) => {
              let te;
              for (se(f, N - 257, 5), se(f, L - 1, 5), se(f, Q - 4, 4), te = 0; te < Q; te++)
                se(f, f.bl_tree[T[te] * 2 + 1], 3);
              Ie(f, f.dyn_ltree, N - 1), Ie(f, f.dyn_dtree, L - 1);
            }, ke = (f) => {
              let N = 4093624447, L;
              for (L = 0; L <= 31; L++, N >>>= 1)
                if (N & 1 && f.dyn_ltree[L * 2] !== 0)
                  return M;
              if (f.dyn_ltree[9 * 2] !== 0 || f.dyn_ltree[10 * 2] !== 0 || f.dyn_ltree[13 * 2] !== 0)
                return E;
              for (L = 32; L < w; L++)
                if (f.dyn_ltree[L * 2] !== 0)
                  return E;
              return M;
            };
            let Ne = !1;
            const X = (f) => {
              Ne || (pe(), Ne = !0), f.l_desc = new le(f.dyn_ltree, Y), f.d_desc = new le(f.dyn_dtree, J), f.bl_desc = new le(f.bl_tree, re), f.bi_buf = 0, f.bi_valid = 0, we(f);
            }, K = (f, N, L, Q) => {
              se(f, (g << 1) + (Q ? 1 : 0), 3), Ge(f), xe(f, L), xe(f, ~L), L && f.pending_buf.set(f.window.subarray(N, N + L), f.pending), f.pending += L;
            }, q = (f) => {
              se(f, C << 1, 3), ce(f, a, W), be(f);
            }, fe = (f, N, L, Q) => {
              let te, ee, Me = 0;
              f.level > 0 ? (f.strm.data_type === A && (f.strm.data_type = ke(f)), ze(f, f.l_desc), ze(f, f.d_desc), Me = Te(f), te = f.opt_len + 3 + 7 >>> 3, ee = f.static_len + 3 + 7 >>> 3, ee <= te && (te = ee)) : te = ee = L + 5, L + 4 <= te && N !== -1 ? K(f, N, L, Q) : f.strategy === v || ee === te ? (se(f, (C << 1) + (Q ? 1 : 0), 3), Fe(f, W, k)) : (se(f, (c << 1) + (Q ? 1 : 0), 3), Re(f, f.l_desc.max_code + 1, f.d_desc.max_code + 1, Me + 1), Fe(f, f.dyn_ltree, f.dyn_dtree)), we(f), Q && Ge(f);
            }, ue = (f, N, L) => (f.pending_buf[f.sym_buf + f.sym_next++] = N, f.pending_buf[f.sym_buf + f.sym_next++] = N >> 8, f.pending_buf[f.sym_buf + f.sym_next++] = L, N === 0 ? f.dyn_ltree[L * 2]++ : (f.matches++, N--, f.dyn_ltree[(U[L] + w + 1) * 2]++, f.dyn_dtree[ie(N) * 2]++), f.sym_next === f.sym_end);
            var De = X, Se = K, Z = fe, de = ue, me = q, Pe = {
              _tr_init: De,
              _tr_stored_block: Se,
              _tr_flush_block: Z,
              _tr_tally: de,
              _tr_align: me
            }, Ce = (f, N, L, Q) => {
              let te = f & 65535 | 0, ee = f >>> 16 & 65535 | 0, Me = 0;
              for (; L !== 0; ) {
                Me = L > 2e3 ? 2e3 : L, L -= Me;
                do
                  te = te + N[Q++] | 0, ee = ee + te | 0;
                while (--Me);
                te %= 65521, ee %= 65521;
              }
              return te | ee << 16 | 0;
            };
            const j = () => {
              let f, N = [];
              for (var L = 0; L < 256; L++) {
                f = L;
                for (var Q = 0; Q < 8; Q++)
                  f = f & 1 ? 3988292384 ^ f >>> 1 : f >>> 1;
                N[L] = f;
              }
              return N;
            }, Oe = new Uint32Array(j());
            var I = (f, N, L, Q) => {
              const te = Oe, ee = Q + L;
              f ^= -1;
              for (let Me = Q; Me < ee; Me++)
                f = f >>> 8 ^ te[(f ^ N[Me]) & 255];
              return f ^ -1;
            }, ge = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            }, ve = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              Z_MEM_ERROR: -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
            const { _tr_init: $, _tr_stored_block: ne, _tr_flush_block: ye, _tr_tally: Ze, _tr_align: Ke } = Pe, {
              Z_NO_FLUSH: Ve,
              Z_PARTIAL_FLUSH: qe,
              Z_FULL_FLUSH: Et,
              Z_FINISH: nt,
              Z_BLOCK: rt,
              Z_OK: tt,
              Z_STREAM_END: yt,
              Z_STREAM_ERROR: _t,
              Z_DATA_ERROR: It,
              Z_BUF_ERROR: Ot,
              Z_DEFAULT_COMPRESSION: pt,
              Z_FILTERED: mt,
              Z_HUFFMAN_ONLY: gt,
              Z_RLE: Ct,
              Z_FIXED: Mt,
              Z_DEFAULT_STRATEGY: Wt,
              Z_UNKNOWN: di,
              Z_DEFLATED: Gt
            } = ve, ci = 9, ui = 15, _i = 8, qt = 29, Ci = 256 + 1 + qt, Qr = 30, Jr = 19, qr = 2 * Ci + 1, en = 15, at = 3, Bt = 258, Tt = Bt + at + 1, tn = 32, Zt = 42, Li = 57, Di = 69, Si = 73, Oi = 91, Ti = 103, Nt = 113, ei = 666, At = 1, Yt = 2, kt = 3, Xt = 4, rn = 3, Vt = (f, N) => (f.msg = ge[N], N), ji = (f) => f * 2 - (f > 4 ? 9 : 0), Ft = (f) => {
              let N = f.length;
              for (; --N >= 0; )
                f[N] = 0;
            }, nn = (f) => {
              let N, L, Q, te = f.w_size;
              N = f.hash_size, Q = N;
              do
                L = f.head[--Q], f.head[Q] = L >= te ? L - te : 0;
              while (--N);
              N = te, Q = N;
              do
                L = f.prev[--Q], f.prev[Q] = L >= te ? L - te : 0;
              while (--N);
            };
            let Ut = (f, N, L) => (N << f.hash_shift ^ L) & f.hash_mask;
            const Lt = (f) => {
              const N = f.state;
              let L = N.pending;
              L > f.avail_out && (L = f.avail_out), L !== 0 && (f.output.set(N.pending_buf.subarray(N.pending_out, N.pending_out + L), f.next_out), f.next_out += L, N.pending_out += L, f.total_out += L, f.avail_out -= L, N.pending -= L, N.pending === 0 && (N.pending_out = 0));
            }, Dt = (f, N) => {
              ye(f, f.block_start >= 0 ? f.block_start : -1, f.strstart - f.block_start, N), f.block_start = f.strstart, Lt(f.strm);
            }, dt = (f, N) => {
              f.pending_buf[f.pending++] = N;
            }, ti = (f, N) => {
              f.pending_buf[f.pending++] = N >>> 8 & 255, f.pending_buf[f.pending++] = N & 255;
            }, Pi = (f, N, L, Q) => {
              let te = f.avail_in;
              return te > Q && (te = Q), te === 0 ? 0 : (f.avail_in -= te, N.set(f.input.subarray(f.next_in, f.next_in + te), L), f.state.wrap === 1 ? f.adler = Ce(f.adler, N, te, L) : f.state.wrap === 2 && (f.adler = I(f.adler, N, te, L)), f.next_in += te, f.total_in += te, te);
            }, Hi = (f, N) => {
              let L = f.max_chain_length, Q = f.strstart, te, ee, Me = f.prev_length, _e = f.nice_match;
              const $e = f.strstart > f.w_size - Tt ? f.strstart - (f.w_size - Tt) : 0, he = f.window, Ae = f.w_mask, ft = f.prev, Xe = f.strstart + Bt;
              let Ue = he[Q + Me - 1], Qe = he[Q + Me];
              f.prev_length >= f.good_match && (L >>= 2), _e > f.lookahead && (_e = f.lookahead);
              do
                if (te = N, !(he[te + Me] !== Qe || he[te + Me - 1] !== Ue || he[te] !== he[Q] || he[++te] !== he[Q + 1])) {
                  Q += 2, te++;
                  do
                    ;
                  while (he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && he[++Q] === he[++te] && Q < Xe);
                  if (ee = Bt - (Xe - Q), Q = Xe - Bt, ee > Me) {
                    if (f.match_start = N, Me = ee, ee >= _e)
                      break;
                    Ue = he[Q + Me - 1], Qe = he[Q + Me];
                  }
                }
              while ((N = ft[N & Ae]) > $e && --L !== 0);
              return Me <= f.lookahead ? Me : f.lookahead;
            }, $t = (f) => {
              const N = f.w_size;
              let L, Q, te;
              do {
                if (Q = f.window_size - f.lookahead - f.strstart, f.strstart >= N + (N - Tt) && (f.window.set(f.window.subarray(N, N + N - Q), 0), f.match_start -= N, f.strstart -= N, f.block_start -= N, f.insert > f.strstart && (f.insert = f.strstart), nn(f), Q += N), f.strm.avail_in === 0)
                  break;
                if (L = Pi(f.strm, f.window, f.strstart + f.lookahead, Q), f.lookahead += L, f.lookahead + f.insert >= at)
                  for (te = f.strstart - f.insert, f.ins_h = f.window[te], f.ins_h = Ut(f, f.ins_h, f.window[te + 1]); f.insert && (f.ins_h = Ut(f, f.ins_h, f.window[te + at - 1]), f.prev[te & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = te, te++, f.insert--, !(f.lookahead + f.insert < at)); )
                    ;
              } while (f.lookahead < Tt && f.strm.avail_in !== 0);
            }, Ki = (f, N) => {
              let L = f.pending_buf_size - 5 > f.w_size ? f.w_size : f.pending_buf_size - 5, Q, te, ee, Me = 0, _e = f.strm.avail_in;
              do {
                if (Q = 65535, ee = f.bi_valid + 42 >> 3, f.strm.avail_out < ee || (ee = f.strm.avail_out - ee, te = f.strstart - f.block_start, Q > te + f.strm.avail_in && (Q = te + f.strm.avail_in), Q > ee && (Q = ee), Q < L && (Q === 0 && N !== nt || N === Ve || Q !== te + f.strm.avail_in)))
                  break;
                Me = N === nt && Q === te + f.strm.avail_in ? 1 : 0, ne(f, 0, 0, Me), f.pending_buf[f.pending - 4] = Q, f.pending_buf[f.pending - 3] = Q >> 8, f.pending_buf[f.pending - 2] = ~Q, f.pending_buf[f.pending - 1] = ~Q >> 8, Lt(f.strm), te && (te > Q && (te = Q), f.strm.output.set(f.window.subarray(f.block_start, f.block_start + te), f.strm.next_out), f.strm.next_out += te, f.strm.avail_out -= te, f.strm.total_out += te, f.block_start += te, Q -= te), Q && (Pi(f.strm, f.strm.output, f.strm.next_out, Q), f.strm.next_out += Q, f.strm.avail_out -= Q, f.strm.total_out += Q);
              } while (Me === 0);
              return _e -= f.strm.avail_in, _e && (_e >= f.w_size ? (f.matches = 2, f.window.set(f.strm.input.subarray(f.strm.next_in - f.w_size, f.strm.next_in), 0), f.strstart = f.w_size, f.insert = f.strstart) : (f.window_size - f.strstart <= _e && (f.strstart -= f.w_size, f.window.set(f.window.subarray(f.w_size, f.w_size + f.strstart), 0), f.matches < 2 && f.matches++, f.insert > f.strstart && (f.insert = f.strstart)), f.window.set(f.strm.input.subarray(f.strm.next_in - _e, f.strm.next_in), f.strstart), f.strstart += _e, f.insert += _e > f.w_size - f.insert ? f.w_size - f.insert : _e), f.block_start = f.strstart), f.high_water < f.strstart && (f.high_water = f.strstart), Me ? Xt : N !== Ve && N !== nt && f.strm.avail_in === 0 && f.strstart === f.block_start ? Yt : (ee = f.window_size - f.strstart, f.strm.avail_in > ee && f.block_start >= f.w_size && (f.block_start -= f.w_size, f.strstart -= f.w_size, f.window.set(f.window.subarray(f.w_size, f.w_size + f.strstart), 0), f.matches < 2 && f.matches++, ee += f.w_size, f.insert > f.strstart && (f.insert = f.strstart)), ee > f.strm.avail_in && (ee = f.strm.avail_in), ee && (Pi(f.strm, f.window, f.strstart, ee), f.strstart += ee, f.insert += ee > f.w_size - f.insert ? f.w_size - f.insert : ee), f.high_water < f.strstart && (f.high_water = f.strstart), ee = f.bi_valid + 42 >> 3, ee = f.pending_buf_size - ee > 65535 ? 65535 : f.pending_buf_size - ee, L = ee > f.w_size ? f.w_size : ee, te = f.strstart - f.block_start, (te >= L || (te || N === nt) && N !== Ve && f.strm.avail_in === 0 && te <= ee) && (Q = te > ee ? ee : te, Me = N === nt && f.strm.avail_in === 0 && Q === te ? 1 : 0, ne(f, f.block_start, Q, Me), f.block_start += Q, Lt(f.strm)), Me ? kt : At);
            }, Ii = (f, N) => {
              let L, Q;
              for (; ; ) {
                if (f.lookahead < Tt) {
                  if ($t(f), f.lookahead < Tt && N === Ve)
                    return At;
                  if (f.lookahead === 0)
                    break;
                }
                if (L = 0, f.lookahead >= at && (f.ins_h = Ut(f, f.ins_h, f.window[f.strstart + at - 1]), L = f.prev[f.strstart & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = f.strstart), L !== 0 && f.strstart - L <= f.w_size - Tt && (f.match_length = Hi(f, L)), f.match_length >= at)
                  if (Q = Ze(f, f.strstart - f.match_start, f.match_length - at), f.lookahead -= f.match_length, f.match_length <= f.max_lazy_match && f.lookahead >= at) {
                    f.match_length--;
                    do
                      f.strstart++, f.ins_h = Ut(f, f.ins_h, f.window[f.strstart + at - 1]), L = f.prev[f.strstart & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = f.strstart;
                    while (--f.match_length !== 0);
                    f.strstart++;
                  } else
                    f.strstart += f.match_length, f.match_length = 0, f.ins_h = f.window[f.strstart], f.ins_h = Ut(f, f.ins_h, f.window[f.strstart + 1]);
                else
                  Q = Ze(f, 0, f.window[f.strstart]), f.lookahead--, f.strstart++;
                if (Q && (Dt(f, !1), f.strm.avail_out === 0))
                  return At;
              }
              return f.insert = f.strstart < at - 1 ? f.strstart : at - 1, N === nt ? (Dt(f, !0), f.strm.avail_out === 0 ? kt : Xt) : f.sym_next && (Dt(f, !1), f.strm.avail_out === 0) ? At : Yt;
            }, Qt = (f, N) => {
              let L, Q, te;
              for (; ; ) {
                if (f.lookahead < Tt) {
                  if ($t(f), f.lookahead < Tt && N === Ve)
                    return At;
                  if (f.lookahead === 0)
                    break;
                }
                if (L = 0, f.lookahead >= at && (f.ins_h = Ut(f, f.ins_h, f.window[f.strstart + at - 1]), L = f.prev[f.strstart & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = f.strstart), f.prev_length = f.match_length, f.prev_match = f.match_start, f.match_length = at - 1, L !== 0 && f.prev_length < f.max_lazy_match && f.strstart - L <= f.w_size - Tt && (f.match_length = Hi(f, L), f.match_length <= 5 && (f.strategy === mt || f.match_length === at && f.strstart - f.match_start > 4096) && (f.match_length = at - 1)), f.prev_length >= at && f.match_length <= f.prev_length) {
                  te = f.strstart + f.lookahead - at, Q = Ze(f, f.strstart - 1 - f.prev_match, f.prev_length - at), f.lookahead -= f.prev_length - 1, f.prev_length -= 2;
                  do
                    ++f.strstart <= te && (f.ins_h = Ut(f, f.ins_h, f.window[f.strstart + at - 1]), L = f.prev[f.strstart & f.w_mask] = f.head[f.ins_h], f.head[f.ins_h] = f.strstart);
                  while (--f.prev_length !== 0);
                  if (f.match_available = 0, f.match_length = at - 1, f.strstart++, Q && (Dt(f, !1), f.strm.avail_out === 0))
                    return At;
                } else if (f.match_available) {
                  if (Q = Ze(f, 0, f.window[f.strstart - 1]), Q && Dt(f, !1), f.strstart++, f.lookahead--, f.strm.avail_out === 0)
                    return At;
                } else
                  f.match_available = 1, f.strstart++, f.lookahead--;
              }
              return f.match_available && (Q = Ze(f, 0, f.window[f.strstart - 1]), f.match_available = 0), f.insert = f.strstart < at - 1 ? f.strstart : at - 1, N === nt ? (Dt(f, !0), f.strm.avail_out === 0 ? kt : Xt) : f.sym_next && (Dt(f, !1), f.strm.avail_out === 0) ? At : Yt;
            }, sn = (f, N) => {
              let L, Q, te, ee;
              const Me = f.window;
              for (; ; ) {
                if (f.lookahead <= Bt) {
                  if ($t(f), f.lookahead <= Bt && N === Ve)
                    return At;
                  if (f.lookahead === 0)
                    break;
                }
                if (f.match_length = 0, f.lookahead >= at && f.strstart > 0 && (te = f.strstart - 1, Q = Me[te], Q === Me[++te] && Q === Me[++te] && Q === Me[++te])) {
                  ee = f.strstart + Bt;
                  do
                    ;
                  while (Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && Q === Me[++te] && te < ee);
                  f.match_length = Bt - (ee - te), f.match_length > f.lookahead && (f.match_length = f.lookahead);
                }
                if (f.match_length >= at ? (L = Ze(f, 1, f.match_length - at), f.lookahead -= f.match_length, f.strstart += f.match_length, f.match_length = 0) : (L = Ze(f, 0, f.window[f.strstart]), f.lookahead--, f.strstart++), L && (Dt(f, !1), f.strm.avail_out === 0))
                  return At;
              }
              return f.insert = 0, N === nt ? (Dt(f, !0), f.strm.avail_out === 0 ? kt : Xt) : f.sym_next && (Dt(f, !1), f.strm.avail_out === 0) ? At : Yt;
            }, an = (f, N) => {
              let L;
              for (; ; ) {
                if (f.lookahead === 0 && ($t(f), f.lookahead === 0)) {
                  if (N === Ve)
                    return At;
                  break;
                }
                if (f.match_length = 0, L = Ze(f, 0, f.window[f.strstart]), f.lookahead--, f.strstart++, L && (Dt(f, !1), f.strm.avail_out === 0))
                  return At;
              }
              return f.insert = 0, N === nt ? (Dt(f, !0), f.strm.avail_out === 0 ? kt : Xt) : f.sym_next && (Dt(f, !1), f.strm.avail_out === 0) ? At : Yt;
            };
            function Pt(f, N, L, Q, te) {
              this.good_length = f, this.max_lazy = N, this.nice_length = L, this.max_chain = Q, this.func = te;
            }
            const ii = [
              /*      good lazy nice chain */
              new Pt(0, 0, 0, 0, Ki),
              /* 0 store only */
              new Pt(4, 4, 8, 4, Ii),
              /* 1 max speed, no lazy matches */
              new Pt(4, 5, 16, 8, Ii),
              /* 2 */
              new Pt(4, 6, 32, 32, Ii),
              /* 3 */
              new Pt(4, 4, 16, 16, Qt),
              /* 4 lazy matches */
              new Pt(8, 16, 32, 32, Qt),
              /* 5 */
              new Pt(8, 16, 128, 128, Qt),
              /* 6 */
              new Pt(8, 32, 128, 256, Qt),
              /* 7 */
              new Pt(32, 128, 258, 1024, Qt),
              /* 8 */
              new Pt(32, 258, 258, 4096, Qt)
              /* 9 max compression */
            ], on = (f) => {
              f.window_size = 2 * f.w_size, Ft(f.head), f.max_lazy_match = ii[f.level].max_lazy, f.good_match = ii[f.level].good_length, f.nice_match = ii[f.level].nice_length, f.max_chain_length = ii[f.level].max_chain, f.strstart = 0, f.block_start = 0, f.lookahead = 0, f.insert = 0, f.match_length = f.prev_length = at - 1, f.match_available = 0, f.ins_h = 0;
            };
            function ln() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Gt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(qr * 2), this.dyn_dtree = new Uint16Array((2 * Qr + 1) * 2), this.bl_tree = new Uint16Array((2 * Jr + 1) * 2), Ft(this.dyn_ltree), Ft(this.dyn_dtree), Ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(en + 1), this.heap = new Uint16Array(2 * Ci + 1), Ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Ci + 1), Ft(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            const ri = (f) => {
              if (!f)
                return 1;
              const N = f.state;
              return !N || N.strm !== f || N.status !== Zt && //#ifdef GZIP
              N.status !== Li && //#endif
              N.status !== Di && N.status !== Si && N.status !== Oi && N.status !== Ti && N.status !== Nt && N.status !== ei ? 1 : 0;
            }, Zi = (f) => {
              if (ri(f))
                return Vt(f, _t);
              f.total_in = f.total_out = 0, f.data_type = di;
              const N = f.state;
              return N.pending = 0, N.pending_out = 0, N.wrap < 0 && (N.wrap = -N.wrap), N.status = //#ifdef GZIP
              N.wrap === 2 ? Li : (
                //#endif
                N.wrap ? Zt : Nt
              ), f.adler = N.wrap === 2 ? 0 : 1, N.last_flush = -2, $(N), tt;
            }, Yi = (f) => {
              const N = Zi(f);
              return N === tt && on(f.state), N;
            }, hn = (f, N) => ri(f) || f.state.wrap !== 2 ? _t : (f.state.gzhead = N, tt), Xi = (f, N, L, Q, te, ee) => {
              if (!f)
                return _t;
              let Me = 1;
              if (N === pt && (N = 6), Q < 0 ? (Me = 0, Q = -Q) : Q > 15 && (Me = 2, Q -= 16), te < 1 || te > ci || L !== Gt || Q < 8 || Q > 15 || N < 0 || N > 9 || ee < 0 || ee > Mt || Q === 8 && Me !== 1)
                return Vt(f, _t);
              Q === 8 && (Q = 9);
              const _e = new ln();
              return f.state = _e, _e.strm = f, _e.status = Zt, _e.wrap = Me, _e.gzhead = null, _e.w_bits = Q, _e.w_size = 1 << _e.w_bits, _e.w_mask = _e.w_size - 1, _e.hash_bits = te + 7, _e.hash_size = 1 << _e.hash_bits, _e.hash_mask = _e.hash_size - 1, _e.hash_shift = ~~((_e.hash_bits + at - 1) / at), _e.window = new Uint8Array(_e.w_size * 2), _e.head = new Uint16Array(_e.hash_size), _e.prev = new Uint16Array(_e.w_size), _e.lit_bufsize = 1 << te + 6, _e.pending_buf_size = _e.lit_bufsize * 4, _e.pending_buf = new Uint8Array(_e.pending_buf_size), _e.sym_buf = _e.lit_bufsize, _e.sym_end = (_e.lit_bufsize - 1) * 3, _e.level = N, _e.strategy = ee, _e.method = L, Yi(f);
            }, fn = (f, N) => Xi(f, N, Gt, ui, _i, Wt), dn = (f, N) => {
              if (ri(f) || N > rt || N < 0)
                return f ? Vt(f, _t) : _t;
              const L = f.state;
              if (!f.output || f.avail_in !== 0 && !f.input || L.status === ei && N !== nt)
                return Vt(f, f.avail_out === 0 ? Ot : _t);
              const Q = L.last_flush;
              if (L.last_flush = N, L.pending !== 0) {
                if (Lt(f), f.avail_out === 0)
                  return L.last_flush = -1, tt;
              } else if (f.avail_in === 0 && ji(N) <= ji(Q) && N !== nt)
                return Vt(f, Ot);
              if (L.status === ei && f.avail_in !== 0)
                return Vt(f, Ot);
              if (L.status === Zt && L.wrap === 0 && (L.status = Nt), L.status === Zt) {
                let te = Gt + (L.w_bits - 8 << 4) << 8, ee = -1;
                if (L.strategy >= gt || L.level < 2 ? ee = 0 : L.level < 6 ? ee = 1 : L.level === 6 ? ee = 2 : ee = 3, te |= ee << 6, L.strstart !== 0 && (te |= tn), te += 31 - te % 31, ti(L, te), L.strstart !== 0 && (ti(L, f.adler >>> 16), ti(L, f.adler & 65535)), f.adler = 1, L.status = Nt, Lt(f), L.pending !== 0)
                  return L.last_flush = -1, tt;
              }
              if (L.status === Li) {
                if (f.adler = 0, dt(L, 31), dt(L, 139), dt(L, 8), L.gzhead)
                  dt(
                    L,
                    (L.gzhead.text ? 1 : 0) + (L.gzhead.hcrc ? 2 : 0) + (L.gzhead.extra ? 4 : 0) + (L.gzhead.name ? 8 : 0) + (L.gzhead.comment ? 16 : 0)
                  ), dt(L, L.gzhead.time & 255), dt(L, L.gzhead.time >> 8 & 255), dt(L, L.gzhead.time >> 16 & 255), dt(L, L.gzhead.time >> 24 & 255), dt(L, L.level === 9 ? 2 : L.strategy >= gt || L.level < 2 ? 4 : 0), dt(L, L.gzhead.os & 255), L.gzhead.extra && L.gzhead.extra.length && (dt(L, L.gzhead.extra.length & 255), dt(L, L.gzhead.extra.length >> 8 & 255)), L.gzhead.hcrc && (f.adler = I(f.adler, L.pending_buf, L.pending, 0)), L.gzindex = 0, L.status = Di;
                else if (dt(L, 0), dt(L, 0), dt(L, 0), dt(L, 0), dt(L, 0), dt(L, L.level === 9 ? 2 : L.strategy >= gt || L.level < 2 ? 4 : 0), dt(L, rn), L.status = Nt, Lt(f), L.pending !== 0)
                  return L.last_flush = -1, tt;
              }
              if (L.status === Di) {
                if (L.gzhead.extra) {
                  let te = L.pending, ee = (L.gzhead.extra.length & 65535) - L.gzindex;
                  for (; L.pending + ee > L.pending_buf_size; ) {
                    let _e = L.pending_buf_size - L.pending;
                    if (L.pending_buf.set(L.gzhead.extra.subarray(L.gzindex, L.gzindex + _e), L.pending), L.pending = L.pending_buf_size, L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te)), L.gzindex += _e, Lt(f), L.pending !== 0)
                      return L.last_flush = -1, tt;
                    te = 0, ee -= _e;
                  }
                  let Me = new Uint8Array(L.gzhead.extra);
                  L.pending_buf.set(Me.subarray(L.gzindex, L.gzindex + ee), L.pending), L.pending += ee, L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te)), L.gzindex = 0;
                }
                L.status = Si;
              }
              if (L.status === Si) {
                if (L.gzhead.name) {
                  let te = L.pending, ee;
                  do {
                    if (L.pending === L.pending_buf_size) {
                      if (L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te)), Lt(f), L.pending !== 0)
                        return L.last_flush = -1, tt;
                      te = 0;
                    }
                    L.gzindex < L.gzhead.name.length ? ee = L.gzhead.name.charCodeAt(L.gzindex++) & 255 : ee = 0, dt(L, ee);
                  } while (ee !== 0);
                  L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te)), L.gzindex = 0;
                }
                L.status = Oi;
              }
              if (L.status === Oi) {
                if (L.gzhead.comment) {
                  let te = L.pending, ee;
                  do {
                    if (L.pending === L.pending_buf_size) {
                      if (L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te)), Lt(f), L.pending !== 0)
                        return L.last_flush = -1, tt;
                      te = 0;
                    }
                    L.gzindex < L.gzhead.comment.length ? ee = L.gzhead.comment.charCodeAt(L.gzindex++) & 255 : ee = 0, dt(L, ee);
                  } while (ee !== 0);
                  L.gzhead.hcrc && L.pending > te && (f.adler = I(f.adler, L.pending_buf, L.pending - te, te));
                }
                L.status = Ti;
              }
              if (L.status === Ti) {
                if (L.gzhead.hcrc) {
                  if (L.pending + 2 > L.pending_buf_size && (Lt(f), L.pending !== 0))
                    return L.last_flush = -1, tt;
                  dt(L, f.adler & 255), dt(L, f.adler >> 8 & 255), f.adler = 0;
                }
                if (L.status = Nt, Lt(f), L.pending !== 0)
                  return L.last_flush = -1, tt;
              }
              if (f.avail_in !== 0 || L.lookahead !== 0 || N !== Ve && L.status !== ei) {
                let te = L.level === 0 ? Ki(L, N) : L.strategy === gt ? an(L, N) : L.strategy === Ct ? sn(L, N) : ii[L.level].func(L, N);
                if ((te === kt || te === Xt) && (L.status = ei), te === At || te === kt)
                  return f.avail_out === 0 && (L.last_flush = -1), tt;
                if (te === Yt && (N === qe ? Ke(L) : N !== rt && (ne(L, 0, 0, !1), N === Et && (Ft(L.head), L.lookahead === 0 && (L.strstart = 0, L.block_start = 0, L.insert = 0))), Lt(f), f.avail_out === 0))
                  return L.last_flush = -1, tt;
              }
              return N !== nt ? tt : L.wrap <= 0 ? yt : (L.wrap === 2 ? (dt(L, f.adler & 255), dt(L, f.adler >> 8 & 255), dt(L, f.adler >> 16 & 255), dt(L, f.adler >> 24 & 255), dt(L, f.total_in & 255), dt(L, f.total_in >> 8 & 255), dt(L, f.total_in >> 16 & 255), dt(L, f.total_in >> 24 & 255)) : (ti(L, f.adler >>> 16), ti(L, f.adler & 65535)), Lt(f), L.wrap > 0 && (L.wrap = -L.wrap), L.pending !== 0 ? tt : yt);
            }, cn = (f) => {
              if (ri(f))
                return _t;
              const N = f.state.status;
              return f.state = null, N === Nt ? Vt(f, It) : tt;
            }, un = (f, N) => {
              let L = N.length;
              if (ri(f))
                return _t;
              const Q = f.state, te = Q.wrap;
              if (te === 2 || te === 1 && Q.status !== Zt || Q.lookahead)
                return _t;
              if (te === 1 && (f.adler = Ce(f.adler, N, L, 0)), Q.wrap = 0, L >= Q.w_size) {
                te === 0 && (Ft(Q.head), Q.strstart = 0, Q.block_start = 0, Q.insert = 0);
                let $e = new Uint8Array(Q.w_size);
                $e.set(N.subarray(L - Q.w_size, L), 0), N = $e, L = Q.w_size;
              }
              const ee = f.avail_in, Me = f.next_in, _e = f.input;
              for (f.avail_in = L, f.next_in = 0, f.input = N, $t(Q); Q.lookahead >= at; ) {
                let $e = Q.strstart, he = Q.lookahead - (at - 1);
                do
                  Q.ins_h = Ut(Q, Q.ins_h, Q.window[$e + at - 1]), Q.prev[$e & Q.w_mask] = Q.head[Q.ins_h], Q.head[Q.ins_h] = $e, $e++;
                while (--he);
                Q.strstart = $e, Q.lookahead = at - 1, $t(Q);
              }
              return Q.strstart += Q.lookahead, Q.block_start = Q.strstart, Q.insert = Q.lookahead, Q.lookahead = 0, Q.match_length = Q.prev_length = at - 1, Q.match_available = 0, f.next_in = Me, f.input = _e, f.avail_in = ee, Q.wrap = te, tt;
            };
            var _n = fn, gn = Xi, vn = Yi, pn = Zi, mn = hn, xn = dn, bn = cn, yn = un, En = "pako deflate (from Nodeca project)", ni = {
              deflateInit: _n,
              deflateInit2: gn,
              deflateReset: vn,
              deflateResetKeep: pn,
              deflateSetHeader: mn,
              deflate: xn,
              deflateEnd: bn,
              deflateSetDictionary: yn,
              deflateInfo: En
            };
            const wn = (f, N) => Object.prototype.hasOwnProperty.call(f, N);
            var Mn = function(f) {
              const N = Array.prototype.slice.call(arguments, 1);
              for (; N.length; ) {
                const L = N.shift();
                if (L) {
                  if (typeof L != "object")
                    throw new TypeError(L + "must be non-object");
                  for (const Q in L)
                    wn(L, Q) && (f[Q] = L[Q]);
                }
              }
              return f;
            }, An = (f) => {
              let N = 0;
              for (let Q = 0, te = f.length; Q < te; Q++)
                N += f[Q].length;
              const L = new Uint8Array(N);
              for (let Q = 0, te = 0, ee = f.length; Q < ee; Q++) {
                let Me = f[Q];
                L.set(Me, te), te += Me.length;
              }
              return L;
            }, vi = {
              assign: Mn,
              flattenChunks: An
            };
            let $i = !0;
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              $i = !1;
            }
            const si = new Uint8Array(256);
            for (let f = 0; f < 256; f++)
              si[f] = f >= 252 ? 6 : f >= 248 ? 5 : f >= 240 ? 4 : f >= 224 ? 3 : f >= 192 ? 2 : 1;
            si[254] = si[254] = 1;
            var Cn = (f) => {
              if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
                return new TextEncoder().encode(f);
              let N, L, Q, te, ee, Me = f.length, _e = 0;
              for (te = 0; te < Me; te++)
                L = f.charCodeAt(te), (L & 64512) === 55296 && te + 1 < Me && (Q = f.charCodeAt(te + 1), (Q & 64512) === 56320 && (L = 65536 + (L - 55296 << 10) + (Q - 56320), te++)), _e += L < 128 ? 1 : L < 2048 ? 2 : L < 65536 ? 3 : 4;
              for (N = new Uint8Array(_e), ee = 0, te = 0; ee < _e; te++)
                L = f.charCodeAt(te), (L & 64512) === 55296 && te + 1 < Me && (Q = f.charCodeAt(te + 1), (Q & 64512) === 56320 && (L = 65536 + (L - 55296 << 10) + (Q - 56320), te++)), L < 128 ? N[ee++] = L : L < 2048 ? (N[ee++] = 192 | L >>> 6, N[ee++] = 128 | L & 63) : L < 65536 ? (N[ee++] = 224 | L >>> 12, N[ee++] = 128 | L >>> 6 & 63, N[ee++] = 128 | L & 63) : (N[ee++] = 240 | L >>> 18, N[ee++] = 128 | L >>> 12 & 63, N[ee++] = 128 | L >>> 6 & 63, N[ee++] = 128 | L & 63);
              return N;
            };
            const Ln = (f, N) => {
              if (N < 65534 && f.subarray && $i)
                return String.fromCharCode.apply(null, f.length === N ? f : f.subarray(0, N));
              let L = "";
              for (let Q = 0; Q < N; Q++)
                L += String.fromCharCode(f[Q]);
              return L;
            };
            var Dn = (f, N) => {
              const L = N || f.length;
              if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
                return new TextDecoder().decode(f.subarray(0, N));
              let Q, te;
              const ee = new Array(L * 2);
              for (te = 0, Q = 0; Q < L; ) {
                let Me = f[Q++];
                if (Me < 128) {
                  ee[te++] = Me;
                  continue;
                }
                let _e = si[Me];
                if (_e > 4) {
                  ee[te++] = 65533, Q += _e - 1;
                  continue;
                }
                for (Me &= _e === 2 ? 31 : _e === 3 ? 15 : 7; _e > 1 && Q < L; )
                  Me = Me << 6 | f[Q++] & 63, _e--;
                if (_e > 1) {
                  ee[te++] = 65533;
                  continue;
                }
                Me < 65536 ? ee[te++] = Me : (Me -= 65536, ee[te++] = 55296 | Me >> 10 & 1023, ee[te++] = 56320 | Me & 1023);
              }
              return Ln(ee, te);
            }, Sn = (f, N) => {
              N = N || f.length, N > f.length && (N = f.length);
              let L = N - 1;
              for (; L >= 0 && (f[L] & 192) === 128; )
                L--;
              return L < 0 || L === 0 ? N : L + si[f[L]] > N ? L : N;
            }, ai = {
              string2buf: Cn,
              buf2string: Dn,
              utf8border: Sn
            };
            function On() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            var Qi = On;
            const Ji = Object.prototype.toString, {
              Z_NO_FLUSH: Tn,
              Z_SYNC_FLUSH: Pn,
              Z_FULL_FLUSH: In,
              Z_FINISH: Rn,
              Z_OK: pi,
              Z_STREAM_END: zn,
              Z_DEFAULT_COMPRESSION: Bn,
              Z_DEFAULT_STRATEGY: Fn,
              Z_DEFLATED: Un
            } = ve;
            function oi(f) {
              this.options = vi.assign({
                level: Bn,
                method: Un,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Fn
              }, f || {});
              let N = this.options;
              N.raw && N.windowBits > 0 ? N.windowBits = -N.windowBits : N.gzip && N.windowBits > 0 && N.windowBits < 16 && (N.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Qi(), this.strm.avail_out = 0;
              let L = ni.deflateInit2(
                this.strm,
                N.level,
                N.method,
                N.windowBits,
                N.memLevel,
                N.strategy
              );
              if (L !== pi)
                throw new Error(ge[L]);
              if (N.header && ni.deflateSetHeader(this.strm, N.header), N.dictionary) {
                let Q;
                if (typeof N.dictionary == "string" ? Q = ai.string2buf(N.dictionary) : Ji.call(N.dictionary) === "[object ArrayBuffer]" ? Q = new Uint8Array(N.dictionary) : Q = N.dictionary, L = ni.deflateSetDictionary(this.strm, Q), L !== pi)
                  throw new Error(ge[L]);
                this._dict_set = !0;
              }
            }
            oi.prototype.push = function(f, N) {
              const L = this.strm, Q = this.options.chunkSize;
              let te, ee;
              if (this.ended)
                return !1;
              for (N === ~~N ? ee = N : ee = N === !0 ? Rn : Tn, typeof f == "string" ? L.input = ai.string2buf(f) : Ji.call(f) === "[object ArrayBuffer]" ? L.input = new Uint8Array(f) : L.input = f, L.next_in = 0, L.avail_in = L.input.length; ; ) {
                if (L.avail_out === 0 && (L.output = new Uint8Array(Q), L.next_out = 0, L.avail_out = Q), (ee === Pn || ee === In) && L.avail_out <= 6) {
                  this.onData(L.output.subarray(0, L.next_out)), L.avail_out = 0;
                  continue;
                }
                if (te = ni.deflate(L, ee), te === zn)
                  return L.next_out > 0 && this.onData(L.output.subarray(0, L.next_out)), te = ni.deflateEnd(this.strm), this.onEnd(te), this.ended = !0, te === pi;
                if (L.avail_out === 0) {
                  this.onData(L.output);
                  continue;
                }
                if (ee > 0 && L.next_out > 0) {
                  this.onData(L.output.subarray(0, L.next_out)), L.avail_out = 0;
                  continue;
                }
                if (L.avail_in === 0)
                  break;
              }
              return !0;
            }, oi.prototype.onData = function(f) {
              this.chunks.push(f);
            }, oi.prototype.onEnd = function(f) {
              f === pi && (this.result = vi.flattenChunks(this.chunks)), this.chunks = [], this.err = f, this.msg = this.strm.msg;
            };
            function Ri(f, N) {
              const L = new oi(N);
              if (L.push(f, !0), L.err)
                throw L.msg || ge[L.err];
              return L.result;
            }
            function Wn(f, N) {
              return N = N || {}, N.raw = !0, Ri(f, N);
            }
            function Gn(f, N) {
              return N = N || {}, N.gzip = !0, Ri(f, N);
            }
            var Nn = oi, kn = Ri, Vn = Wn, jn = Gn, Hn = ve, Kn = {
              Deflate: Nn,
              deflate: kn,
              deflateRaw: Vn,
              gzip: jn,
              constants: Hn
            };
            const mi = 16209, Zn = 16191;
            var Yn = function(N, L) {
              let Q, te, ee, Me, _e, $e, he, Ae, ft, Xe, Ue, Qe, bt, lt, it, ut, st, Ye, ct, wt, Je, vt, ht, et;
              const ot = N.state;
              Q = N.next_in, ht = N.input, te = Q + (N.avail_in - 5), ee = N.next_out, et = N.output, Me = ee - (L - N.avail_out), _e = ee + (N.avail_out - 257), $e = ot.dmax, he = ot.wsize, Ae = ot.whave, ft = ot.wnext, Xe = ot.window, Ue = ot.hold, Qe = ot.bits, bt = ot.lencode, lt = ot.distcode, it = (1 << ot.lenbits) - 1, ut = (1 << ot.distbits) - 1;
              e:
                do {
                  Qe < 15 && (Ue += ht[Q++] << Qe, Qe += 8, Ue += ht[Q++] << Qe, Qe += 8), st = bt[Ue & it];
                  t:
                    for (; ; ) {
                      if (Ye = st >>> 24, Ue >>>= Ye, Qe -= Ye, Ye = st >>> 16 & 255, Ye === 0)
                        et[ee++] = st & 65535;
                      else if (Ye & 16) {
                        ct = st & 65535, Ye &= 15, Ye && (Qe < Ye && (Ue += ht[Q++] << Qe, Qe += 8), ct += Ue & (1 << Ye) - 1, Ue >>>= Ye, Qe -= Ye), Qe < 15 && (Ue += ht[Q++] << Qe, Qe += 8, Ue += ht[Q++] << Qe, Qe += 8), st = lt[Ue & ut];
                        i:
                          for (; ; ) {
                            if (Ye = st >>> 24, Ue >>>= Ye, Qe -= Ye, Ye = st >>> 16 & 255, Ye & 16) {
                              if (wt = st & 65535, Ye &= 15, Qe < Ye && (Ue += ht[Q++] << Qe, Qe += 8, Qe < Ye && (Ue += ht[Q++] << Qe, Qe += 8)), wt += Ue & (1 << Ye) - 1, wt > $e) {
                                N.msg = "invalid distance too far back", ot.mode = mi;
                                break e;
                              }
                              if (Ue >>>= Ye, Qe -= Ye, Ye = ee - Me, wt > Ye) {
                                if (Ye = wt - Ye, Ye > Ae && ot.sane) {
                                  N.msg = "invalid distance too far back", ot.mode = mi;
                                  break e;
                                }
                                if (Je = 0, vt = Xe, ft === 0) {
                                  if (Je += he - Ye, Ye < ct) {
                                    ct -= Ye;
                                    do
                                      et[ee++] = Xe[Je++];
                                    while (--Ye);
                                    Je = ee - wt, vt = et;
                                  }
                                } else if (ft < Ye) {
                                  if (Je += he + ft - Ye, Ye -= ft, Ye < ct) {
                                    ct -= Ye;
                                    do
                                      et[ee++] = Xe[Je++];
                                    while (--Ye);
                                    if (Je = 0, ft < ct) {
                                      Ye = ft, ct -= Ye;
                                      do
                                        et[ee++] = Xe[Je++];
                                      while (--Ye);
                                      Je = ee - wt, vt = et;
                                    }
                                  }
                                } else if (Je += ft - Ye, Ye < ct) {
                                  ct -= Ye;
                                  do
                                    et[ee++] = Xe[Je++];
                                  while (--Ye);
                                  Je = ee - wt, vt = et;
                                }
                                for (; ct > 2; )
                                  et[ee++] = vt[Je++], et[ee++] = vt[Je++], et[ee++] = vt[Je++], ct -= 3;
                                ct && (et[ee++] = vt[Je++], ct > 1 && (et[ee++] = vt[Je++]));
                              } else {
                                Je = ee - wt;
                                do
                                  et[ee++] = et[Je++], et[ee++] = et[Je++], et[ee++] = et[Je++], ct -= 3;
                                while (ct > 2);
                                ct && (et[ee++] = et[Je++], ct > 1 && (et[ee++] = et[Je++]));
                              }
                            } else if (Ye & 64) {
                              N.msg = "invalid distance code", ot.mode = mi;
                              break e;
                            } else {
                              st = lt[(st & 65535) + (Ue & (1 << Ye) - 1)];
                              continue i;
                            }
                            break;
                          }
                      } else if (Ye & 64)
                        if (Ye & 32) {
                          ot.mode = Zn;
                          break e;
                        } else {
                          N.msg = "invalid literal/length code", ot.mode = mi;
                          break e;
                        }
                      else {
                        st = bt[(st & 65535) + (Ue & (1 << Ye) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (Q < te && ee < _e);
              ct = Qe >> 3, Q -= ct, Qe -= ct << 3, Ue &= (1 << Qe) - 1, N.next_in = Q, N.next_out = ee, N.avail_in = Q < te ? 5 + (te - Q) : 5 - (Q - te), N.avail_out = ee < _e ? 257 + (_e - ee) : 257 - (ee - _e), ot.hold = Ue, ot.bits = Qe;
            };
            const Jt = 15, qi = 852, er = 592, tr = 0, zi = 1, ir = 2, Xn = new Uint16Array([
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ]), $n = new Uint8Array([
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ]), Qn = new Uint16Array([
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ]), Jn = new Uint8Array([
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ]);
            var li = (f, N, L, Q, te, ee, Me, _e) => {
              const $e = _e.bits;
              let he = 0, Ae = 0, ft = 0, Xe = 0, Ue = 0, Qe = 0, bt = 0, lt = 0, it = 0, ut = 0, st, Ye, ct, wt, Je, vt = null, ht;
              const et = new Uint16Array(Jt + 1), ot = new Uint16Array(Jt + 1);
              let Kt = null, $r, Mi, Ai;
              for (he = 0; he <= Jt; he++)
                et[he] = 0;
              for (Ae = 0; Ae < Q; Ae++)
                et[N[L + Ae]]++;
              for (Ue = $e, Xe = Jt; Xe >= 1 && et[Xe] === 0; Xe--)
                ;
              if (Ue > Xe && (Ue = Xe), Xe === 0)
                return te[ee++] = 1 << 24 | 64 << 16 | 0, te[ee++] = 1 << 24 | 64 << 16 | 0, _e.bits = 1, 0;
              for (ft = 1; ft < Xe && et[ft] === 0; ft++)
                ;
              for (Ue < ft && (Ue = ft), lt = 1, he = 1; he <= Jt; he++)
                if (lt <<= 1, lt -= et[he], lt < 0)
                  return -1;
              if (lt > 0 && (f === tr || Xe !== 1))
                return -1;
              for (ot[1] = 0, he = 1; he < Jt; he++)
                ot[he + 1] = ot[he] + et[he];
              for (Ae = 0; Ae < Q; Ae++)
                N[L + Ae] !== 0 && (Me[ot[N[L + Ae]]++] = Ae);
              if (f === tr ? (vt = Kt = Me, ht = 20) : f === zi ? (vt = Xn, Kt = $n, ht = 257) : (vt = Qn, Kt = Jn, ht = 0), ut = 0, Ae = 0, he = ft, Je = ee, Qe = Ue, bt = 0, ct = -1, it = 1 << Ue, wt = it - 1, f === zi && it > qi || f === ir && it > er)
                return 1;
              for (; ; ) {
                $r = he - bt, Me[Ae] + 1 < ht ? (Mi = 0, Ai = Me[Ae]) : Me[Ae] >= ht ? (Mi = Kt[Me[Ae] - ht], Ai = vt[Me[Ae] - ht]) : (Mi = 32 + 64, Ai = 0), st = 1 << he - bt, Ye = 1 << Qe, ft = Ye;
                do
                  Ye -= st, te[Je + (ut >> bt) + Ye] = $r << 24 | Mi << 16 | Ai | 0;
                while (Ye !== 0);
                for (st = 1 << he - 1; ut & st; )
                  st >>= 1;
                if (st !== 0 ? (ut &= st - 1, ut += st) : ut = 0, Ae++, --et[he] === 0) {
                  if (he === Xe)
                    break;
                  he = N[L + Me[Ae]];
                }
                if (he > Ue && (ut & wt) !== ct) {
                  for (bt === 0 && (bt = Ue), Je += ft, Qe = he - bt, lt = 1 << Qe; Qe + bt < Xe && (lt -= et[Qe + bt], !(lt <= 0)); )
                    Qe++, lt <<= 1;
                  if (it += 1 << Qe, f === zi && it > qi || f === ir && it > er)
                    return 1;
                  ct = ut & wt, te[ct] = Ue << 24 | Qe << 16 | Je - ee | 0;
                }
              }
              return ut !== 0 && (te[Je + ut] = he - bt << 24 | 64 << 16 | 0), _e.bits = Ue, 0;
            };
            const qn = 0, rr = 1, nr = 2, {
              Z_FINISH: sr,
              Z_BLOCK: es,
              Z_TREES: xi,
              Z_OK: jt,
              Z_STREAM_END: ts,
              Z_NEED_DICT: is,
              Z_STREAM_ERROR: St,
              Z_DATA_ERROR: ar,
              Z_MEM_ERROR: or,
              Z_BUF_ERROR: rs,
              Z_DEFLATED: lr
            } = ve, bi = 16180, hr = 16181, fr = 16182, dr = 16183, cr = 16184, ur = 16185, _r = 16186, gr = 16187, vr = 16188, pr = 16189, yi = 16190, Rt = 16191, Bi = 16192, mr = 16193, Fi = 16194, xr = 16195, br = 16196, yr = 16197, Er = 16198, Ei = 16199, wi = 16200, wr = 16201, Mr = 16202, Ar = 16203, Cr = 16204, Lr = 16205, Ui = 16206, Dr = 16207, Sr = 16208, xt = 16209, Or = 16210, Tr = 16211, ns = 852, ss = 592, as = 15, Pr = (f) => (f >>> 24 & 255) + (f >>> 8 & 65280) + ((f & 65280) << 8) + ((f & 255) << 24);
            function os() {
              this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            const Ht = (f) => {
              if (!f)
                return 1;
              const N = f.state;
              return !N || N.strm !== f || N.mode < bi || N.mode > Tr ? 1 : 0;
            }, Ir = (f) => {
              if (Ht(f))
                return St;
              const N = f.state;
              return f.total_in = f.total_out = N.total = 0, f.msg = "", N.wrap && (f.adler = N.wrap & 1), N.mode = bi, N.last = 0, N.havedict = 0, N.flags = -1, N.dmax = 32768, N.head = null, N.hold = 0, N.bits = 0, N.lencode = N.lendyn = new Int32Array(ns), N.distcode = N.distdyn = new Int32Array(ss), N.sane = 1, N.back = -1, jt;
            }, Rr = (f) => {
              if (Ht(f))
                return St;
              const N = f.state;
              return N.wsize = 0, N.whave = 0, N.wnext = 0, Ir(f);
            }, zr = (f, N) => {
              let L;
              if (Ht(f))
                return St;
              const Q = f.state;
              return N < 0 ? (L = 0, N = -N) : (L = (N >> 4) + 5, N < 48 && (N &= 15)), N && (N < 8 || N > 15) ? St : (Q.window !== null && Q.wbits !== N && (Q.window = null), Q.wrap = L, Q.wbits = N, Rr(f));
            }, Br = (f, N) => {
              if (!f)
                return St;
              const L = new os();
              f.state = L, L.strm = f, L.window = null, L.mode = bi;
              const Q = zr(f, N);
              return Q !== jt && (f.state = null), Q;
            }, ls = (f) => Br(f, as);
            let Fr = !0, Wi, Gi;
            const hs = (f) => {
              if (Fr) {
                Wi = new Int32Array(512), Gi = new Int32Array(32);
                let N = 0;
                for (; N < 144; )
                  f.lens[N++] = 8;
                for (; N < 256; )
                  f.lens[N++] = 9;
                for (; N < 280; )
                  f.lens[N++] = 7;
                for (; N < 288; )
                  f.lens[N++] = 8;
                for (li(rr, f.lens, 0, 288, Wi, 0, f.work, { bits: 9 }), N = 0; N < 32; )
                  f.lens[N++] = 5;
                li(nr, f.lens, 0, 32, Gi, 0, f.work, { bits: 5 }), Fr = !1;
              }
              f.lencode = Wi, f.lenbits = 9, f.distcode = Gi, f.distbits = 5;
            }, Ur = (f, N, L, Q) => {
              let te;
              const ee = f.state;
              return ee.window === null && (ee.wsize = 1 << ee.wbits, ee.wnext = 0, ee.whave = 0, ee.window = new Uint8Array(ee.wsize)), Q >= ee.wsize ? (ee.window.set(N.subarray(L - ee.wsize, L), 0), ee.wnext = 0, ee.whave = ee.wsize) : (te = ee.wsize - ee.wnext, te > Q && (te = Q), ee.window.set(N.subarray(L - Q, L - Q + te), ee.wnext), Q -= te, Q ? (ee.window.set(N.subarray(L - Q, L), 0), ee.wnext = Q, ee.whave = ee.wsize) : (ee.wnext += te, ee.wnext === ee.wsize && (ee.wnext = 0), ee.whave < ee.wsize && (ee.whave += te))), 0;
            }, fs = (f, N) => {
              let L, Q, te, ee, Me, _e, $e, he, Ae, ft, Xe, Ue, Qe, bt, lt = 0, it, ut, st, Ye, ct, wt, Je, vt;
              const ht = new Uint8Array(4);
              let et, ot;
              const Kt = (
                /* permutation of code lengths */
                new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              );
              if (Ht(f) || !f.output || !f.input && f.avail_in !== 0)
                return St;
              L = f.state, L.mode === Rt && (L.mode = Bi), Me = f.next_out, te = f.output, $e = f.avail_out, ee = f.next_in, Q = f.input, _e = f.avail_in, he = L.hold, Ae = L.bits, ft = _e, Xe = $e, vt = jt;
              e:
                for (; ; )
                  switch (L.mode) {
                    case bi:
                      if (L.wrap === 0) {
                        L.mode = Bi;
                        break;
                      }
                      for (; Ae < 16; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if (L.wrap & 2 && he === 35615) {
                        L.wbits === 0 && (L.wbits = 15), L.check = 0, ht[0] = he & 255, ht[1] = he >>> 8 & 255, L.check = I(L.check, ht, 2, 0), he = 0, Ae = 0, L.mode = hr;
                        break;
                      }
                      if (L.head && (L.head.done = !1), !(L.wrap & 1) || /* check if zlib header allowed */
                      (((he & 255) << 8) + (he >> 8)) % 31) {
                        f.msg = "incorrect header check", L.mode = xt;
                        break;
                      }
                      if ((he & 15) !== lr) {
                        f.msg = "unknown compression method", L.mode = xt;
                        break;
                      }
                      if (he >>>= 4, Ae -= 4, Je = (he & 15) + 8, L.wbits === 0 && (L.wbits = Je), Je > 15 || Je > L.wbits) {
                        f.msg = "invalid window size", L.mode = xt;
                        break;
                      }
                      L.dmax = 1 << L.wbits, L.flags = 0, f.adler = L.check = 1, L.mode = he & 512 ? pr : Rt, he = 0, Ae = 0;
                      break;
                    case hr:
                      for (; Ae < 16; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if (L.flags = he, (L.flags & 255) !== lr) {
                        f.msg = "unknown compression method", L.mode = xt;
                        break;
                      }
                      if (L.flags & 57344) {
                        f.msg = "unknown header flags set", L.mode = xt;
                        break;
                      }
                      L.head && (L.head.text = he >> 8 & 1), L.flags & 512 && L.wrap & 4 && (ht[0] = he & 255, ht[1] = he >>> 8 & 255, L.check = I(L.check, ht, 2, 0)), he = 0, Ae = 0, L.mode = fr;
                    case fr:
                      for (; Ae < 32; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      L.head && (L.head.time = he), L.flags & 512 && L.wrap & 4 && (ht[0] = he & 255, ht[1] = he >>> 8 & 255, ht[2] = he >>> 16 & 255, ht[3] = he >>> 24 & 255, L.check = I(L.check, ht, 4, 0)), he = 0, Ae = 0, L.mode = dr;
                    case dr:
                      for (; Ae < 16; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      L.head && (L.head.xflags = he & 255, L.head.os = he >> 8), L.flags & 512 && L.wrap & 4 && (ht[0] = he & 255, ht[1] = he >>> 8 & 255, L.check = I(L.check, ht, 2, 0)), he = 0, Ae = 0, L.mode = cr;
                    case cr:
                      if (L.flags & 1024) {
                        for (; Ae < 16; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        L.length = he, L.head && (L.head.extra_len = he), L.flags & 512 && L.wrap & 4 && (ht[0] = he & 255, ht[1] = he >>> 8 & 255, L.check = I(L.check, ht, 2, 0)), he = 0, Ae = 0;
                      } else
                        L.head && (L.head.extra = null);
                      L.mode = ur;
                    case ur:
                      if (L.flags & 1024 && (Ue = L.length, Ue > _e && (Ue = _e), Ue && (L.head && (Je = L.head.extra_len - L.length, L.head.extra || (L.head.extra = new Uint8Array(L.head.extra_len)), L.head.extra.set(
                        Q.subarray(
                          ee,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          ee + Ue
                        ),
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        Je
                      )), L.flags & 512 && L.wrap & 4 && (L.check = I(L.check, Q, Ue, ee)), _e -= Ue, ee += Ue, L.length -= Ue), L.length))
                        break e;
                      L.length = 0, L.mode = _r;
                    case _r:
                      if (L.flags & 2048) {
                        if (_e === 0)
                          break e;
                        Ue = 0;
                        do
                          Je = Q[ee + Ue++], L.head && Je && L.length < 65536 && (L.head.name += String.fromCharCode(Je));
                        while (Je && Ue < _e);
                        if (L.flags & 512 && L.wrap & 4 && (L.check = I(L.check, Q, Ue, ee)), _e -= Ue, ee += Ue, Je)
                          break e;
                      } else
                        L.head && (L.head.name = null);
                      L.length = 0, L.mode = gr;
                    case gr:
                      if (L.flags & 4096) {
                        if (_e === 0)
                          break e;
                        Ue = 0;
                        do
                          Je = Q[ee + Ue++], L.head && Je && L.length < 65536 && (L.head.comment += String.fromCharCode(Je));
                        while (Je && Ue < _e);
                        if (L.flags & 512 && L.wrap & 4 && (L.check = I(L.check, Q, Ue, ee)), _e -= Ue, ee += Ue, Je)
                          break e;
                      } else
                        L.head && (L.head.comment = null);
                      L.mode = vr;
                    case vr:
                      if (L.flags & 512) {
                        for (; Ae < 16; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        if (L.wrap & 4 && he !== (L.check & 65535)) {
                          f.msg = "header crc mismatch", L.mode = xt;
                          break;
                        }
                        he = 0, Ae = 0;
                      }
                      L.head && (L.head.hcrc = L.flags >> 9 & 1, L.head.done = !0), f.adler = L.check = 0, L.mode = Rt;
                      break;
                    case pr:
                      for (; Ae < 32; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      f.adler = L.check = Pr(he), he = 0, Ae = 0, L.mode = yi;
                    case yi:
                      if (L.havedict === 0)
                        return f.next_out = Me, f.avail_out = $e, f.next_in = ee, f.avail_in = _e, L.hold = he, L.bits = Ae, is;
                      f.adler = L.check = 1, L.mode = Rt;
                    case Rt:
                      if (N === es || N === xi)
                        break e;
                    case Bi:
                      if (L.last) {
                        he >>>= Ae & 7, Ae -= Ae & 7, L.mode = Ui;
                        break;
                      }
                      for (; Ae < 3; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      switch (L.last = he & 1, he >>>= 1, Ae -= 1, he & 3) {
                        case 0:
                          L.mode = mr;
                          break;
                        case 1:
                          if (hs(L), L.mode = Ei, N === xi) {
                            he >>>= 2, Ae -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          L.mode = br;
                          break;
                        case 3:
                          f.msg = "invalid block type", L.mode = xt;
                      }
                      he >>>= 2, Ae -= 2;
                      break;
                    case mr:
                      for (he >>>= Ae & 7, Ae -= Ae & 7; Ae < 32; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if ((he & 65535) !== (he >>> 16 ^ 65535)) {
                        f.msg = "invalid stored block lengths", L.mode = xt;
                        break;
                      }
                      if (L.length = he & 65535, he = 0, Ae = 0, L.mode = Fi, N === xi)
                        break e;
                    case Fi:
                      L.mode = xr;
                    case xr:
                      if (Ue = L.length, Ue) {
                        if (Ue > _e && (Ue = _e), Ue > $e && (Ue = $e), Ue === 0)
                          break e;
                        te.set(Q.subarray(ee, ee + Ue), Me), _e -= Ue, ee += Ue, $e -= Ue, Me += Ue, L.length -= Ue;
                        break;
                      }
                      L.mode = Rt;
                      break;
                    case br:
                      for (; Ae < 14; ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if (L.nlen = (he & 31) + 257, he >>>= 5, Ae -= 5, L.ndist = (he & 31) + 1, he >>>= 5, Ae -= 5, L.ncode = (he & 15) + 4, he >>>= 4, Ae -= 4, L.nlen > 286 || L.ndist > 30) {
                        f.msg = "too many length or distance symbols", L.mode = xt;
                        break;
                      }
                      L.have = 0, L.mode = yr;
                    case yr:
                      for (; L.have < L.ncode; ) {
                        for (; Ae < 3; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        L.lens[Kt[L.have++]] = he & 7, he >>>= 3, Ae -= 3;
                      }
                      for (; L.have < 19; )
                        L.lens[Kt[L.have++]] = 0;
                      if (L.lencode = L.lendyn, L.lenbits = 7, et = { bits: L.lenbits }, vt = li(qn, L.lens, 0, 19, L.lencode, 0, L.work, et), L.lenbits = et.bits, vt) {
                        f.msg = "invalid code lengths set", L.mode = xt;
                        break;
                      }
                      L.have = 0, L.mode = Er;
                    case Er:
                      for (; L.have < L.nlen + L.ndist; ) {
                        for (; lt = L.lencode[he & (1 << L.lenbits) - 1], it = lt >>> 24, ut = lt >>> 16 & 255, st = lt & 65535, !(it <= Ae); ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        if (st < 16)
                          he >>>= it, Ae -= it, L.lens[L.have++] = st;
                        else {
                          if (st === 16) {
                            for (ot = it + 2; Ae < ot; ) {
                              if (_e === 0)
                                break e;
                              _e--, he += Q[ee++] << Ae, Ae += 8;
                            }
                            if (he >>>= it, Ae -= it, L.have === 0) {
                              f.msg = "invalid bit length repeat", L.mode = xt;
                              break;
                            }
                            Je = L.lens[L.have - 1], Ue = 3 + (he & 3), he >>>= 2, Ae -= 2;
                          } else if (st === 17) {
                            for (ot = it + 3; Ae < ot; ) {
                              if (_e === 0)
                                break e;
                              _e--, he += Q[ee++] << Ae, Ae += 8;
                            }
                            he >>>= it, Ae -= it, Je = 0, Ue = 3 + (he & 7), he >>>= 3, Ae -= 3;
                          } else {
                            for (ot = it + 7; Ae < ot; ) {
                              if (_e === 0)
                                break e;
                              _e--, he += Q[ee++] << Ae, Ae += 8;
                            }
                            he >>>= it, Ae -= it, Je = 0, Ue = 11 + (he & 127), he >>>= 7, Ae -= 7;
                          }
                          if (L.have + Ue > L.nlen + L.ndist) {
                            f.msg = "invalid bit length repeat", L.mode = xt;
                            break;
                          }
                          for (; Ue--; )
                            L.lens[L.have++] = Je;
                        }
                      }
                      if (L.mode === xt)
                        break;
                      if (L.lens[256] === 0) {
                        f.msg = "invalid code -- missing end-of-block", L.mode = xt;
                        break;
                      }
                      if (L.lenbits = 9, et = { bits: L.lenbits }, vt = li(rr, L.lens, 0, L.nlen, L.lencode, 0, L.work, et), L.lenbits = et.bits, vt) {
                        f.msg = "invalid literal/lengths set", L.mode = xt;
                        break;
                      }
                      if (L.distbits = 6, L.distcode = L.distdyn, et = { bits: L.distbits }, vt = li(nr, L.lens, L.nlen, L.ndist, L.distcode, 0, L.work, et), L.distbits = et.bits, vt) {
                        f.msg = "invalid distances set", L.mode = xt;
                        break;
                      }
                      if (L.mode = Ei, N === xi)
                        break e;
                    case Ei:
                      L.mode = wi;
                    case wi:
                      if (_e >= 6 && $e >= 258) {
                        f.next_out = Me, f.avail_out = $e, f.next_in = ee, f.avail_in = _e, L.hold = he, L.bits = Ae, Yn(f, Xe), Me = f.next_out, te = f.output, $e = f.avail_out, ee = f.next_in, Q = f.input, _e = f.avail_in, he = L.hold, Ae = L.bits, L.mode === Rt && (L.back = -1);
                        break;
                      }
                      for (L.back = 0; lt = L.lencode[he & (1 << L.lenbits) - 1], it = lt >>> 24, ut = lt >>> 16 & 255, st = lt & 65535, !(it <= Ae); ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if (ut && !(ut & 240)) {
                        for (Ye = it, ct = ut, wt = st; lt = L.lencode[wt + ((he & (1 << Ye + ct) - 1) >> Ye)], it = lt >>> 24, ut = lt >>> 16 & 255, st = lt & 65535, !(Ye + it <= Ae); ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        he >>>= Ye, Ae -= Ye, L.back += Ye;
                      }
                      if (he >>>= it, Ae -= it, L.back += it, L.length = st, ut === 0) {
                        L.mode = Lr;
                        break;
                      }
                      if (ut & 32) {
                        L.back = -1, L.mode = Rt;
                        break;
                      }
                      if (ut & 64) {
                        f.msg = "invalid literal/length code", L.mode = xt;
                        break;
                      }
                      L.extra = ut & 15, L.mode = wr;
                    case wr:
                      if (L.extra) {
                        for (ot = L.extra; Ae < ot; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        L.length += he & (1 << L.extra) - 1, he >>>= L.extra, Ae -= L.extra, L.back += L.extra;
                      }
                      L.was = L.length, L.mode = Mr;
                    case Mr:
                      for (; lt = L.distcode[he & (1 << L.distbits) - 1], it = lt >>> 24, ut = lt >>> 16 & 255, st = lt & 65535, !(it <= Ae); ) {
                        if (_e === 0)
                          break e;
                        _e--, he += Q[ee++] << Ae, Ae += 8;
                      }
                      if (!(ut & 240)) {
                        for (Ye = it, ct = ut, wt = st; lt = L.distcode[wt + ((he & (1 << Ye + ct) - 1) >> Ye)], it = lt >>> 24, ut = lt >>> 16 & 255, st = lt & 65535, !(Ye + it <= Ae); ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        he >>>= Ye, Ae -= Ye, L.back += Ye;
                      }
                      if (he >>>= it, Ae -= it, L.back += it, ut & 64) {
                        f.msg = "invalid distance code", L.mode = xt;
                        break;
                      }
                      L.offset = st, L.extra = ut & 15, L.mode = Ar;
                    case Ar:
                      if (L.extra) {
                        for (ot = L.extra; Ae < ot; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        L.offset += he & (1 << L.extra) - 1, he >>>= L.extra, Ae -= L.extra, L.back += L.extra;
                      }
                      if (L.offset > L.dmax) {
                        f.msg = "invalid distance too far back", L.mode = xt;
                        break;
                      }
                      L.mode = Cr;
                    case Cr:
                      if ($e === 0)
                        break e;
                      if (Ue = Xe - $e, L.offset > Ue) {
                        if (Ue = L.offset - Ue, Ue > L.whave && L.sane) {
                          f.msg = "invalid distance too far back", L.mode = xt;
                          break;
                        }
                        Ue > L.wnext ? (Ue -= L.wnext, Qe = L.wsize - Ue) : Qe = L.wnext - Ue, Ue > L.length && (Ue = L.length), bt = L.window;
                      } else
                        bt = te, Qe = Me - L.offset, Ue = L.length;
                      Ue > $e && (Ue = $e), $e -= Ue, L.length -= Ue;
                      do
                        te[Me++] = bt[Qe++];
                      while (--Ue);
                      L.length === 0 && (L.mode = wi);
                      break;
                    case Lr:
                      if ($e === 0)
                        break e;
                      te[Me++] = L.length, $e--, L.mode = wi;
                      break;
                    case Ui:
                      if (L.wrap) {
                        for (; Ae < 32; ) {
                          if (_e === 0)
                            break e;
                          _e--, he |= Q[ee++] << Ae, Ae += 8;
                        }
                        if (Xe -= $e, f.total_out += Xe, L.total += Xe, L.wrap & 4 && Xe && (f.adler = L.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                        L.flags ? I(L.check, te, Xe, Me - Xe) : Ce(L.check, te, Xe, Me - Xe)), Xe = $e, L.wrap & 4 && (L.flags ? he : Pr(he)) !== L.check) {
                          f.msg = "incorrect data check", L.mode = xt;
                          break;
                        }
                        he = 0, Ae = 0;
                      }
                      L.mode = Dr;
                    case Dr:
                      if (L.wrap && L.flags) {
                        for (; Ae < 32; ) {
                          if (_e === 0)
                            break e;
                          _e--, he += Q[ee++] << Ae, Ae += 8;
                        }
                        if (L.wrap & 4 && he !== (L.total & 4294967295)) {
                          f.msg = "incorrect length check", L.mode = xt;
                          break;
                        }
                        he = 0, Ae = 0;
                      }
                      L.mode = Sr;
                    case Sr:
                      vt = ts;
                      break e;
                    case xt:
                      vt = ar;
                      break e;
                    case Or:
                      return or;
                    case Tr:
                    default:
                      return St;
                  }
              return f.next_out = Me, f.avail_out = $e, f.next_in = ee, f.avail_in = _e, L.hold = he, L.bits = Ae, (L.wsize || Xe !== f.avail_out && L.mode < xt && (L.mode < Ui || N !== sr)) && Ur(f, f.output, f.next_out, Xe - f.avail_out), ft -= f.avail_in, Xe -= f.avail_out, f.total_in += ft, f.total_out += Xe, L.total += Xe, L.wrap & 4 && Xe && (f.adler = L.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
              L.flags ? I(L.check, te, Xe, f.next_out - Xe) : Ce(L.check, te, Xe, f.next_out - Xe)), f.data_type = L.bits + (L.last ? 64 : 0) + (L.mode === Rt ? 128 : 0) + (L.mode === Ei || L.mode === Fi ? 256 : 0), (ft === 0 && Xe === 0 || N === sr) && vt === jt && (vt = rs), vt;
            }, ds = (f) => {
              if (Ht(f))
                return St;
              let N = f.state;
              return N.window && (N.window = null), f.state = null, jt;
            }, cs = (f, N) => {
              if (Ht(f))
                return St;
              const L = f.state;
              return L.wrap & 2 ? (L.head = N, N.done = !1, jt) : St;
            }, us = (f, N) => {
              const L = N.length;
              let Q, te, ee;
              return Ht(f) || (Q = f.state, Q.wrap !== 0 && Q.mode !== yi) ? St : Q.mode === yi && (te = 1, te = Ce(te, N, L, 0), te !== Q.check) ? ar : (ee = Ur(f, N, L, L), ee ? (Q.mode = Or, or) : (Q.havedict = 1, jt));
            };
            var _s = Rr, gs = zr, vs = Ir, ps = ls, ms = Br, xs = fs, bs = ds, ys = cs, Es = us, ws = "pako inflate (from Nodeca project)", zt = {
              inflateReset: _s,
              inflateReset2: gs,
              inflateResetKeep: vs,
              inflateInit: ps,
              inflateInit2: ms,
              inflate: xs,
              inflateEnd: bs,
              inflateGetHeader: ys,
              inflateSetDictionary: Es,
              inflateInfo: ws
            };
            function Ms() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            var As = Ms;
            const Wr = Object.prototype.toString, {
              Z_NO_FLUSH: Cs,
              Z_FINISH: Ls,
              Z_OK: hi,
              Z_STREAM_END: Ni,
              Z_NEED_DICT: ki,
              Z_STREAM_ERROR: Ds,
              Z_DATA_ERROR: Gr,
              Z_MEM_ERROR: Ss
            } = ve;
            function fi(f) {
              this.options = vi.assign({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
              }, f || {});
              const N = this.options;
              N.raw && N.windowBits >= 0 && N.windowBits < 16 && (N.windowBits = -N.windowBits, N.windowBits === 0 && (N.windowBits = -15)), N.windowBits >= 0 && N.windowBits < 16 && !(f && f.windowBits) && (N.windowBits += 32), N.windowBits > 15 && N.windowBits < 48 && (N.windowBits & 15 || (N.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Qi(), this.strm.avail_out = 0;
              let L = zt.inflateInit2(
                this.strm,
                N.windowBits
              );
              if (L !== hi)
                throw new Error(ge[L]);
              if (this.header = new As(), zt.inflateGetHeader(this.strm, this.header), N.dictionary && (typeof N.dictionary == "string" ? N.dictionary = ai.string2buf(N.dictionary) : Wr.call(N.dictionary) === "[object ArrayBuffer]" && (N.dictionary = new Uint8Array(N.dictionary)), N.raw && (L = zt.inflateSetDictionary(this.strm, N.dictionary), L !== hi)))
                throw new Error(ge[L]);
            }
            fi.prototype.push = function(f, N) {
              const L = this.strm, Q = this.options.chunkSize, te = this.options.dictionary;
              let ee, Me, _e;
              if (this.ended)
                return !1;
              for (N === ~~N ? Me = N : Me = N === !0 ? Ls : Cs, Wr.call(f) === "[object ArrayBuffer]" ? L.input = new Uint8Array(f) : L.input = f, L.next_in = 0, L.avail_in = L.input.length; ; ) {
                for (L.avail_out === 0 && (L.output = new Uint8Array(Q), L.next_out = 0, L.avail_out = Q), ee = zt.inflate(L, Me), ee === ki && te && (ee = zt.inflateSetDictionary(L, te), ee === hi ? ee = zt.inflate(L, Me) : ee === Gr && (ee = ki)); L.avail_in > 0 && ee === Ni && L.state.wrap > 0 && f[L.next_in] !== 0; )
                  zt.inflateReset(L), ee = zt.inflate(L, Me);
                switch (ee) {
                  case Ds:
                  case Gr:
                  case ki:
                  case Ss:
                    return this.onEnd(ee), this.ended = !0, !1;
                }
                if (_e = L.avail_out, L.next_out && (L.avail_out === 0 || ee === Ni))
                  if (this.options.to === "string") {
                    let $e = ai.utf8border(L.output, L.next_out), he = L.next_out - $e, Ae = ai.buf2string(L.output, $e);
                    L.next_out = he, L.avail_out = Q - he, he && L.output.set(L.output.subarray($e, $e + he), 0), this.onData(Ae);
                  } else
                    this.onData(L.output.length === L.next_out ? L.output : L.output.subarray(0, L.next_out));
                if (!(ee === hi && _e === 0)) {
                  if (ee === Ni)
                    return ee = zt.inflateEnd(this.strm), this.onEnd(ee), this.ended = !0, !0;
                  if (L.avail_in === 0)
                    break;
                }
              }
              return !0;
            }, fi.prototype.onData = function(f) {
              this.chunks.push(f);
            }, fi.prototype.onEnd = function(f) {
              f === hi && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = vi.flattenChunks(this.chunks)), this.chunks = [], this.err = f, this.msg = this.strm.msg;
            };
            function Vi(f, N) {
              const L = new fi(N);
              if (L.push(f), L.err)
                throw L.msg || ge[L.err];
              return L.result;
            }
            function Os(f, N) {
              return N = N || {}, N.raw = !0, Vi(f, N);
            }
            var Ts = fi, Ps = Vi, Is = Os, Rs = Vi, zs = ve, Bs = {
              Inflate: Ts,
              inflate: Ps,
              inflateRaw: Is,
              ungzip: Rs,
              constants: zs
            };
            const { Deflate: Fs, deflate: Us, deflateRaw: Ws, gzip: Gs } = Kn, { Inflate: Ns, inflate: ks, inflateRaw: Vs, ungzip: js } = Bs;
            var Nr = Fs, kr = Us, Vr = Ws, jr = Gs, Hr = Ns, Kr = ks, Zr = Vs, Yr = js, Xr = ve, Hs = {
              Deflate: Nr,
              deflate: kr,
              deflateRaw: Vr,
              gzip: jr,
              Inflate: Hr,
              inflate: Kr,
              inflateRaw: Zr,
              ungzip: Yr,
              constants: Xr
            };
          }
        )
        /******/
      }, __webpack_module_cache__ = {};
      function __webpack_require__(P) {
        var _ = __webpack_module_cache__[P];
        if (_ !== void 0)
          return _.exports;
        var s = __webpack_module_cache__[P] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[P].call(s.exports, s, s.exports, __webpack_require__), s.exports;
      }
      __webpack_require__.n = (P) => {
        var _ = P && P.__esModule ? (
          /******/
          () => P.default
        ) : (
          /******/
          () => P
        );
        return __webpack_require__.d(_, { a: _ }), _;
      }, __webpack_require__.d = (P, _) => {
        for (var s in _)
          __webpack_require__.o(_, s) && !__webpack_require__.o(P, s) && Object.defineProperty(P, s, { enumerable: !0, get: _[s] });
      }, __webpack_require__.o = (P, _) => Object.prototype.hasOwnProperty.call(P, _), __webpack_require__.r = (P) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(P, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(P, "__esModule", { value: !0 });
      }, __webpack_require__("./src/index.ts"), __webpack_require__("./src/SurfaceWorker.js");
      var __webpack_exports__ = __webpack_require__("./src/exporter.js");
      return __webpack_exports__;
    })()
  ));
})(_3Dmol);
var _3DmolExports = _3Dmol.exports;
const Dmol = /* @__PURE__ */ getDefaultExportFromCjs(_3DmolExports), Gallery_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$3,
  add_iframe_resize_listener,
  add_render_callback,
  append: append$2,
  attr: attr$2,
  check_outros: check_outros$1,
  create_component: create_component$2,
  destroy_component: destroy_component$2,
  destroy_each: destroy_each$1,
  detach: detach$3,
  element: element$2,
  empty: empty$1,
  ensure_array_like: ensure_array_like$1,
  group_outros: group_outros$1,
  init: init$3,
  insert: insert$3,
  listen,
  mount_component: mount_component$2,
  noop: noop$3,
  safe_not_equal: safe_not_equal$4,
  set_data: set_data$1,
  set_style: set_style$2,
  space: space$2,
  text: text$1,
  toggle_class: toggle_class$2,
  transition_in: transition_in$2,
  transition_out: transition_out$2
} = window.__gradio__svelte__internal, { afterUpdate } = window.__gradio__svelte__internal;
function get_each_context$1(P, _, s) {
  const v = P.slice();
  return v[14] = _[s], v[16] = s, v;
}
function create_if_block_2$1(P) {
  let _, s;
  return _ = new BlockLabel({
    props: {
      show_label: (
        /*show_label*/
        P[0]
      ),
      Icon: Image,
      label: (
        /*label*/
        P[1] || "Gallery"
      )
    }
  }), {
    c() {
      create_component$2(_.$$.fragment);
    },
    m(v, M) {
      mount_component$2(_, v, M), s = !0;
    },
    p(v, M) {
      const E = {};
      M & /*show_label*/
      1 && (E.show_label = /*show_label*/
      v[0]), M & /*label*/
      2 && (E.label = /*label*/
      v[1] || "Gallery"), _.$set(E);
    },
    i(v) {
      s || (transition_in$2(_.$$.fragment, v), s = !0);
    },
    o(v) {
      transition_out$2(_.$$.fragment, v), s = !1;
    },
    d(v) {
      destroy_component$2(_, v);
    }
  };
}
function create_else_block$1(P) {
  let _, s, v, M = ensure_array_like$1(
    /*_value*/
    P[6]
  ), E = [];
  for (let A = 0; A < M.length; A += 1)
    E[A] = create_each_block$1(get_each_context$1(P, M, A));
  return {
    c() {
      _ = element$2("div"), s = element$2("div");
      for (let A = 0; A < E.length; A += 1)
        E[A].c();
      attr$2(s, "class", "grid-container svelte-1xw0nij"), set_style$2(
        s,
        "--grid-cols",
        /*columns*/
        P[3]
      ), set_style$2(
        s,
        "--grid-rows",
        /*rows*/
        P[4]
      ), set_style$2(
        s,
        "height",
        /*height*/
        P[5]
      ), toggle_class$2(
        s,
        "pt-6",
        /*show_label*/
        P[0]
      ), attr$2(_, "class", "grid-wrap svelte-1xw0nij"), add_render_callback(() => (
        /*div1_elementresize_handler*/
        P[12].call(_)
      )), toggle_class$2(_, "fixed-height", !/*height*/
      P[5] || /*height*/
      P[5] == "auto");
    },
    m(A, h) {
      insert$3(A, _, h), append$2(_, s);
      for (let g = 0; g < E.length; g += 1)
        E[g] && E[g].m(s, null);
      v = add_iframe_resize_listener(
        _,
        /*div1_elementresize_handler*/
        P[12].bind(_)
      );
    },
    p(A, h) {
      if (h & /*_value, handleContextMenu*/
      64) {
        M = ensure_array_like$1(
          /*_value*/
          A[6]
        );
        let g;
        for (g = 0; g < M.length; g += 1) {
          const C = get_each_context$1(A, M, g);
          E[g] ? E[g].p(C, h) : (E[g] = create_each_block$1(C), E[g].c(), E[g].m(s, null));
        }
        for (; g < E.length; g += 1)
          E[g].d(1);
        E.length = M.length;
      }
      h & /*columns*/
      8 && set_style$2(
        s,
        "--grid-cols",
        /*columns*/
        A[3]
      ), h & /*rows*/
      16 && set_style$2(
        s,
        "--grid-rows",
        /*rows*/
        A[4]
      ), h & /*height*/
      32 && set_style$2(
        s,
        "height",
        /*height*/
        A[5]
      ), h & /*show_label*/
      1 && toggle_class$2(
        s,
        "pt-6",
        /*show_label*/
        A[0]
      ), h & /*height*/
      32 && toggle_class$2(_, "fixed-height", !/*height*/
      A[5] || /*height*/
      A[5] == "auto");
    },
    i: noop$3,
    o: noop$3,
    d(A) {
      A && detach$3(_), destroy_each$1(E, A), v();
    }
  };
}
function create_if_block$1(P) {
  let _, s;
  return _ = new Empty({
    props: {
      unpadded_box: !0,
      size: "large",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx: P }
    }
  }), {
    c() {
      create_component$2(_.$$.fragment);
    },
    m(v, M) {
      mount_component$2(_, v, M), s = !0;
    },
    p(v, M) {
      const E = {};
      M & /*$$scope*/
      131072 && (E.$$scope = { dirty: M, ctx: v }), _.$set(E);
    },
    i(v) {
      s || (transition_in$2(_.$$.fragment, v), s = !0);
    },
    o(v) {
      transition_out$2(_.$$.fragment, v), s = !1;
    },
    d(v) {
      destroy_component$2(_, v);
    }
  };
}
function create_if_block_1$1(P) {
  let _, s = (
    /*entry*/
    P[14].caption + ""
  ), v;
  return {
    c() {
      _ = element$2("div"), v = text$1(s), attr$2(_, "class", "caption-label svelte-1xw0nij");
    },
    m(M, E) {
      insert$3(M, _, E), append$2(_, v);
    },
    p(M, E) {
      E & /*_value*/
      64 && s !== (s = /*entry*/
      M[14].caption + "") && set_data$1(v, s);
    },
    d(M) {
      M && detach$3(_);
    }
  };
}
function create_each_block$1(P) {
  let _, s, v, M, E, A, h, g = (
    /*entry*/
    P[14].caption && create_if_block_1$1(P)
  );
  return {
    c() {
      _ = element$2("div"), s = element$2("div"), v = space$2(), g && g.c(), M = space$2(), attr$2(s, "id", "mol-canvas-id-" + /*i*/
      (P[16] + 1)), attr$2(s, "class", "mol-canvas svelte-1xw0nij"), attr$2(_, "class", "molecule-item molecule-lg, mol-container svelte-1xw0nij"), attr$2(_, "aria-label", E = "Molecule " + /*i*/
      (P[16] + 1) + " of " + /*_value*/
      P[6].length);
    },
    m(C, c) {
      insert$3(C, _, c), append$2(_, s), append$2(_, v), g && g.m(_, null), append$2(_, M), A || (h = listen(s, "contextmenu", handleContextMenu), A = !0);
    },
    p(C, c) {
      /*entry*/
      C[14].caption ? g ? g.p(C, c) : (g = create_if_block_1$1(C), g.c(), g.m(_, M)) : g && (g.d(1), g = null), c & /*_value*/
      64 && E !== (E = "Molecule " + /*i*/
      (C[16] + 1) + " of " + /*_value*/
      C[6].length) && attr$2(_, "aria-label", E);
    },
    d(C) {
      C && detach$3(_), g && g.d(), A = !1, h();
    }
  };
}
function create_default_slot$1(P) {
  let _, s;
  return _ = new Image({}), {
    c() {
      create_component$2(_.$$.fragment);
    },
    m(v, M) {
      mount_component$2(_, v, M), s = !0;
    },
    i(v) {
      s || (transition_in$2(_.$$.fragment, v), s = !0);
    },
    o(v) {
      transition_out$2(_.$$.fragment, v), s = !1;
    },
    d(v) {
      destroy_component$2(_, v);
    }
  };
}
function create_fragment$3(P) {
  let _, s, v, M, E, A, h;
  add_render_callback(
    /*onwindowresize*/
    P[11]
  );
  let g = (
    /*show_label*/
    P[0] && create_if_block_2$1(P)
  );
  const C = [create_if_block$1, create_else_block$1], c = [];
  function S(y, b) {
    return (
      /*value*/
      y[2] === null || /*_value*/
      y[6] === null || /*_value*/
      y[6].length === 0 ? 0 : 1
    );
  }
  return s = S(P), v = c[s] = C[s](P), {
    c() {
      g && g.c(), _ = space$2(), v.c(), M = empty$1();
    },
    m(y, b) {
      g && g.m(y, b), insert$3(y, _, b), c[s].m(y, b), insert$3(y, M, b), E = !0, A || (h = listen(
        window,
        "resize",
        /*onwindowresize*/
        P[11]
      ), A = !0);
    },
    p(y, [b]) {
      /*show_label*/
      y[0] ? g ? (g.p(y, b), b & /*show_label*/
      1 && transition_in$2(g, 1)) : (g = create_if_block_2$1(y), g.c(), transition_in$2(g, 1), g.m(_.parentNode, _)) : g && (group_outros$1(), transition_out$2(g, 1, 1, () => {
        g = null;
      }), check_outros$1());
      let w = s;
      s = S(y), s === w ? c[s].p(y, b) : (group_outros$1(), transition_out$2(c[w], 1, 1, () => {
        c[w] = null;
      }), check_outros$1(), v = c[s], v ? v.p(y, b) : (v = c[s] = C[s](y), v.c()), transition_in$2(v, 1), v.m(M.parentNode, M));
    },
    i(y) {
      E || (transition_in$2(g), transition_in$2(v), E = !0);
    },
    o(y) {
      transition_out$2(g), transition_out$2(v), E = !1;
    },
    d(y) {
      y && (detach$3(_), detach$3(M)), g && g.d(y), c[s].d(y), A = !1, h();
    }
  };
}
function rotateMolecule(P) {
  P.rotate(0.3, "y"), P.rotate(0.3, "x"), requestAnimationFrame((_) => rotateMolecule(P));
}
function handleContextMenu(P) {
  P.preventDefault();
  const _ = P.target, s = P.currentTarget.id;
  console.log(s);
  var v = _.toDataURL("image/png"), M = document.createElement("a");
  M.href = v, M.download = s + ".png", document.body.appendChild(M), M.click(), document.body.removeChild(M);
}
function instance$3(P, _, s) {
  let { show_label: v = !0 } = _, { label: M } = _, { value: E = null } = _, { columns: A = [2] } = _, { rows: h = void 0 } = _, { height: g = "auto" } = _, { automatic_rotation: C = !0 } = _, c = !0, S = null, y = 0, b = 0;
  function w(u, o) {
    let l = Dmol.createViewer(o, {});
    return l.addModel(u, "pdb" + { _value: S }), l.setStyle({ stick: {} }), l.setBackgroundColor("white"), l.zoomTo(), l.render(), l;
  }
  afterUpdate(() => {
    S && S.forEach((u, o) => {
      const l = "mol-canvas-id-" + (o + 1);
      let e = w(u.molecule, l);
      C && rotateMolecule(e);
    });
  });
  function t() {
    s(8, b = window.innerHeight);
  }
  function r() {
    y = this.clientHeight, s(7, y);
  }
  return P.$$set = (u) => {
    "show_label" in u && s(0, v = u.show_label), "label" in u && s(1, M = u.label), "value" in u && s(2, E = u.value), "columns" in u && s(3, A = u.columns), "rows" in u && s(4, h = u.rows), "height" in u && s(5, g = u.height), "automatic_rotation" in u && s(9, C = u.automatic_rotation);
  }, P.$$.update = () => {
    P.$$.dirty & /*value, was_reset*/
    1028 && s(10, c = E == null || E.length == 0 ? !0 : c), P.$$.dirty & /*value*/
    4 && s(6, S = E === null ? null : E.map((u, o) => ({
      molecule: u.molecule,
      caption: u.caption
    })));
  }, [
    v,
    M,
    E,
    A,
    h,
    g,
    S,
    y,
    b,
    C,
    c,
    t,
    r
  ];
}
class Gallery extends SvelteComponent$3 {
  constructor(_) {
    super(), init$3(this, _, instance$3, create_fragment$3, safe_not_equal$4, {
      show_label: 0,
      label: 1,
      value: 2,
      columns: 3,
      rows: 4,
      height: 5,
      automatic_rotation: 9
    });
  }
}
function pretty_si(P) {
  let _ = ["", "k", "M", "G", "T", "P", "E", "Z"], s = 0;
  for (; P > 1e3 && s < _.length - 1; )
    P /= 1e3, s++;
  let v = _[s];
  return (Number.isInteger(P) ? P : P.toFixed(1)) + v;
}
function noop$2() {
}
function safe_not_equal$3(P, _) {
  return P != P ? _ == _ : P !== _ || P && typeof P == "object" || typeof P == "function";
}
const is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (P) => requestAnimationFrame(P) : noop$2;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(P) {
  tasks.forEach((_) => {
    _.c(P) || (tasks.delete(_), _.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(P) {
  let _;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((s) => {
      tasks.add(_ = { c: P, f: s });
    }),
    abort() {
      tasks.delete(_);
    }
  };
}
const subscriber_queue = [];
function writable(P, _ = noop$2) {
  let s;
  const v = /* @__PURE__ */ new Set();
  function M(h) {
    if (safe_not_equal$3(P, h) && (P = h, s)) {
      const g = !subscriber_queue.length;
      for (const C of v)
        C[1](), subscriber_queue.push(C, P);
      if (g) {
        for (let C = 0; C < subscriber_queue.length; C += 2)
          subscriber_queue[C][0](subscriber_queue[C + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function E(h) {
    M(h(P));
  }
  function A(h, g = noop$2) {
    const C = [h, g];
    return v.add(C), v.size === 1 && (s = _(M, E) || noop$2), h(P), () => {
      v.delete(C), v.size === 0 && s && (s(), s = null);
    };
  }
  return { set: M, update: E, subscribe: A };
}
function is_date(P) {
  return Object.prototype.toString.call(P) === "[object Date]";
}
function tick_spring(P, _, s, v) {
  if (typeof s == "number" || is_date(s)) {
    const M = v - s, E = (s - _) / (P.dt || 1 / 60), A = P.opts.stiffness * M, h = P.opts.damping * E, g = (A - h) * P.inv_mass, C = (E + g) * P.dt;
    return Math.abs(C) < P.opts.precision && Math.abs(M) < P.opts.precision ? v : (P.settled = !1, is_date(s) ? new Date(s.getTime() + C) : s + C);
  } else {
    if (Array.isArray(s))
      return s.map(
        (M, E) => tick_spring(P, _[E], s[E], v[E])
      );
    if (typeof s == "object") {
      const M = {};
      for (const E in s)
        M[E] = tick_spring(P, _[E], s[E], v[E]);
      return M;
    } else
      throw new Error(`Cannot spring ${typeof s} values`);
  }
}
function spring(P, _ = {}) {
  const s = writable(P), { stiffness: v = 0.15, damping: M = 0.8, precision: E = 0.01 } = _;
  let A, h, g, C = P, c = P, S = 1, y = 0, b = !1;
  function w(r, u = {}) {
    c = r;
    const o = g = {};
    return P == null || u.hard || t.stiffness >= 1 && t.damping >= 1 ? (b = !0, A = now(), C = r, s.set(P = c), Promise.resolve()) : (u.soft && (y = 1 / ((u.soft === !0 ? 0.5 : +u.soft) * 60), S = 0), h || (A = now(), b = !1, h = loop((l) => {
      if (b)
        return b = !1, h = null, !1;
      S = Math.min(S + y, 1);
      const e = {
        inv_mass: S,
        opts: t,
        settled: !0,
        dt: (l - A) * 60 / 1e3
      }, n = tick_spring(e, C, P, c);
      return A = l, C = P, s.set(P = n), e.settled && (h = null), !e.settled;
    })), new Promise((l) => {
      h.promise.then(() => {
        o === g && l();
      });
    }));
  }
  const t = {
    set: w,
    update: (r, u) => w(r(c, P), u),
    subscribe: s.subscribe,
    stiffness: v,
    damping: M,
    precision: E
  };
  return t;
}
const Loader_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$2,
  append: append$1,
  attr: attr$1,
  component_subscribe,
  detach: detach$2,
  element: element$1,
  init: init$2,
  insert: insert$2,
  noop: noop$1,
  safe_not_equal: safe_not_equal$2,
  set_style: set_style$1,
  svg_element,
  toggle_class: toggle_class$1
} = window.__gradio__svelte__internal, { onMount } = window.__gradio__svelte__internal;
function create_fragment$2(P) {
  let _, s, v, M, E, A, h, g, C, c, S, y;
  return {
    c() {
      _ = element$1("div"), s = svg_element("svg"), v = svg_element("g"), M = svg_element("path"), E = svg_element("path"), A = svg_element("path"), h = svg_element("path"), g = svg_element("g"), C = svg_element("path"), c = svg_element("path"), S = svg_element("path"), y = svg_element("path"), attr$1(M, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$1(M, "fill", "#FF7C00"), attr$1(M, "fill-opacity", "0.4"), attr$1(M, "class", "svelte-43sxxs"), attr$1(E, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$1(E, "fill", "#FF7C00"), attr$1(E, "class", "svelte-43sxxs"), attr$1(A, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$1(A, "fill", "#FF7C00"), attr$1(A, "fill-opacity", "0.4"), attr$1(A, "class", "svelte-43sxxs"), attr$1(h, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$1(h, "fill", "#FF7C00"), attr$1(h, "class", "svelte-43sxxs"), set_style$1(v, "transform", "translate(" + /*$top*/
      P[1][0] + "px, " + /*$top*/
      P[1][1] + "px)"), attr$1(C, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$1(C, "fill", "#FF7C00"), attr$1(C, "fill-opacity", "0.4"), attr$1(C, "class", "svelte-43sxxs"), attr$1(c, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$1(c, "fill", "#FF7C00"), attr$1(c, "class", "svelte-43sxxs"), attr$1(S, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$1(S, "fill", "#FF7C00"), attr$1(S, "fill-opacity", "0.4"), attr$1(S, "class", "svelte-43sxxs"), attr$1(y, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$1(y, "fill", "#FF7C00"), attr$1(y, "class", "svelte-43sxxs"), set_style$1(g, "transform", "translate(" + /*$bottom*/
      P[2][0] + "px, " + /*$bottom*/
      P[2][1] + "px)"), attr$1(s, "viewBox", "-1200 -1200 3000 3000"), attr$1(s, "fill", "none"), attr$1(s, "xmlns", "http://www.w3.org/2000/svg"), attr$1(s, "class", "svelte-43sxxs"), attr$1(_, "class", "svelte-43sxxs"), toggle_class$1(
        _,
        "margin",
        /*margin*/
        P[0]
      );
    },
    m(b, w) {
      insert$2(b, _, w), append$1(_, s), append$1(s, v), append$1(v, M), append$1(v, E), append$1(v, A), append$1(v, h), append$1(s, g), append$1(g, C), append$1(g, c), append$1(g, S), append$1(g, y);
    },
    p(b, [w]) {
      w & /*$top*/
      2 && set_style$1(v, "transform", "translate(" + /*$top*/
      b[1][0] + "px, " + /*$top*/
      b[1][1] + "px)"), w & /*$bottom*/
      4 && set_style$1(g, "transform", "translate(" + /*$bottom*/
      b[2][0] + "px, " + /*$bottom*/
      b[2][1] + "px)"), w & /*margin*/
      1 && toggle_class$1(
        _,
        "margin",
        /*margin*/
        b[0]
      );
    },
    i: noop$1,
    o: noop$1,
    d(b) {
      b && detach$2(_);
    }
  };
}
function instance$2(P, _, s) {
  let v, M, { margin: E = !0 } = _;
  const A = spring([0, 0]);
  component_subscribe(P, A, (y) => s(1, v = y));
  const h = spring([0, 0]);
  component_subscribe(P, h, (y) => s(2, M = y));
  let g;
  async function C() {
    await Promise.all([A.set([125, 140]), h.set([-125, -140])]), await Promise.all([A.set([-125, 140]), h.set([125, -140])]), await Promise.all([A.set([-125, 0]), h.set([125, -0])]), await Promise.all([A.set([125, 0]), h.set([-125, 0])]);
  }
  async function c() {
    await C(), g || c();
  }
  async function S() {
    await Promise.all([A.set([125, 0]), h.set([-125, 0])]), c();
  }
  return onMount(() => (S(), () => g = !0)), P.$$set = (y) => {
    "margin" in y && s(0, E = y.margin);
  }, [E, v, M, A, h];
}
class Loader extends SvelteComponent$2 {
  constructor(_) {
    super(), init$2(this, _, instance$2, create_fragment$2, safe_not_equal$2, { margin: 0 });
  }
}
const index_svelte_svelte_type_style_lang = "", {
  SvelteComponent: SvelteComponent$1,
  append,
  attr,
  binding_callbacks,
  check_outros,
  create_component: create_component$1,
  create_slot,
  destroy_component: destroy_component$1,
  destroy_each,
  detach: detach$1,
  element,
  empty,
  ensure_array_like,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init: init$1,
  insert: insert$1,
  mount_component: mount_component$1,
  noop,
  safe_not_equal: safe_not_equal$1,
  set_data,
  set_style,
  space: space$1,
  text,
  toggle_class,
  transition_in: transition_in$1,
  transition_out: transition_out$1,
  update_slot_base
} = window.__gradio__svelte__internal, { tick } = window.__gradio__svelte__internal, { onDestroy } = window.__gradio__svelte__internal, get_error_slot_changes = (P) => ({}), get_error_slot_context = (P) => ({});
function get_each_context(P, _, s) {
  const v = P.slice();
  return v[38] = _[s], v[40] = s, v;
}
function get_each_context_1(P, _, s) {
  const v = P.slice();
  return v[38] = _[s], v;
}
function create_if_block_17(P) {
  let _, s = (
    /*i18n*/
    P[1]("common.error") + ""
  ), v, M, E;
  const A = (
    /*#slots*/
    P[29].error
  ), h = create_slot(
    A,
    P,
    /*$$scope*/
    P[28],
    get_error_slot_context
  );
  return {
    c() {
      _ = element("span"), v = text(s), M = space$1(), h && h.c(), attr(_, "class", "error svelte-1txqlrd");
    },
    m(g, C) {
      insert$1(g, _, C), append(_, v), insert$1(g, M, C), h && h.m(g, C), E = !0;
    },
    p(g, C) {
      (!E || C[0] & /*i18n*/
      2) && s !== (s = /*i18n*/
      g[1]("common.error") + "") && set_data(v, s), h && h.p && (!E || C[0] & /*$$scope*/
      268435456) && update_slot_base(
        h,
        A,
        g,
        /*$$scope*/
        g[28],
        E ? get_slot_changes(
          A,
          /*$$scope*/
          g[28],
          C,
          get_error_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          g[28]
        ),
        get_error_slot_context
      );
    },
    i(g) {
      E || (transition_in$1(h, g), E = !0);
    },
    o(g) {
      transition_out$1(h, g), E = !1;
    },
    d(g) {
      g && (detach$1(_), detach$1(M)), h && h.d(g);
    }
  };
}
function create_if_block(P) {
  let _, s, v, M, E, A, h, g, C, c = (
    /*variant*/
    P[8] === "default" && /*show_eta_bar*/
    P[18] && /*show_progress*/
    P[6] === "full" && create_if_block_16(P)
  );
  function S(l, e) {
    if (
      /*progress*/
      l[7]
    )
      return create_if_block_11;
    if (
      /*queue_position*/
      l[2] !== null && /*queue_size*/
      l[3] !== void 0 && /*queue_position*/
      l[2] >= 0
    )
      return create_if_block_14;
    if (
      /*queue_position*/
      l[2] === 0
    )
      return create_if_block_15;
  }
  let y = S(P), b = y && y(P), w = (
    /*timer*/
    P[5] && create_if_block_10(P)
  );
  const t = [create_if_block_2, create_if_block_9], r = [];
  function u(l, e) {
    return (
      /*last_progress_level*/
      l[15] != null ? 0 : (
        /*show_progress*/
        l[6] === "full" ? 1 : -1
      )
    );
  }
  ~(E = u(P)) && (A = r[E] = t[E](P));
  let o = !/*timer*/
  P[5] && create_if_block_1(P);
  return {
    c() {
      c && c.c(), _ = space$1(), s = element("div"), b && b.c(), v = space$1(), w && w.c(), M = space$1(), A && A.c(), h = space$1(), o && o.c(), g = empty(), attr(s, "class", "progress-text svelte-1txqlrd"), toggle_class(
        s,
        "meta-text-center",
        /*variant*/
        P[8] === "center"
      ), toggle_class(
        s,
        "meta-text",
        /*variant*/
        P[8] === "default"
      );
    },
    m(l, e) {
      c && c.m(l, e), insert$1(l, _, e), insert$1(l, s, e), b && b.m(s, null), append(s, v), w && w.m(s, null), insert$1(l, M, e), ~E && r[E].m(l, e), insert$1(l, h, e), o && o.m(l, e), insert$1(l, g, e), C = !0;
    },
    p(l, e) {
      /*variant*/
      l[8] === "default" && /*show_eta_bar*/
      l[18] && /*show_progress*/
      l[6] === "full" ? c ? c.p(l, e) : (c = create_if_block_16(l), c.c(), c.m(_.parentNode, _)) : c && (c.d(1), c = null), y === (y = S(l)) && b ? b.p(l, e) : (b && b.d(1), b = y && y(l), b && (b.c(), b.m(s, v))), /*timer*/
      l[5] ? w ? w.p(l, e) : (w = create_if_block_10(l), w.c(), w.m(s, null)) : w && (w.d(1), w = null), (!C || e[0] & /*variant*/
      256) && toggle_class(
        s,
        "meta-text-center",
        /*variant*/
        l[8] === "center"
      ), (!C || e[0] & /*variant*/
      256) && toggle_class(
        s,
        "meta-text",
        /*variant*/
        l[8] === "default"
      );
      let n = E;
      E = u(l), E === n ? ~E && r[E].p(l, e) : (A && (group_outros(), transition_out$1(r[n], 1, 1, () => {
        r[n] = null;
      }), check_outros()), ~E ? (A = r[E], A ? A.p(l, e) : (A = r[E] = t[E](l), A.c()), transition_in$1(A, 1), A.m(h.parentNode, h)) : A = null), /*timer*/
      l[5] ? o && (o.d(1), o = null) : o ? o.p(l, e) : (o = create_if_block_1(l), o.c(), o.m(g.parentNode, g));
    },
    i(l) {
      C || (transition_in$1(A), C = !0);
    },
    o(l) {
      transition_out$1(A), C = !1;
    },
    d(l) {
      l && (detach$1(_), detach$1(s), detach$1(M), detach$1(h), detach$1(g)), c && c.d(l), b && b.d(), w && w.d(), ~E && r[E].d(l), o && o.d(l);
    }
  };
}
function create_if_block_16(P) {
  let _, s = `translateX(${/*eta_level*/
  (P[17] || 0) * 100 - 100}%)`;
  return {
    c() {
      _ = element("div"), attr(_, "class", "eta-bar svelte-1txqlrd"), set_style(_, "transform", s);
    },
    m(v, M) {
      insert$1(v, _, M);
    },
    p(v, M) {
      M[0] & /*eta_level*/
      131072 && s !== (s = `translateX(${/*eta_level*/
      (v[17] || 0) * 100 - 100}%)`) && set_style(_, "transform", s);
    },
    d(v) {
      v && detach$1(_);
    }
  };
}
function create_if_block_15(P) {
  let _;
  return {
    c() {
      _ = text("processing |");
    },
    m(s, v) {
      insert$1(s, _, v);
    },
    p: noop,
    d(s) {
      s && detach$1(_);
    }
  };
}
function create_if_block_14(P) {
  let _, s = (
    /*queue_position*/
    P[2] + 1 + ""
  ), v, M, E, A;
  return {
    c() {
      _ = text("queue: "), v = text(s), M = text("/"), E = text(
        /*queue_size*/
        P[3]
      ), A = text(" |");
    },
    m(h, g) {
      insert$1(h, _, g), insert$1(h, v, g), insert$1(h, M, g), insert$1(h, E, g), insert$1(h, A, g);
    },
    p(h, g) {
      g[0] & /*queue_position*/
      4 && s !== (s = /*queue_position*/
      h[2] + 1 + "") && set_data(v, s), g[0] & /*queue_size*/
      8 && set_data(
        E,
        /*queue_size*/
        h[3]
      );
    },
    d(h) {
      h && (detach$1(_), detach$1(v), detach$1(M), detach$1(E), detach$1(A));
    }
  };
}
function create_if_block_11(P) {
  let _, s = ensure_array_like(
    /*progress*/
    P[7]
  ), v = [];
  for (let M = 0; M < s.length; M += 1)
    v[M] = create_each_block_1(get_each_context_1(P, s, M));
  return {
    c() {
      for (let M = 0; M < v.length; M += 1)
        v[M].c();
      _ = empty();
    },
    m(M, E) {
      for (let A = 0; A < v.length; A += 1)
        v[A] && v[A].m(M, E);
      insert$1(M, _, E);
    },
    p(M, E) {
      if (E[0] & /*progress*/
      128) {
        s = ensure_array_like(
          /*progress*/
          M[7]
        );
        let A;
        for (A = 0; A < s.length; A += 1) {
          const h = get_each_context_1(M, s, A);
          v[A] ? v[A].p(h, E) : (v[A] = create_each_block_1(h), v[A].c(), v[A].m(_.parentNode, _));
        }
        for (; A < v.length; A += 1)
          v[A].d(1);
        v.length = s.length;
      }
    },
    d(M) {
      M && detach$1(_), destroy_each(v, M);
    }
  };
}
function create_if_block_12(P) {
  let _, s = (
    /*p*/
    P[38].unit + ""
  ), v, M, E = " ", A;
  function h(c, S) {
    return (
      /*p*/
      c[38].length != null ? create_if_block_13 : create_else_block
    );
  }
  let g = h(P), C = g(P);
  return {
    c() {
      C.c(), _ = space$1(), v = text(s), M = text(" | "), A = text(E);
    },
    m(c, S) {
      C.m(c, S), insert$1(c, _, S), insert$1(c, v, S), insert$1(c, M, S), insert$1(c, A, S);
    },
    p(c, S) {
      g === (g = h(c)) && C ? C.p(c, S) : (C.d(1), C = g(c), C && (C.c(), C.m(_.parentNode, _))), S[0] & /*progress*/
      128 && s !== (s = /*p*/
      c[38].unit + "") && set_data(v, s);
    },
    d(c) {
      c && (detach$1(_), detach$1(v), detach$1(M), detach$1(A)), C.d(c);
    }
  };
}
function create_else_block(P) {
  let _ = pretty_si(
    /*p*/
    P[38].index || 0
  ) + "", s;
  return {
    c() {
      s = text(_);
    },
    m(v, M) {
      insert$1(v, s, M);
    },
    p(v, M) {
      M[0] & /*progress*/
      128 && _ !== (_ = pretty_si(
        /*p*/
        v[38].index || 0
      ) + "") && set_data(s, _);
    },
    d(v) {
      v && detach$1(s);
    }
  };
}
function create_if_block_13(P) {
  let _ = pretty_si(
    /*p*/
    P[38].index || 0
  ) + "", s, v, M = pretty_si(
    /*p*/
    P[38].length
  ) + "", E;
  return {
    c() {
      s = text(_), v = text("/"), E = text(M);
    },
    m(A, h) {
      insert$1(A, s, h), insert$1(A, v, h), insert$1(A, E, h);
    },
    p(A, h) {
      h[0] & /*progress*/
      128 && _ !== (_ = pretty_si(
        /*p*/
        A[38].index || 0
      ) + "") && set_data(s, _), h[0] & /*progress*/
      128 && M !== (M = pretty_si(
        /*p*/
        A[38].length
      ) + "") && set_data(E, M);
    },
    d(A) {
      A && (detach$1(s), detach$1(v), detach$1(E));
    }
  };
}
function create_each_block_1(P) {
  let _, s = (
    /*p*/
    P[38].index != null && create_if_block_12(P)
  );
  return {
    c() {
      s && s.c(), _ = empty();
    },
    m(v, M) {
      s && s.m(v, M), insert$1(v, _, M);
    },
    p(v, M) {
      /*p*/
      v[38].index != null ? s ? s.p(v, M) : (s = create_if_block_12(v), s.c(), s.m(_.parentNode, _)) : s && (s.d(1), s = null);
    },
    d(v) {
      v && detach$1(_), s && s.d(v);
    }
  };
}
function create_if_block_10(P) {
  let _, s = (
    /*eta*/
    P[0] ? `/${/*formatted_eta*/
    P[19]}` : ""
  ), v, M;
  return {
    c() {
      _ = text(
        /*formatted_timer*/
        P[20]
      ), v = text(s), M = text("s");
    },
    m(E, A) {
      insert$1(E, _, A), insert$1(E, v, A), insert$1(E, M, A);
    },
    p(E, A) {
      A[0] & /*formatted_timer*/
      1048576 && set_data(
        _,
        /*formatted_timer*/
        E[20]
      ), A[0] & /*eta, formatted_eta*/
      524289 && s !== (s = /*eta*/
      E[0] ? `/${/*formatted_eta*/
      E[19]}` : "") && set_data(v, s);
    },
    d(E) {
      E && (detach$1(_), detach$1(v), detach$1(M));
    }
  };
}
function create_if_block_9(P) {
  let _, s;
  return _ = new Loader({
    props: { margin: (
      /*variant*/
      P[8] === "default"
    ) }
  }), {
    c() {
      create_component$1(_.$$.fragment);
    },
    m(v, M) {
      mount_component$1(_, v, M), s = !0;
    },
    p(v, M) {
      const E = {};
      M[0] & /*variant*/
      256 && (E.margin = /*variant*/
      v[8] === "default"), _.$set(E);
    },
    i(v) {
      s || (transition_in$1(_.$$.fragment, v), s = !0);
    },
    o(v) {
      transition_out$1(_.$$.fragment, v), s = !1;
    },
    d(v) {
      destroy_component$1(_, v);
    }
  };
}
function create_if_block_2(P) {
  let _, s, v, M, E, A = `${/*last_progress_level*/
  P[15] * 100}%`, h = (
    /*progress*/
    P[7] != null && create_if_block_3(P)
  );
  return {
    c() {
      _ = element("div"), s = element("div"), h && h.c(), v = space$1(), M = element("div"), E = element("div"), attr(s, "class", "progress-level-inner svelte-1txqlrd"), attr(E, "class", "progress-bar svelte-1txqlrd"), set_style(E, "width", A), attr(M, "class", "progress-bar-wrap svelte-1txqlrd"), attr(_, "class", "progress-level svelte-1txqlrd");
    },
    m(g, C) {
      insert$1(g, _, C), append(_, s), h && h.m(s, null), append(_, v), append(_, M), append(M, E), P[30](E);
    },
    p(g, C) {
      /*progress*/
      g[7] != null ? h ? h.p(g, C) : (h = create_if_block_3(g), h.c(), h.m(s, null)) : h && (h.d(1), h = null), C[0] & /*last_progress_level*/
      32768 && A !== (A = `${/*last_progress_level*/
      g[15] * 100}%`) && set_style(E, "width", A);
    },
    i: noop,
    o: noop,
    d(g) {
      g && detach$1(_), h && h.d(), P[30](null);
    }
  };
}
function create_if_block_3(P) {
  let _, s = ensure_array_like(
    /*progress*/
    P[7]
  ), v = [];
  for (let M = 0; M < s.length; M += 1)
    v[M] = create_each_block(get_each_context(P, s, M));
  return {
    c() {
      for (let M = 0; M < v.length; M += 1)
        v[M].c();
      _ = empty();
    },
    m(M, E) {
      for (let A = 0; A < v.length; A += 1)
        v[A] && v[A].m(M, E);
      insert$1(M, _, E);
    },
    p(M, E) {
      if (E[0] & /*progress_level, progress*/
      16512) {
        s = ensure_array_like(
          /*progress*/
          M[7]
        );
        let A;
        for (A = 0; A < s.length; A += 1) {
          const h = get_each_context(M, s, A);
          v[A] ? v[A].p(h, E) : (v[A] = create_each_block(h), v[A].c(), v[A].m(_.parentNode, _));
        }
        for (; A < v.length; A += 1)
          v[A].d(1);
        v.length = s.length;
      }
    },
    d(M) {
      M && detach$1(_), destroy_each(v, M);
    }
  };
}
function create_if_block_4(P) {
  let _, s, v, M, E = (
    /*i*/
    P[40] !== 0 && create_if_block_8()
  ), A = (
    /*p*/
    P[38].desc != null && create_if_block_7(P)
  ), h = (
    /*p*/
    P[38].desc != null && /*progress_level*/
    P[14] && /*progress_level*/
    P[14][
      /*i*/
      P[40]
    ] != null && create_if_block_6()
  ), g = (
    /*progress_level*/
    P[14] != null && create_if_block_5(P)
  );
  return {
    c() {
      E && E.c(), _ = space$1(), A && A.c(), s = space$1(), h && h.c(), v = space$1(), g && g.c(), M = empty();
    },
    m(C, c) {
      E && E.m(C, c), insert$1(C, _, c), A && A.m(C, c), insert$1(C, s, c), h && h.m(C, c), insert$1(C, v, c), g && g.m(C, c), insert$1(C, M, c);
    },
    p(C, c) {
      /*p*/
      C[38].desc != null ? A ? A.p(C, c) : (A = create_if_block_7(C), A.c(), A.m(s.parentNode, s)) : A && (A.d(1), A = null), /*p*/
      C[38].desc != null && /*progress_level*/
      C[14] && /*progress_level*/
      C[14][
        /*i*/
        C[40]
      ] != null ? h || (h = create_if_block_6(), h.c(), h.m(v.parentNode, v)) : h && (h.d(1), h = null), /*progress_level*/
      C[14] != null ? g ? g.p(C, c) : (g = create_if_block_5(C), g.c(), g.m(M.parentNode, M)) : g && (g.d(1), g = null);
    },
    d(C) {
      C && (detach$1(_), detach$1(s), detach$1(v), detach$1(M)), E && E.d(C), A && A.d(C), h && h.d(C), g && g.d(C);
    }
  };
}
function create_if_block_8(P) {
  let _;
  return {
    c() {
      _ = text(" /");
    },
    m(s, v) {
      insert$1(s, _, v);
    },
    d(s) {
      s && detach$1(_);
    }
  };
}
function create_if_block_7(P) {
  let _ = (
    /*p*/
    P[38].desc + ""
  ), s;
  return {
    c() {
      s = text(_);
    },
    m(v, M) {
      insert$1(v, s, M);
    },
    p(v, M) {
      M[0] & /*progress*/
      128 && _ !== (_ = /*p*/
      v[38].desc + "") && set_data(s, _);
    },
    d(v) {
      v && detach$1(s);
    }
  };
}
function create_if_block_6(P) {
  let _;
  return {
    c() {
      _ = text("-");
    },
    m(s, v) {
      insert$1(s, _, v);
    },
    d(s) {
      s && detach$1(_);
    }
  };
}
function create_if_block_5(P) {
  let _ = (100 * /*progress_level*/
  (P[14][
    /*i*/
    P[40]
  ] || 0)).toFixed(1) + "", s, v;
  return {
    c() {
      s = text(_), v = text("%");
    },
    m(M, E) {
      insert$1(M, s, E), insert$1(M, v, E);
    },
    p(M, E) {
      E[0] & /*progress_level*/
      16384 && _ !== (_ = (100 * /*progress_level*/
      (M[14][
        /*i*/
        M[40]
      ] || 0)).toFixed(1) + "") && set_data(s, _);
    },
    d(M) {
      M && (detach$1(s), detach$1(v));
    }
  };
}
function create_each_block(P) {
  let _, s = (
    /*p*/
    (P[38].desc != null || /*progress_level*/
    P[14] && /*progress_level*/
    P[14][
      /*i*/
      P[40]
    ] != null) && create_if_block_4(P)
  );
  return {
    c() {
      s && s.c(), _ = empty();
    },
    m(v, M) {
      s && s.m(v, M), insert$1(v, _, M);
    },
    p(v, M) {
      /*p*/
      v[38].desc != null || /*progress_level*/
      v[14] && /*progress_level*/
      v[14][
        /*i*/
        v[40]
      ] != null ? s ? s.p(v, M) : (s = create_if_block_4(v), s.c(), s.m(_.parentNode, _)) : s && (s.d(1), s = null);
    },
    d(v) {
      v && detach$1(_), s && s.d(v);
    }
  };
}
function create_if_block_1(P) {
  let _, s;
  return {
    c() {
      _ = element("p"), s = text(
        /*loading_text*/
        P[9]
      ), attr(_, "class", "loading svelte-1txqlrd");
    },
    m(v, M) {
      insert$1(v, _, M), append(_, s);
    },
    p(v, M) {
      M[0] & /*loading_text*/
      512 && set_data(
        s,
        /*loading_text*/
        v[9]
      );
    },
    d(v) {
      v && detach$1(_);
    }
  };
}
function create_fragment$1(P) {
  let _, s, v, M, E;
  const A = [create_if_block, create_if_block_17], h = [];
  function g(C, c) {
    return (
      /*status*/
      C[4] === "pending" ? 0 : (
        /*status*/
        C[4] === "error" ? 1 : -1
      )
    );
  }
  return ~(s = g(P)) && (v = h[s] = A[s](P)), {
    c() {
      _ = element("div"), v && v.c(), attr(_, "class", M = "wrap " + /*variant*/
      P[8] + " " + /*show_progress*/
      P[6] + " svelte-1txqlrd"), toggle_class(_, "hide", !/*status*/
      P[4] || /*status*/
      P[4] === "complete" || /*show_progress*/
      P[6] === "hidden"), toggle_class(
        _,
        "translucent",
        /*variant*/
        P[8] === "center" && /*status*/
        (P[4] === "pending" || /*status*/
        P[4] === "error") || /*translucent*/
        P[11] || /*show_progress*/
        P[6] === "minimal"
      ), toggle_class(
        _,
        "generating",
        /*status*/
        P[4] === "generating"
      ), toggle_class(
        _,
        "border",
        /*border*/
        P[12]
      ), set_style(
        _,
        "position",
        /*absolute*/
        P[10] ? "absolute" : "static"
      ), set_style(
        _,
        "padding",
        /*absolute*/
        P[10] ? "0" : "var(--size-8) 0"
      );
    },
    m(C, c) {
      insert$1(C, _, c), ~s && h[s].m(_, null), P[31](_), E = !0;
    },
    p(C, c) {
      let S = s;
      s = g(C), s === S ? ~s && h[s].p(C, c) : (v && (group_outros(), transition_out$1(h[S], 1, 1, () => {
        h[S] = null;
      }), check_outros()), ~s ? (v = h[s], v ? v.p(C, c) : (v = h[s] = A[s](C), v.c()), transition_in$1(v, 1), v.m(_, null)) : v = null), (!E || c[0] & /*variant, show_progress*/
      320 && M !== (M = "wrap " + /*variant*/
      C[8] + " " + /*show_progress*/
      C[6] + " svelte-1txqlrd")) && attr(_, "class", M), (!E || c[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class(_, "hide", !/*status*/
      C[4] || /*status*/
      C[4] === "complete" || /*show_progress*/
      C[6] === "hidden"), (!E || c[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
      2384) && toggle_class(
        _,
        "translucent",
        /*variant*/
        C[8] === "center" && /*status*/
        (C[4] === "pending" || /*status*/
        C[4] === "error") || /*translucent*/
        C[11] || /*show_progress*/
        C[6] === "minimal"
      ), (!E || c[0] & /*variant, show_progress, status*/
      336) && toggle_class(
        _,
        "generating",
        /*status*/
        C[4] === "generating"
      ), (!E || c[0] & /*variant, show_progress, border*/
      4416) && toggle_class(
        _,
        "border",
        /*border*/
        C[12]
      ), c[0] & /*absolute*/
      1024 && set_style(
        _,
        "position",
        /*absolute*/
        C[10] ? "absolute" : "static"
      ), c[0] & /*absolute*/
      1024 && set_style(
        _,
        "padding",
        /*absolute*/
        C[10] ? "0" : "var(--size-8) 0"
      );
    },
    i(C) {
      E || (transition_in$1(v), E = !0);
    },
    o(C) {
      transition_out$1(v), E = !1;
    },
    d(C) {
      C && detach$1(_), ~s && h[s].d(), P[31](null);
    }
  };
}
let items = [], called = !1;
async function scroll_into_view(P, _ = !0) {
  if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && _ !== !0)) {
    if (items.push(P), !called)
      called = !0;
    else
      return;
    await tick(), requestAnimationFrame(() => {
      let s = [0, 0];
      for (let v = 0; v < items.length; v++) {
        const E = items[v].getBoundingClientRect();
        (v === 0 || E.top + window.scrollY <= s[0]) && (s[0] = E.top + window.scrollY, s[1] = v);
      }
      window.scrollTo({ top: s[0] - 20, behavior: "smooth" }), called = !1, items = [];
    });
  }
}
function instance$1(P, _, s) {
  let v, { $$slots: M = {}, $$scope: E } = _, { i18n: A } = _, { eta: h = null } = _, { queue: g = !1 } = _, { queue_position: C } = _, { queue_size: c } = _, { status: S } = _, { scroll_to_output: y = !1 } = _, { timer: b = !0 } = _, { show_progress: w = "full" } = _, { message: t = null } = _, { progress: r = null } = _, { variant: u = "default" } = _, { loading_text: o = "Loading..." } = _, { absolute: l = !0 } = _, { translucent: e = !1 } = _, { border: n = !1 } = _, { autoscroll: a } = _, p, x = !1, D = 0, O = 0, R = null, z = 0, T = null, B, W = null, k = !0;
  const F = () => {
    s(25, D = performance.now()), s(26, O = 0), x = !0, U();
  };
  function U() {
    requestAnimationFrame(() => {
      s(26, O = (performance.now() - D) / 1e3), x && U();
    });
  }
  function V() {
    s(26, O = 0), x && (x = !1);
  }
  onDestroy(() => {
    x && V();
  });
  let H = null;
  function G(J) {
    binding_callbacks[J ? "unshift" : "push"](() => {
      W = J, s(16, W), s(7, r), s(14, T), s(15, B);
    });
  }
  function Y(J) {
    binding_callbacks[J ? "unshift" : "push"](() => {
      p = J, s(13, p);
    });
  }
  return P.$$set = (J) => {
    "i18n" in J && s(1, A = J.i18n), "eta" in J && s(0, h = J.eta), "queue" in J && s(21, g = J.queue), "queue_position" in J && s(2, C = J.queue_position), "queue_size" in J && s(3, c = J.queue_size), "status" in J && s(4, S = J.status), "scroll_to_output" in J && s(22, y = J.scroll_to_output), "timer" in J && s(5, b = J.timer), "show_progress" in J && s(6, w = J.show_progress), "message" in J && s(23, t = J.message), "progress" in J && s(7, r = J.progress), "variant" in J && s(8, u = J.variant), "loading_text" in J && s(9, o = J.loading_text), "absolute" in J && s(10, l = J.absolute), "translucent" in J && s(11, e = J.translucent), "border" in J && s(12, n = J.border), "autoscroll" in J && s(24, a = J.autoscroll), "$$scope" in J && s(28, E = J.$$scope);
  }, P.$$.update = () => {
    P.$$.dirty[0] & /*eta, old_eta, queue, timer_start*/
    169869313 && (h === null ? s(0, h = R) : g && s(0, h = (performance.now() - D) / 1e3 + h), h != null && (s(19, H = h.toFixed(1)), s(27, R = h))), P.$$.dirty[0] & /*eta, timer_diff*/
    67108865 && s(17, z = h === null || h <= 0 || !O ? null : Math.min(O / h, 1)), P.$$.dirty[0] & /*progress*/
    128 && r != null && s(18, k = !1), P.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
    114816 && (r != null ? s(14, T = r.map((J) => {
      if (J.index != null && J.length != null)
        return J.index / J.length;
      if (J.progress != null)
        return J.progress;
    })) : s(14, T = null), T ? (s(15, B = T[T.length - 1]), W && (B === 0 ? s(16, W.style.transition = "0", W) : s(16, W.style.transition = "150ms", W))) : s(15, B = void 0)), P.$$.dirty[0] & /*status*/
    16 && (S === "pending" ? F() : V()), P.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
    20979728 && p && y && (S === "pending" || S === "complete") && scroll_into_view(p, a), P.$$.dirty[0] & /*status, message*/
    8388624, P.$$.dirty[0] & /*timer_diff*/
    67108864 && s(20, v = O.toFixed(1));
  }, [
    h,
    A,
    C,
    c,
    S,
    b,
    w,
    r,
    u,
    o,
    l,
    e,
    n,
    p,
    T,
    B,
    W,
    z,
    k,
    H,
    v,
    g,
    y,
    t,
    a,
    D,
    O,
    R,
    E,
    M,
    G,
    Y
  ];
}
class Static extends SvelteComponent$1 {
  constructor(_) {
    super(), init$1(
      this,
      _,
      instance$1,
      create_fragment$1,
      safe_not_equal$1,
      {
        i18n: 1,
        eta: 0,
        queue: 21,
        queue_position: 2,
        queue_size: 3,
        status: 4,
        scroll_to_output: 22,
        timer: 5,
        show_progress: 6,
        message: 23,
        progress: 7,
        variant: 8,
        loading_text: 9,
        absolute: 10,
        translucent: 11,
        border: 12,
        autoscroll: 24
      },
      null,
      [-1, -1]
    );
  }
}
const ToastContent_svelte_svelte_type_style_lang = "", Toast_svelte_svelte_type_style_lang = "", {
  SvelteComponent,
  assign,
  create_component,
  destroy_component,
  detach,
  get_spread_object,
  get_spread_update,
  init,
  insert,
  mount_component,
  safe_not_equal,
  space,
  transition_in,
  transition_out
} = window.__gradio__svelte__internal;
function create_default_slot(P) {
  let _, s, v, M;
  const E = [
    {
      autoscroll: (
        /*gradio*/
        P[14].autoscroll
      )
    },
    { i18n: (
      /*gradio*/
      P[14].i18n
    ) },
    /*loading_status*/
    P[0]
  ];
  let A = {};
  for (let h = 0; h < E.length; h += 1)
    A = assign(A, E[h]);
  return _ = new Static({ props: A }), v = new Gallery({
    props: {
      label: (
        /*label*/
        P[2]
      ),
      value: (
        /*value*/
        P[6]
      ),
      show_label: (
        /*show_label*/
        P[1]
      ),
      columns: (
        /*columns*/
        P[10]
      ),
      rows: (
        /*rows*/
        P[11]
      ),
      height: (
        /*height*/
        P[12]
      ),
      automatic_rotation: (
        /*automatic_rotation*/
        P[13]
      )
    }
  }), v.$on(
    "change",
    /*change_handler*/
    P[15]
  ), v.$on(
    "select",
    /*select_handler*/
    P[16]
  ), v.$on(
    "share",
    /*share_handler*/
    P[17]
  ), v.$on(
    "error",
    /*error_handler*/
    P[18]
  ), {
    c() {
      create_component(_.$$.fragment), s = space(), create_component(v.$$.fragment);
    },
    m(h, g) {
      mount_component(_, h, g), insert(h, s, g), mount_component(v, h, g), M = !0;
    },
    p(h, g) {
      const C = g & /*gradio, loading_status*/
      16385 ? get_spread_update(E, [
        g & /*gradio*/
        16384 && {
          autoscroll: (
            /*gradio*/
            h[14].autoscroll
          )
        },
        g & /*gradio*/
        16384 && { i18n: (
          /*gradio*/
          h[14].i18n
        ) },
        g & /*loading_status*/
        1 && get_spread_object(
          /*loading_status*/
          h[0]
        )
      ]) : {};
      _.$set(C);
      const c = {};
      g & /*label*/
      4 && (c.label = /*label*/
      h[2]), g & /*value*/
      64 && (c.value = /*value*/
      h[6]), g & /*show_label*/
      2 && (c.show_label = /*show_label*/
      h[1]), g & /*columns*/
      1024 && (c.columns = /*columns*/
      h[10]), g & /*rows*/
      2048 && (c.rows = /*rows*/
      h[11]), g & /*height*/
      4096 && (c.height = /*height*/
      h[12]), g & /*automatic_rotation*/
      8192 && (c.automatic_rotation = /*automatic_rotation*/
      h[13]), v.$set(c);
    },
    i(h) {
      M || (transition_in(_.$$.fragment, h), transition_in(v.$$.fragment, h), M = !0);
    },
    o(h) {
      transition_out(_.$$.fragment, h), transition_out(v.$$.fragment, h), M = !1;
    },
    d(h) {
      h && detach(s), destroy_component(_, h), destroy_component(v, h);
    }
  };
}
function create_fragment(P) {
  let _, s;
  return _ = new Block({
    props: {
      visible: (
        /*visible*/
        P[5]
      ),
      variant: "solid",
      padding: !1,
      elem_id: (
        /*elem_id*/
        P[3]
      ),
      elem_classes: (
        /*elem_classes*/
        P[4]
      ),
      container: (
        /*container*/
        P[7]
      ),
      scale: (
        /*scale*/
        P[8]
      ),
      min_width: (
        /*min_width*/
        P[9]
      ),
      allow_overflow: !1,
      height: typeof /*height*/
      P[12] == "number" ? (
        /*height*/
        P[12]
      ) : void 0,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: P }
    }
  }), {
    c() {
      create_component(_.$$.fragment);
    },
    m(v, M) {
      mount_component(_, v, M), s = !0;
    },
    p(v, [M]) {
      const E = {};
      M & /*visible*/
      32 && (E.visible = /*visible*/
      v[5]), M & /*elem_id*/
      8 && (E.elem_id = /*elem_id*/
      v[3]), M & /*elem_classes*/
      16 && (E.elem_classes = /*elem_classes*/
      v[4]), M & /*container*/
      128 && (E.container = /*container*/
      v[7]), M & /*scale*/
      256 && (E.scale = /*scale*/
      v[8]), M & /*min_width*/
      512 && (E.min_width = /*min_width*/
      v[9]), M & /*height*/
      4096 && (E.height = typeof /*height*/
      v[12] == "number" ? (
        /*height*/
        v[12]
      ) : void 0), M & /*$$scope, label, value, show_label, columns, rows, height, automatic_rotation, gradio, loading_status*/
      556103 && (E.$$scope = { dirty: M, ctx: v }), _.$set(E);
    },
    i(v) {
      s || (transition_in(_.$$.fragment, v), s = !0);
    },
    o(v) {
      transition_out(_.$$.fragment, v), s = !1;
    },
    d(v) {
      destroy_component(_, v);
    }
  };
}
function instance(P, _, s) {
  let { loading_status: v } = _, { show_label: M } = _, { label: E } = _, { elem_id: A = "" } = _, { elem_classes: h = [] } = _, { visible: g = !0 } = _, { value: C = null } = _, { container: c = !0 } = _, { scale: S = null } = _, { min_width: y = void 0 } = _, { columns: b = [2] } = _, { rows: w = void 0 } = _, { height: t = "auto" } = _, { automatic_rotation: r = !0 } = _, { gradio: u } = _;
  const o = () => u.dispatch("change", C), l = (a) => u.dispatch("select", a.detail), e = (a) => u.dispatch("share", a.detail), n = (a) => u.dispatch("error", a.detail);
  return P.$$set = (a) => {
    "loading_status" in a && s(0, v = a.loading_status), "show_label" in a && s(1, M = a.show_label), "label" in a && s(2, E = a.label), "elem_id" in a && s(3, A = a.elem_id), "elem_classes" in a && s(4, h = a.elem_classes), "visible" in a && s(5, g = a.visible), "value" in a && s(6, C = a.value), "container" in a && s(7, c = a.container), "scale" in a && s(8, S = a.scale), "min_width" in a && s(9, y = a.min_width), "columns" in a && s(10, b = a.columns), "rows" in a && s(11, w = a.rows), "height" in a && s(12, t = a.height), "automatic_rotation" in a && s(13, r = a.automatic_rotation), "gradio" in a && s(14, u = a.gradio);
  }, [
    v,
    M,
    E,
    A,
    h,
    g,
    C,
    c,
    S,
    y,
    b,
    w,
    t,
    r,
    u,
    o,
    l,
    e,
    n
  ];
}
class Index extends SvelteComponent {
  constructor(_) {
    super(), init(this, _, instance, create_fragment, safe_not_equal, {
      loading_status: 0,
      show_label: 1,
      label: 2,
      elem_id: 3,
      elem_classes: 4,
      visible: 5,
      value: 6,
      container: 7,
      scale: 8,
      min_width: 9,
      columns: 10,
      rows: 11,
      height: 12,
      automatic_rotation: 13,
      gradio: 14
    });
  }
}
export {
  Gallery as BaseGallery,
  Index as default
};
